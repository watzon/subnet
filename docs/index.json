{"repository_name":"github.com/watzon/subnet","body":"# Subnet\n\nSubnet is a Crystal library designed to make the use of IPv4 and IPv6 (soon) addresses simple, powerful and enjoyable. It provides a complete set of methods to handle IP addresses for any need, from simple scripting to full network design.\n\nSubnet is written with a full OO interface, and its code is easy to read, maintain and extend. The documentation is full of examples, to let you start being productive immediately.\n\nThis document provides a brief introduction to the library and examples of typical usage. You can check out the full documentation [here](https://watzon.github.io/subnet/).\n\n## Installation\n\n1. Add the dependency to your `shard.yml`:\n\n   ```yaml\n   dependencies:\n     subnet:\n       github: watzon/subnet\n   ```\n\n2. Run `shards install`\n\n## Usage\n\n```crystal\nrequire \"subnet\"\n```\n\nTODO: Write usage instructions here\n\n## Development\n\nTODO: Write development instructions here\n\n## Contributing\n\n1. Fork it (<https://github.com/watzon/subnet/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n## Contributors\n\n- [Chris Watson](https://github.com/watzon) - creator and maintainer\n","program":{"html_id":"github.com/watzon/subnet/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"github.com/watzon/subnet","program":true,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"github.com/watzon/subnet/Subnet","path":"Subnet.html","kind":"module","full_name":"Subnet","name":"Subnet","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"subnet/version.cr","line_number":1,"url":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/version.cr"},{"filename":"subnet/prefix.cr","line_number":3,"url":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr"},{"filename":"subnet/ipv4.cr","line_number":3,"url":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr"},{"filename":"subnet/ipv6.cr","line_number":1,"url":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv6.cr"},{"filename":"subnet.cr","line_number":7,"url":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet.cr"}],"repository_name":"github.com/watzon/subnet","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[{"id":"VERSION","name":"VERSION","value":"\"0.1.0\"","doc":null,"summary":null}],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[{"html_id":"github.com/watzon/subnet/Subnet/IPv4","kind":"class","full_name":"Subnet::IPv4","name":"IPv4"},{"html_id":"github.com/watzon/subnet/Subnet/IPv6","kind":"class","full_name":"Subnet::IPv6","name":"IPv6"}],"namespace":null,"doc":"TODO: Write documentation for `Subnet`","summary":"<p><span class=\"flag orange\">TODO</span>  Write documentation for <code><a href=\"Subnet.html\">Subnet</a></code></p>","class_methods":[{"id":"deprecate(message=nil)-class-method","html_id":"deprecate(message=nil)-class-method","name":"deprecate","doc":"Deprecate method\n:nodoc:","summary":"<p>Deprecate method :nodoc:</p>","abstract":false,"args":[{"name":"message","doc":null,"default_value":"nil","external_name":"message","restriction":""}],"args_string":"(message = <span class=\"n\">nil</span>)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet.cr#L227","def":{"name":"deprecate","args":[{"name":"message","doc":null,"default_value":"nil","external_name":"message","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"message || (message = \"You are using deprecated behavior which will be removed from the next major or minor release.\")\nwarn(\"DEPRECATION WARNING: #{message}\")\n"}},{"id":"ntoa(uint)-class-method","html_id":"ntoa(uint)-class-method","name":"ntoa","doc":"Converts a unit32 to IPv4\n\n```\nSubnet::ntoa(167837953)\n  # => \"10.1.1.1\"\n```","summary":"<p>Converts a unit32 to IPv4</p>","abstract":false,"args":[{"name":"uint","doc":null,"default_value":"","external_name":"uint","restriction":""}],"args_string":"(uint)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet.cr#L54","def":{"name":"ntoa","args":[{"name":"uint","doc":null,"default_value":"","external_name":"uint","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if (uint.is_a?(Number) && uint <= 4294967295_i64) && uint >= 0\nelse\n  raise(ArgumentError.new(\"not a long integer: #{uint.inspect}\"))\nend\nret = [] of UInt8 | UInt16 | UInt32 | UInt64 | Int32 | Int64\n4.times do\n  ret.unshift(uint & 255)\n  uint = uint >> 8\nend\nret.join('.')\n"}},{"id":"parse(str)-class-method","html_id":"parse(str)-class-method","name":"parse","doc":"Parse the argument string to create a new\nIPv4, IPv6 or Mapped IP object\n\n```\nip  = Subnet.parse 167837953 # 10.1.1.1\nip  = Subnet.parse \"172.16.10.1/24\"\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\nip_mapped = Subnet.parse \"::ffff:172.16.10.1/128\"\n```\n\nAll the object created will be instances of the\ncorrect class:\n\n```\nip.class\n  # => Subnet::IPv4\nip6.class\n  # => Subnet::IPv6\nip_mapped.class\n  # => Subnet::IPv6::Mapped\n```","summary":"<p>Parse the argument string to create a new IPv4, IPv6 or Mapped IP object</p>","abstract":false,"args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"args_string":"(str)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet.cr#L29","def":{"name":"parse","args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if str.is_a?(Number)\n  return Subnet::IPv4.new(ntoa(str))\nend\ncase str\nwhen /\\./\n  Subnet::IPv4.new(str)\nelse\n  raise(ArgumentError.new(\"Unknown IP Address #{str}\"))\nend\n"}},{"id":"valid?(addr)-class-method","html_id":"valid?(addr)-class-method","name":"valid?","doc":"Checks if the given string is either a valid IP, either a valid IPv4 subnet\n\nExample:\n\n```\nSubnet::valid? \"10.0.0.0/24\"\n  # => true\n\nSubnet::valid? \"2002::1\"\n  # => true\n\nSubnet::valid? \"10.0.0.256\"\n  # => false\n\nSubnet::valid? \"10.0.0.0/999\"\n  # => false\n```","summary":"<p>Checks if the given string is either a valid IP, either a valid IPv4 subnet</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet.cr#L109","def":{"name":"valid?","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"((valid_ip?(addr)) || (valid_ipv4_subnet?(addr))) || (valid_ipv6_subnet?(addr))"}},{"id":"valid_ip?(addr)-class-method","html_id":"valid_ip?(addr)-class-method","name":"valid_ip?","doc":"Checks if the given string is a valid IP address,\neither IPv4 or IPv6\n\nExample:\n\n```\nSubnet::valid_ip? \"2002::1\"\n  # => true\n\nSubnet::valid_ip? \"10.0.0.256\"\n  # => false\n```","summary":"<p>Checks if the given string is a valid IP address, either IPv4 or IPv6</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet.cr#L125","def":{"name":"valid_ip?","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(valid_ipv4?(addr)) || (valid_ipv6?(addr))"}},{"id":"valid_ipv4?(addr)-class-method","html_id":"valid_ipv4?(addr)-class-method","name":"valid_ipv4?","doc":"Checks if the given string is a valid IPv4 address\n\nExample:\n\n```\nSubnet::valid_ipv4? \"2002::1\"\n  # => false\n\nSubnet::valid_ipv4? \"172.16.10.1\"\n  # => true\n```","summary":"<p>Checks if the given string is a valid IPv4 address</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet.cr#L184","def":{"name":"valid_ipv4?","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if (/\\A(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\Z/) =~ addr\n  return $~.captures.all? do |i|\n    if i.nil?\n    else\n      i.to_i < 256\n    end\n  end\nend\nfalse\n"}},{"id":"valid_ipv4_netmask?(addr)-class-method","html_id":"valid_ipv4_netmask?(addr)-class-method","name":"valid_ipv4_netmask?","doc":"Checks if the argument is a valid IPv4 netmask\nexpressed in dotted decimal format.\n\n```\nSubnet.valid_ipv4_netmask? \"255.255.0.0\"\n  # => true\n```","summary":"<p>Checks if the argument is a valid IPv4 netmask expressed in dotted decimal format.</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet.cr#L198","def":{"name":"valid_ipv4_netmask?","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"begin\n  arr = (addr.split(\".\")).map do |i|\n    i.to_u8\n  end\n  bin = ((Slice.new(arr.to_unsafe, arr.size)).hexstring.to_u32(16)).to_s(2)\n  bits = bin.scan(/01/)\n  bits.empty? && (valid_ipv4?(addr))\nrescue\n  return false\nend"}},{"id":"valid_ipv4_subnet?(addr)-class-method","html_id":"valid_ipv4_subnet?(addr)-class-method","name":"valid_ipv4_subnet?","doc":"Checks if the given string is a valid IPv4 subnet\n\nExample:\n\n```\nSubnet::valid_ipv4_subnet? \"10.0.0.0/24\"\n  # => true\n\nSubnet::valid_ipv4_subnet? \"10.0.0.0/255.255.255.0\"\n  # => true\n\nSubnet::valid_ipv4_subnet? \"10.0.0.0/64\"\n  # => false\n```","summary":"<p>Checks if the given string is a valid IPv4 subnet</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet.cr#L143","def":{"name":"valid_ipv4_subnet?","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"ip, netmask = addr.split('/')\n(valid_ipv4?(ip)) && ((!(netmask =~ (/\\A([12]?\\d|3[0-2])\\z/)).nil?) || (valid_ipv4_netmask?(netmask)))\n"}},{"id":"valid_ipv6?(addr)-class-method","html_id":"valid_ipv6?(addr)-class-method","name":"valid_ipv6?","doc":"Checks if the given string is a valid IPv6 address\n\nExample:\n\n```\nSubnet::valid_ipv6? \"2002::1\"\n  # => true\n\nSubnet::valid_ipv6? \"2002::DEAD::BEEF\"\n  # => false\n```","summary":"<p>Checks if the given string is a valid IPv6 address</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet.cr#L218","def":{"name":"valid_ipv6?","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if (/^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/) =~ addr\n  return true\nend\nfalse\n"}},{"id":"valid_ipv6_subnet?(addr)-class-method","html_id":"valid_ipv6_subnet?(addr)-class-method","name":"valid_ipv6_subnet?","doc":"Checks if the given string is a valid IPv6 subnet\n\nExample:\n\n```\nSubnet::valid_ipv6_subnet? \"::/0\"\n  # => true\n\nSubnet::valid_ipv6_subnet? \"dead:beef:cafe:babe::/64\"\n  # => true\n\nSubnet::valid_ipv6_subnet? \"2001::1/129\"\n  # => false\n```","summary":"<p>Checks if the given string is a valid IPv6 subnet</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet.cr#L163","def":{"name":"valid_ipv6_subnet?","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"begin\n  ip, netmask = addr.split('/')\n  netmask = netmask.to_i(10)\n  ((valid_ipv6?(ip)) && netmask >= 0) && netmask <= 128\nrescue ArgumentError\n  false\nend"}}],"constructors":[],"instance_methods":[{"id":"ipv4?-instance-method","html_id":"ipv4?-instance-method","name":"ipv4?","doc":"True if the object is an IPv4 address\n\n```\nip = Subnet.parse(\"192.168.10.100/24\")\n\nip.ipv4?\n  # => true\n```","summary":"<p>True if the object is an IPv4 address</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet.cr#L75","def":{"name":"ipv4?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.is_a?(Subnet::IPv4)"}},{"id":"ipv6?-instance-method","html_id":"ipv6?-instance-method","name":"ipv6?","doc":"\nTrue if the object is an IPv6 address\n\n```\nip = Subnet.parse(\"192.168.10.100/24\")\n\nip.ipv6?\n  # => false\n```","summary":"<p>True if the object is an IPv6 address</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet.cr#L88","def":{"name":"ipv6?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.is_a?(Subnet::IPv6)"}}],"macros":[],"types":[{"html_id":"github.com/watzon/subnet/Subnet/IPv4","path":"Subnet/IPv4.html","kind":"class","full_name":"Subnet::IPv4","name":"IPv4","abstract":false,"superclass":{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/subnet/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/subnet/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"subnet/ipv4.cr","line_number":5,"url":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr"}],"repository_name":"github.com/watzon/subnet","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[{"id":"CLASSFUL","name":"CLASSFUL","value":"{/^0../ => 8, /^10./ => 16, /^110/ => 24}","doc":"This Hash contains the prefix values for Classful networks\n\nNote: classes C, D and E will all have a default\nprefix of /24 or 255.255.255.0","summary":"<p>This Hash contains the prefix values for Classful networks</p>"},{"id":"IPV4REGEX","name":"IPV4REGEX","value":"/((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)\\.){3}(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)/","doc":"Regular expression to match an IPv4 address","summary":"<p>Regular expression to match an IPv4 address</p>"}],"included_modules":[{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/subnet/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"}],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},"doc":"Represents a IPv4 style IP address.","summary":"<p>Represents a IPv4 style IP address.</p>","class_methods":[{"id":"extract(str)-class-method","html_id":"extract(str)-class-method","name":"extract","doc":"Extract an IPv4 address from a string and\nreturns a new object\n\nExample:\n\n```\nstr = \"foobar172.16.10.1barbaz\"\nip = Subnet::IPv4.extract str\n\nip.to_s\n  #=> \"172.16.10.1\"\n```","summary":"<p>Extract an IPv4 address from a string and returns a new object</p>","abstract":false,"args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"args_string":"(str)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L953","def":{"name":"extract","args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"addr = (IPV4REGEX.match(str)).try do |__arg1|\n  __arg1[0].to_s\nend\nif addr\n  IPv4.new(addr)\nend\n"}},{"id":"parse_classful(ip)-class-method","html_id":"parse_classful(ip)-class-method","name":"parse_classful","doc":"Creates a new IPv4 address object by parsing the\naddress in a classful way.\n\nClassful addresses have a fixed netmask based on the\nclass they belong to:\n\n* Class A, from 0.0.0.0 to 127.255.255.255\n* Class B, from 128.0.0.0 to 191.255.255.255\n* Class C, D and E, from 192.0.0.0 to 255.255.255.254\n\nExample:\n\n```\nip = Subnet::IPv4.parse_classful \"10.0.0.1\"\n\nip.netmask\n  #=> \"255.0.0.0\"\nip.a?\n  #=> true\n```\n\nNote that classes C, D and E will all have a default\nprefix of /24 or 255.255.255.0\n","summary":"<p>Creates a new IPv4 address object by parsing the address in a classful way.</p>","abstract":false,"args":[{"name":"ip","doc":null,"default_value":"","external_name":"ip","restriction":""}],"args_string":"(ip)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L1082","def":{"name":"parse_classful","args":[{"name":"ip","doc":null,"default_value":"","external_name":"ip","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if Subnet.valid_ipv4?(ip)\nelse\n  raise(ArgumentError.new(\"Invalid IP #{ip.inspect}\"))\nend\naddress = ip.strip\nprefix = CLASSFUL.find do |h, k|\n  h === (\"%08b\" % (address.split('.')).first.to_i)\nend.try(&.last)\nnew(\"#{address}/#{prefix}\")\n"}},{"id":"parse_data(bytes,prefix=32)-class-method","html_id":"parse_data(bytes,prefix=32)-class-method","name":"parse_data","doc":"Creates a new IPv4 object from binary data,\nlike the one you get from a network stream.\n\nFor example, on a network stream the IP 172.16.0.1\nis represented with the binary `Bytes[172, 16, 10, 1]`.\n\n```\nip = Subnet::IPv4.parse_data Bytes[172, 16, 10, 1]\nip.prefix = 24\n\nip.to_string\n  #=> \"172.16.10.1/24\"\n```","summary":"<p>Creates a new IPv4 object from binary data, like the one you get from a network stream.</p>","abstract":false,"args":[{"name":"bytes","doc":null,"default_value":"","external_name":"bytes","restriction":""},{"name":"prefix","doc":null,"default_value":"32","external_name":"prefix","restriction":""}],"args_string":"(bytes, prefix = <span class=\"n\">32</span>)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L937","def":{"name":"parse_data","args":[{"name":"bytes","doc":null,"default_value":"","external_name":"bytes","restriction":""},{"name":"prefix","doc":null,"default_value":"32","external_name":"prefix","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"new((bytes.join('.')) + \"/#{prefix}\")"}},{"id":"parse_u32(u32,prefix=32)-class-method","html_id":"parse_u32(u32,prefix=32)-class-method","name":"parse_u32","doc":"Creates a new IPv4 object from an\nunsigned 32bits integer.\n\n```\nip = Subnet::IPv4.parse_u32(167772160)\n\nip.prefix = 8\nip.to_string\n  #=> \"10.0.0.0/8\"\n```\n\nThe `prefix` parameter is optional:\n\n```\nip = Subnet::IPv4.parse_u32(167772160, 8)\n\nip.to_string\n  #=> \"10.0.0.0/8\"\n```","summary":"<p>Creates a new IPv4 object from an unsigned 32bits integer.</p>","abstract":false,"args":[{"name":"u32","doc":null,"default_value":"","external_name":"u32","restriction":""},{"name":"prefix","doc":null,"default_value":"32","external_name":"prefix","restriction":""}],"args_string":"(u32, prefix = <span class=\"n\">32</span>)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L918","def":{"name":"parse_u32","args":[{"name":"u32","doc":null,"default_value":"","external_name":"u32","restriction":""},{"name":"prefix","doc":null,"default_value":"32","external_name":"prefix","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"octets = uninitialized ::StaticArray(UInt8, 4)\nIO::ByteFormat::BigEndian.encode(u32.to_u32, octets.to_slice)\nnew((octets.join('.')) + \"/#{prefix}\")\n"}},{"id":"summarize(args)-class-method","html_id":"summarize(args)-class-method","name":"summarize","doc":"Summarization (or aggregation) is the process when two or more\nnetworks are taken together to check if a supernet, including all\nand only these networks, exists. If it exists then this supernet\nis called the summarized (or aggregated) network.\n\nIt is very important to understand that summarization can only\noccur if there are no holes in the aggregated network, or, in other\nwords, if the given networks fill completely the address space\nof the supernet. So the two rules are:\n\n1) The aggregate network must contain +all+ the IP addresses of the\n   original networks;\n2) The aggregate network must contain +only+ the IP addresses of the\n   original networks;\n\nA few examples will help clarify the above. Let's consider for\ninstance the following two networks:\n\n```\nip1 = Subnet.parse(\"172.16.10.0/24\")\nip2 = Subnet.parse(\"172.16.11.0/24\")\n```\n\nThese two networks can be expressed using only one IP address\nnetwork if we change the prefix. Let Ruby do the work:\n\n```\nSubnet::IPv4.summarize(ip1,ip2).to_s\n  #=> \"172.16.10.0/23\"\n```\n\nWe note how the network \"172.16.10.0/23\" includes all the addresses\nspecified in the above networks, and (more important) includes\nONLY those addresses.\n\nIf we summarized `ip1` and `ip2` with the following network:\n\n```\n\"172.16.0.0/16\"\n```\n\nwe would have satisfied rule #1 above, but not rule #2. So \"172.16.0.0/16\"\nis not an aggregate network for `ip1` and `ip2`.\n\nIf it's not possible to compute a single aggregated network for all the\noriginal networks, the method returns an array with all the aggregate\nnetworks found. For example, the following four networks can be\naggregated in a single /22:\n\n```\nip1 = Subnet.parse(\"10.0.0.1/24\")\nip2 = Subnet.parse(\"10.0.1.1/24\")\nip3 = Subnet.parse(\"10.0.2.1/24\")\nip4 = Subnet.parse(\"10.0.3.1/24\")\n\nSubnet::IPv4.summarize(ip1,ip2,ip3,ip4).to_string\n  #=> [\"10.0.0.0/22\"]\n```\n\nBut the following networks can't be summarized in a single network:\n\n```\nip1 = Subnet.parse(\"10.0.1.1/24\")\nip2 = Subnet.parse(\"10.0.2.1/24\")\nip3 = Subnet.parse(\"10.0.3.1/24\")\nip4 = Subnet.parse(\"10.0.4.1/24\")\n\nSubnet::IPv4.summarize(ip1,ip2,ip3,ip4).map{|i| i.to_string}\n  #=> [\"10.0.1.0/24\",\"10.0.2.0/23\",\"10.0.4.0/24\"]\n```","summary":"<p>Summarization (or aggregation) is the process when two or more networks are taken together to check if a supernet, including all and only these networks, exists.</p>","abstract":false,"args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(args)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L1028","def":{"name":"summarize","args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if args.size < 1\n  raise(\"Can't summarize an empty network\")\nend\nif args.size == 1\n  return [args.first.not_nil!.network]\nend\ni = 0\nargs = args.to_a\nresult = args.dup.sort.map do |ip|\n  ip.network\nend\nwhile i < (result.size - 1)\n  sum = result[i] + result[i + 1]\n  if sum.size == 1\n    result[i..(i + 1)] = sum.first\n  end\n  i = i + 1\nend\nresult = result.flatten\nif result.size == args.size\n  return result\nelse\n  return self.summarize(result)\nend\n"}},{"id":"summarize(*args)-class-method","html_id":"summarize(*args)-class-method","name":"summarize","doc":"Summarization (or aggregation) is the process when two or more\nnetworks are taken together to check if a supernet, including all\nand only these networks, exists. If it exists then this supernet\nis called the summarized (or aggregated) network.\n\nIt is very important to understand that summarization can only\noccur if there are no holes in the aggregated network, or, in other\nwords, if the given networks fill completely the address space\nof the supernet. So the two rules are:\n\n1) The aggregate network must contain +all+ the IP addresses of the\n   original networks;\n2) The aggregate network must contain +only+ the IP addresses of the\n   original networks;\n\nA few examples will help clarify the above. Let's consider for\ninstance the following two networks:\n\n```\nip1 = Subnet.parse(\"172.16.10.0/24\")\nip2 = Subnet.parse(\"172.16.11.0/24\")\n```\n\nThese two networks can be expressed using only one IP address\nnetwork if we change the prefix. Let Ruby do the work:\n\n```\nSubnet::IPv4.summarize(ip1,ip2).to_s\n  #=> \"172.16.10.0/23\"\n```\n\nWe note how the network \"172.16.10.0/23\" includes all the addresses\nspecified in the above networks, and (more important) includes\nONLY those addresses.\n\nIf we summarized `ip1` and `ip2` with the following network:\n\n```\n\"172.16.0.0/16\"\n```\n\nwe would have satisfied rule #1 above, but not rule #2. So \"172.16.0.0/16\"\nis not an aggregate network for `ip1` and `ip2`.\n\nIf it's not possible to compute a single aggregated network for all the\noriginal networks, the method returns an array with all the aggregate\nnetworks found. For example, the following four networks can be\naggregated in a single /22:\n\n```\nip1 = Subnet.parse(\"10.0.0.1/24\")\nip2 = Subnet.parse(\"10.0.1.1/24\")\nip3 = Subnet.parse(\"10.0.2.1/24\")\nip4 = Subnet.parse(\"10.0.3.1/24\")\n\nSubnet::IPv4.summarize(ip1,ip2,ip3,ip4).to_string\n  #=> [\"10.0.0.0/22\"]\n```\n\nBut the following networks can't be summarized in a single network:\n\n```\nip1 = Subnet.parse(\"10.0.1.1/24\")\nip2 = Subnet.parse(\"10.0.2.1/24\")\nip3 = Subnet.parse(\"10.0.3.1/24\")\nip4 = Subnet.parse(\"10.0.4.1/24\")\n\nSubnet::IPv4.summarize(ip1,ip2,ip3,ip4).map{|i| i.to_string}\n  #=> [\"10.0.1.0/24\",\"10.0.2.0/23\",\"10.0.4.0/24\"]\n```","summary":"<p>Summarization (or aggregation) is the process when two or more networks are taken together to check if a supernet, including all and only these networks, exists.</p>","abstract":false,"args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(*args)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L1054","def":{"name":"summarize","args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":null,"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"summarize(args)"}}],"constructors":[{"id":"new(str:String)-class-method","html_id":"new(str:String)-class-method","name":"new","doc":"Creates a new IPv4 address object.\n\nAn IPv4 address can be expressed in any of the following forms:\n\n* \"10.1.1.1/24\": ip `address` and `prefix`. This is the common and\nsuggested way to create an object.\n\n* \"10.1.1.1/255.255.255.0\": ip `address` and `netmask`. Although\nconvenient sometimes, this format is less clear than the previous\none.\n\n* \"10.1.1.1\": if the address alone is specified, the prefix will be\nset as default 32, also known as the host prefix\n\nExamples:\n\n```crystal\n# These two are the same\nip = Subnet::IPv4.new(\"10.0.0.1/24\")\nip = Subnet.parse(\"10.0.0.1/24\")\n\n# These two are the same\nSubnet::IPv4.new \"10.0.0.1/8\"\nSubnet::IPv4.new \"10.0.0.1/255.0.0.0\"\n```","summary":"<p>Creates a new IPv4 address object.</p>","abstract":false,"args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":"String"}],"args_string":"(str : String)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L100","def":{"name":"new","args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":"String"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(str)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"+(oth)-instance-method","html_id":"+(oth)-instance-method","name":"+","doc":"Returns a new IPv4 object which is the result\nof the summarization, if possible, of the two\nobjects\n\nExample:\n\n```\nip1 = Subnet.parse(\"172.16.10.1/24\")\nip2 = Subnet.parse(\"172.16.11.2/24\")\n\np (ip1 + ip2).map {|i| i.to_string}\n  #=> [\"172.16.10.0/23\"]\n```\n\nIf the networks are not contiguous, returns\nthe two network numbers from the objects\n\n```\nip1 = Subnet.parse(\"10.0.0.1/24\")\nip2 = Subnet.parse(\"10.0.2.1/24\")\n\np (ip1 + ip2).map {|i| i.to_string}\n  #=> [\"10.0.0.0/24\",\"10.0.2.0/24\"]\n```","summary":"<p>Returns a new IPv4 object which is the result of the summarization, if possible, of the two objects</p>","abstract":false,"args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"args_string":"(oth)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L831","def":{"name":"+","args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"tup = [self, oth].sort.map do |i|\n  i.network\nend\naggregate(tup[0], tup[1])\n"}},{"id":"-(oth)-instance-method","html_id":"-(oth)-instance-method","name":"-","doc":"Returns the difference between two IP addresses\nin unsigned int 32 bits format\n\nExample:\n\n```\nip1 = Subnet.parse(\"172.16.10.0/24\")\nip2 = Subnet.parse(\"172.16.11.0/24\")\n\nputs ip1 - ip2\n  #=> 256\n```","summary":"<p>Returns the difference between two IP addresses in unsigned int 32 bits format</p>","abstract":false,"args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"args_string":"(oth)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L803","def":{"name":"-","args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"return (to_u32 - oth.to_u32).abs"}},{"id":"/(subnets)-instance-method","html_id":"/(subnets)-instance-method","name":"/","doc":"Splits a network into different subnets\n\nIf the IP Address is a network, it can be divided into\nmultiple networks. If `self` is not a network, this\nmethod will calculate the network from the IP and then\nsubnet it.\n\nIf `subnets` is an power of two number, the resulting\nnetworks will be divided evenly from the supernet.\n\n```\nnetwork = Subnet.parse(\"172.16.10.0/24\")\n\nnetwork / 4   # implies map{|i| i.to_string}\n  #=> [\"172.16.10.0/26\",\n  #=>  \"172.16.10.64/26\",\n  #=>  \"172.16.10.128/26\",\n  #=>  \"172.16.10.192/26\"]\n```\n\nIf `num` is any other number, the supernet will be\ndivided into some networks with a even number of hosts and\nother networks with the remaining addresses.\n\n```\nnetwork = Subnet.parse(\"172.16.10.0/24\")\n\nnetwork / 3   # implies map{|i| i.to_string}\n  #=> [\"172.16.10.0/26\",\n  #=>  \"172.16.10.64/26\",\n  #=>  \"172.16.10.128/25\"]\n```\n\nReturns an array of IPv4 objects","summary":"<p>Splits a network into different subnets</p>","abstract":false,"args":[{"name":"subnets","doc":null,"default_value":"","external_name":"subnets","restriction":""}],"args_string":"(subnets)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L718","def":{"name":"/","args":[{"name":"subnets","doc":null,"default_value":"","external_name":"subnets","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"split(subnets)"}},{"id":"(oth)-instance-method","html_id":"(oth)-instance-method","name":"<=>","doc":"Spaceship operator to compare IPv4 objects\n\nComparing IPv4 addresses is useful to ordinate\nthem into lists that match our intuitive\nperception of ordered IP addresses.\n\nThe first comparison criteria is the u32 value.\nFor example, 10.100.100.1 will be considered\nto be less than 172.16.0.1, because, in a ordered list,\nwe expect 10.100.100.1 to come before 172.16.0.1.\n\nThe second criteria, in case two IPv4 objects\nhave identical addresses, is the prefix. An higher\nprefix will be considered greater than a lower\nprefix. This is because we expect to see\n10.100.100.0/24 come before 10.100.100.0/25.\n\nExample:\n\n```crystal\nip1 = Subnet.parse \"10.100.100.1/8\"\nip2 = Subnet.parse \"172.16.0.1/16\"\nip3 = Subnet.parse \"10.100.100.1/16\"\n\nip1 < ip2\n  #=> true\nip1 > ip3\n  #=> false\n\n[ip1,ip2,ip3].sort.map{|i| i.to_s }\n  #=> [\"10.100.100.1/8\",\"10.100.100.1/16\",\"172.16.0.1/16\"]\n```","summary":"<p>Spaceship operator to compare IPv4 objects</p>","abstract":false,"args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"args_string":"(oth)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L473","def":{"name":"<=>","args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if oth.is_a?(IPv4)\nelse\n  return nil\nend\nif to_u32 == oth.to_u32\n  return prefix <=> oth.prefix\nend\nto_u32 <=> oth.to_u32\n"}},{"id":"[](index)-instance-method","html_id":"[](index)-instance-method","name":"[]","doc":"Returns the octet specified by index\n\n```crystal\nip = Subnet.parse(\"172.16.100.50/24\")\n\nip[0]\n  #=> 172\nip[1]\n  #=> 16\nip[2]\n  #=> 100\nip[3]\n  #=> 50\n```","summary":"<p>Returns the octet specified by index</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"args_string":"(index)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L242","def":{"name":"[]","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@octets[index]"}},{"id":"[]=(index,value)-instance-method","html_id":"[]=(index,value)-instance-method","name":"[]=","doc":"Updated the octet specified at index\n\n```crystal\nip = Subnet.parse(\"172.16.100.50/24\")\nip[2] = 200\n\n#=>  #<Subnet::IPv4:0x00000000000000 @address=\"172.16.200.1\",\n#=>       @prefix=32, @octets=[172, 16, 200, 1], @u32=2886780929>\n```","summary":"<p>Updated the octet specified at index</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":""}],"args_string":"(index, value)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L260","def":{"name":"[]=","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@octets[index] = value.to_i\ninitialize(\"#{@octets.join('.')}/#{prefix}\")\n"}},{"id":"a?-instance-method","html_id":"a?-instance-method","name":"a?","doc":"Checks whether the ip address belongs to a\nRFC 791 CLASS A network, no matter\nwhat the subnet mask is.\n\nExample:\n\n```\nip = Subnet.parse(\"10.0.0.1/24\")\n\nip.a?\n  #=> true\n```","summary":"<p>Checks whether the ip address belongs to a RFC 791 CLASS A network, no matter what the subnet mask is.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L848","def":{"name":"a?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(CLASSFUL.key_for(8)) === bits"}},{"id":"address:String-instance-method","html_id":"address:String-instance-method","name":"address","doc":"Returns the address portion of the IPv4 object\nas a string.\n\n```crystal\nip = Subnet.parse(\"172.16.100.4/22\")\n\nip.address\n  #=> \"172.16.100.4\"\n```","summary":"<p>Returns the address portion of the IPv4 object as a string.</p>","abstract":false,"args":[],"args_string":" : String","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L34","def":{"name":"address","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"String","visibility":"Public","body":"@address"}},{"id":"allocate(skip=0)-instance-method","html_id":"allocate(skip=0)-instance-method","name":"allocate","doc":"Allocates a new ip from the current subnet. Optional skip parameter\ncan be used to skip addresses.\n\nWill return `nil` exception when all addresses have been allocated\n\nExample:\n\n```\nip = Subnet.parse(\"10.0.0.0/24\")\nip.allocate\n  #=> \"10.0.0.1/24\"\nip.allocate\n  #=> \"10.0.0.2/24\"\nip.allocate(2)\n  #=> \"10.0.0.5/24\"\n```\n\nUses an internal @allocator which tracks the state of allocated\naddresses.\n","summary":"<p>Allocates a new ip from the current subnet.</p>","abstract":false,"args":[{"name":"skip","doc":null,"default_value":"0","external_name":"skip","restriction":""}],"args_string":"(skip = <span class=\"n\">0</span>)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L1109","def":{"name":"allocate","args":[{"name":"skip","doc":null,"default_value":"0","external_name":"skip","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@allocator = @allocator + (1 + skip)\nnext_ip = network_u32 + @allocator\nif next_ip > (broadcast_u32 + 1)\n  return nil\nend\nIPv4.parse_u32(network_u32 + @allocator, @prefix)\n"}},{"id":"arpa-instance-method","html_id":"arpa-instance-method","name":"arpa","doc":"Returns the IP address in in-addr.arpa format\nfor DNS lookups\n\n```\nip = Subnet.parse(\"172.16.100.50/24\")\n\nip.reverse\n  #=> \"50.100.16.172.in-addr.arpa\"\n```","summary":"<p>Returns the IP address in in-addr.arpa format for DNS lookups</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L647","def":{"name":"arpa","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"reverse"}},{"id":"b?-instance-method","html_id":"b?-instance-method","name":"b?","doc":"Checks whether the ip address belongs to a\nRFC 791 CLASS B network, no matter\nwhat the subnet mask is.\n\nExample:\n\n```\nip = Subnet.parse(\"172.16.10.1/24\")\n\nip.b?\n  #=> true\n```","summary":"<p>Checks whether the ip address belongs to a RFC 791 CLASS B network, no matter what the subnet mask is.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L864","def":{"name":"b?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(CLASSFUL.key_for(16)) === bits"}},{"id":"bits-instance-method","html_id":"bits-instance-method","name":"bits","doc":"Returns the address portion of an IP in binary format,\nas a string containing a sequence of 0 and 1\n\n```crystal\nip = Subnet.parse(\"127.0.0.1\")\n\nip.bits\n  #=> \"01111111000000000000000000000001\"\n```","summary":"<p>Returns the address portion of an IP in binary format, as a string containing a sequence of 0 and 1</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L274","def":{"name":"bits","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"\"%032.32b\" % (hexstring.to_i64(16))"}},{"id":"broadcast-instance-method","html_id":"broadcast-instance-method","name":"broadcast","doc":"Returns the broadcast address for the given IP.\n\n```crystal\nip = Subnet.parse(\"172.16.10.64/24\")\n\nip.broadcast.to_s\n  #=> \"172.16.10.255\"\n```","summary":"<p>Returns the broadcast address for the given IP.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L286","def":{"name":"broadcast","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"case\nwhen prefix <= 30\n  IPv4.parse_u32(broadcast_u32, @prefix)\nwhen prefix == 31\n  IPv4.parse_u32(-1, @prefix)\nelse\n  return self\nend"}},{"id":"broadcast_u32-instance-method","html_id":"broadcast_u32-instance-method","name":"broadcast_u32","doc":"Returns the broadcast address in Unsigned 32bits format\n\n```\nip = Subnet.parse(\"10.0.0.1/29\")\n\nip.broadcast_u32\n  #=> 167772167\n```","summary":"<p>Returns the broadcast address in Unsigned 32bits format</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L531","def":{"name":"broadcast_u32","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(network_u32 + size) - 1"}},{"id":"c?-instance-method","html_id":"c?-instance-method","name":"c?","doc":"Checks whether the ip address belongs to a\nRFC 791 CLASS C network, no matter\nwhat the subnet mask is.\n\nExample:\n\n```\nip = Subnet.parse(\"192.168.1.1/30\")\n\nip.c?\n  #=> true\n```","summary":"<p>Checks whether the ip address belongs to a RFC 791 CLASS C network, no matter what the subnet mask is.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L880","def":{"name":"c?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(CLASSFUL.key_for(24)) === bits"}},{"id":"data-instance-method","html_id":"data-instance-method","name":"data","doc":"Returns the address portion of an IPv4 object\nin a network byte order format.\n\n```crystal\nip = Subnet.parse(\"172.16.10.1/24\")\n\nip.data\n  #=> Bytes[172, 16, 10, 1]\n```\n\nIt is usually used to include an IP address\nin a data packet to be sent over a socket.","summary":"<p>Returns the address portion of an IPv4 object in a network byte order format.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L222","def":{"name":"data","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"raw = uninitialized ::StaticArray(UInt8, 4)\nIO::ByteFormat::BigEndian.encode(@u32.to_u32, raw.to_slice)\nraw\n"}},{"id":"each(&block)-instance-method","html_id":"each(&amp;block)-instance-method","name":"each","doc":"Iterates over all the IP addresses for the given\nnetwork (or IP address).\n\nThe object yielded is a new IPv4 object created\nfrom the iteration.\n\n```crystal\nip = Subnet.parse(\"10.0.0.1/29\")\n\nip.each do |i|\n  p i.address\nend\n  #=> \"10.0.0.0\"\n  #=> \"10.0.0.1\"\n  #=> \"10.0.0.2\"\n  #=> \"10.0.0.3\"\n  #=> \"10.0.0.4\"\n  #=> \"10.0.0.5\"\n  #=> \"10.0.0.6\"\n  #=> \"10.0.0.7\"\n```","summary":"<p>Iterates over all the IP addresses for the given network (or IP address).</p>","abstract":false,"args":[],"args_string":"(&block)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L435","def":{"name":"each","args":[],"double_splat":null,"splat_index":null,"yields":1,"block_arg":null,"return_type":"","visibility":"Public","body":"(network_u32..broadcast_u32).each do |i|\n  yield IPv4.parse_u32(i, @prefix)\nend"}},{"id":"each_host(&block)-instance-method","html_id":"each_host(&amp;block)-instance-method","name":"each_host","doc":"Iterates over all the hosts IP addresses for the given\nnetwork (or IP address).\n\n```crystal\nip = Subnet.parse(\"10.0.0.1/29\")\n\nip.each_host do |i|\n  p i.to_s\nend\n  #=> \"10.0.0.1\"\n  #=> \"10.0.0.2\"\n  #=> \"10.0.0.3\"\n  #=> \"10.0.0.4\"\n  #=> \"10.0.0.5\"\n  #=> \"10.0.0.6\"\n```","summary":"<p>Iterates over all the hosts IP addresses for the given network (or IP address).</p>","abstract":false,"args":[],"args_string":"(&block)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L408","def":{"name":"each_host","args":[],"double_splat":null,"splat_index":null,"yields":1,"block_arg":null,"return_type":"","visibility":"Public","body":"((network_u32 + 1)..(broadcast_u32 - 1)).each do |i|\n  yield IPv4.parse_u32(i, @prefix)\nend"}},{"id":"first-instance-method","html_id":"first-instance-method","name":"first","doc":"Returns a new IPv4 object with the\nfirst host IP address in the range.\n\nExample: given the 192.168.100.0/24 network, the first\nhost IP address is 192.168.100.1.\n\n```crystal\nip = Subnet.parse(\"192.168.100.0/24\")\n\nip.first.to_s\n  #=> \"192.168.100.1\"\n```\n\nThe object IP doesn't need to be a network: the method\nautomatically gets the network number from it\n\n```crystal\nip = Subnet.parse(\"192.168.100.50/24\")\n\nip.first.to_s\n  #=> \"192.168.100.1\"\n```","summary":"<p>Returns a new IPv4 object with the first host IP address in the range.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L349","def":{"name":"first","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"case\nwhen prefix <= 30\n  IPv4.parse_u32(network_u32 + 1, @prefix)\nwhen prefix == 31\n  IPv4.parse_u32(network_u32, @prefix)\nwhen prefix == 32\n  return self\nend"}},{"id":"hexstring-instance-method","html_id":"hexstring-instance-method","name":"hexstring","doc":"Returns the address portion in\nhex\n\n```crystal\nip = Subnet.parse(\"10.0.0.0\")\n\nip.hexstring\n  #=> \"0a000000\"\n```","summary":"<p>Returns the address portion in hex</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L206","def":{"name":"hexstring","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"data.to_slice.hexstring"}},{"id":"hosts-instance-method","html_id":"hosts-instance-method","name":"hosts","doc":"Returns an array with the IP addresses of\nall the hosts in the network.\n\n```\nip = Subnet.parse(\"10.0.0.1/29\")\n\nip.hosts.map {|i| i.address}\n  #=> [\"10.0.0.1\",\n  #=>  \"10.0.0.2\",\n  #=>  \"10.0.0.3\",\n  #=>  \"10.0.0.4\",\n  #=>  \"10.0.0.5\",\n  #=>  \"10.0.0.6\"]\n```","summary":"<p>Returns an array with the IP addresses of all the hosts in the network.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L507","def":{"name":"hosts","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"to_a[1..-2]"}},{"id":"includes?(oth)-instance-method","html_id":"includes?(oth)-instance-method","name":"includes?","doc":"Checks whether a subnet includes the given IP address.\n\nAccepts an Subnet.parse::IPv4 object.\n\n```\nip = Subnet.parse(\"192.168.10.100/24\")\n\naddr = Subnet.parse(\"192.168.10.102/24\")\n\nip.includes? addr\n  #=> true\n\nip.includes? Subnet.parse(\"172.16.0.48/16\")\n  #=> false\n```","summary":"<p>Checks whether a subnet includes the given IP address.</p>","abstract":false,"args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"args_string":"(oth)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L550","def":{"name":"includes?","args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix <= oth.prefix && (network_u32 == (oth.to_u32 & @prefix.to_u32))"}},{"id":"includes_all?(others)-instance-method","html_id":"includes_all?(others)-instance-method","name":"includes_all?","doc":"Checks whether a subnet includes all the\ngiven IPv4 objects.\n\n```\nip = Subnet.parse(\"192.168.10.100/24\")\n\naddr1 = Subnet.parse(\"192.168.10.102/24\")\naddr2 = Subnet.parse(\"192.168.10.103/24\")\n\nip.includes_all?(addr1,addr2)\n  #=> true\n```","summary":"<p>Checks whether a subnet includes all the given IPv4 objects.</p>","abstract":false,"args":[{"name":"others","doc":null,"default_value":"","external_name":"others","restriction":""}],"args_string":"(others)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L566","def":{"name":"includes_all?","args":[{"name":"others","doc":null,"default_value":"","external_name":"others","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"others.all? do |oth|\n  includes?(oth)\nend"}},{"id":"includes_all?(*others)-instance-method","html_id":"includes_all?(*others)-instance-method","name":"includes_all?","doc":"Checks whether a subnet includes all the\ngiven IPv4 objects.\n\n```\nip = Subnet.parse(\"192.168.10.100/24\")\n\naddr1 = Subnet.parse(\"192.168.10.102/24\")\naddr2 = Subnet.parse(\"192.168.10.103/24\")\n\nip.includes_all?(addr1,addr2)\n  #=> true\n```","summary":"<p>Checks whether a subnet includes all the given IPv4 objects.</p>","abstract":false,"args":[{"name":"others","doc":null,"default_value":"","external_name":"others","restriction":""}],"args_string":"(*others)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L571","def":{"name":"includes_all?","args":[{"name":"others","doc":null,"default_value":"","external_name":"others","restriction":""}],"double_splat":null,"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"includes_all?(others)"}},{"id":"last-instance-method","html_id":"last-instance-method","name":"last","doc":"Like its sibling method IPv4#first, this method\nreturns a new IPv4 object with the\nlast host IP address in the range.\n\nExample: given the 192.168.100.0/24 network, the last\nhost IP address is 192.168.100.254\n\n```crystal\nip = Subnet.parse(\"192.168.100.0/24\")\n\nip.last.to_s\n  #=> \"192.168.100.254\"\n```\n\nThe object IP doesn't need to be a network: the method\nautomatically gets the network number from it\n\n  ip = Subnet.parse(\"192.168.100.50/24\")\n\n  ip.last.to_s\n    #=> \"192.168.100.254\"","summary":"<p>Like its sibling method IPv4#first, this method returns a new IPv4 object with the last host IP address in the range.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L381","def":{"name":"last","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"case\nwhen prefix <= 30\n  IPv4.parse_u32(broadcast_u32 - 1, @prefix)\nwhen prefix == 31\n  IPv4.parse_u32(broadcast_u32, @prefix)\nwhen prefix == 32\n  return self\nend"}},{"id":"link_local?-instance-method","html_id":"link_local?-instance-method","name":"link_local?","doc":"Checks if an IPv4 address objects belongs\nto a link-local network RFC3927\n\nExample:\n\n```\nip = Subnet \"169.254.0.1\"\nip.link_local?\n  #=> true\n```","summary":"<p>Checks if an IPv4 address objects belongs to a link-local network RFC3927</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L629","def":{"name":"link_local?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"[IPv4.new(\"169.254.0.0/16\")].any? do |i|\n  i.includes?(self)\nend"}},{"id":"loopback?-instance-method","html_id":"loopback?-instance-method","name":"loopback?","doc":"Checks if an IPv4 address objects belongs\nto a loopback network RFC1122\n\nExample:\n\n```\nip = Subnet.parse \"127.0.0.1\"\nip.loopback?\n  #=> true\n```","summary":"<p>Checks if an IPv4 address objects belongs to a loopback network RFC1122</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L615","def":{"name":"loopback?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"[IPv4.new(\"127.0.0.0/8\")].any? do |i|\n  i.includes?(self)\nend"}},{"id":"multicast?-instance-method","html_id":"multicast?-instance-method","name":"multicast?","doc":"Checks if an IPv4 address objects belongs\nto a multicast network RFC3171\n\nExample:\n\n```\nip = Subnet.parse \"224.0.0.0/4\"\nip.multicast?\n  #=> true\n```","summary":"<p>Checks if an IPv4 address objects belongs to a multicast network RFC3171</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L601","def":{"name":"multicast?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"[IPv4.new(\"224.0.0.0/4\")].any? do |i|\n  i.includes?(self)\nend"}},{"id":"netmask-instance-method","html_id":"netmask-instance-method","name":"netmask","doc":"Returns the prefix as a string in IP format\n\n```crystal\nip = Subnet.parse(\"172.16.100.4/22\")\n\nip.netmask\n  #=> \"255.255.252.0\"\n```","summary":"<p>Returns the prefix as a string in IP format</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L164","def":{"name":"netmask","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix.to_ip"}},{"id":"netmask=(addr)-instance-method","html_id":"netmask=(addr)-instance-method","name":"netmask=","doc":"Like `IPv4#prefix=`, this method allow you to\nchange the prefix / netmask of an IP address\nobject.\n\n```crystal\nip = Subnet.parse(\"172.16.100.4\")\n\nputs ip\n  #=> 172.16.100.4/16\n\nip.netmask = \"255.255.252.0\"\n\nputs ip\n  #=> 172.16.100.4/22\n```","summary":"<p>Like <code><a href=\"../Subnet/IPv4.html#prefix%3D%28num%29-instance-method\">IPv4#prefix=</a></code>, this method allow you to change the prefix / netmask of an IP address object.</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L183","def":{"name":"netmask=","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix = Prefix32.parse_netmask(addr)"}},{"id":"network-instance-method","html_id":"network-instance-method","name":"network","doc":"Returns a new IPv4 object with the network number\nfor the given IP.\n\n```crystal\nip = Subnet.parse(\"172.16.10.64/24\")\n\nip.network.to_s\n  #=> \"172.16.10.0\"\n```","summary":"<p>Returns a new IPv4 object with the network number for the given IP.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L323","def":{"name":"network","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"IPv4.parse_u32(network_u32, @prefix)"}},{"id":"network?-instance-method","html_id":"network?-instance-method","name":"network?","doc":"Checks if the IP address is actually a network\n\n```crystal\nip = Subnet.parse(\"172.16.10.64/24\")\n\nip.network?\n  #=> false\n\nip = Subnet.parse(\"172.16.10.64/26\")\n\nip.network?\n  #=> true\n```","summary":"<p>Checks if the IP address is actually a network</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L310","def":{"name":"network?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(@prefix < 32) && ((@u32 | @prefix.to_u32) == @prefix.to_u32)"}},{"id":"network_u32-instance-method","html_id":"network_u32-instance-method","name":"network_u32","doc":"Returns the network number in Unsigned 32bits format\n\n```\nip = Subnet.parse(\"10.0.0.1/29\")\n\nip.network_u32\n  #=> 167772160\n```","summary":"<p>Returns the network number in Unsigned 32bits format</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L519","def":{"name":"network_u32","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@u32 & @prefix.to_u32"}},{"id":"octet(index)-instance-method","html_id":"octet(index)-instance-method","name":"octet","doc":"Returns the octet specified by index\n\n```crystal\nip = Subnet.parse(\"172.16.100.50/24\")\n\nip[0]\n  #=> 172\nip[1]\n  #=> 16\nip[2]\n  #=> 100\nip[3]\n  #=> 50\n```","summary":"<p>Returns the octet specified by index</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"args_string":"(index)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L247","def":{"name":"octet","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self[index]"}},{"id":"octets:Array(Int32)-instance-method","html_id":"octets:Array(Int32)-instance-method","name":"octets","doc":"Returns the address as an array of decimal values\n\n```crystal\nip = Subnet.parse(\"172.16.100.4\")\n\nip.octets\n  #=> [172, 16, 100, 4]\n```","summary":"<p>Returns the address as an array of decimal values</p>","abstract":false,"args":[],"args_string":" : Array(Int32)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L58","def":{"name":"octets","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Array(Int32)","visibility":"Public","body":"@octets"}},{"id":"prefix:Prefix32-instance-method","html_id":"prefix:Prefix32-instance-method","name":"prefix","doc":"Returns the prefix portion of the IPv4 object\nas a Subnet::Prefix32 object\n\n```crystal\nip = Subnet.parse(\"172.16.100.4/22\")\n\nip.prefix\n  #=> 22\n\nip.prefix.class\n  #=> Subnet::Prefix32\n```","summary":"<p>Returns the prefix portion of the IPv4 object as a Subnet::Prefix32 object</p>","abstract":false,"args":[],"args_string":" : Prefix32","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L48","def":{"name":"prefix","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Prefix32","visibility":"Public","body":"@prefix"}},{"id":"prefix=(num)-instance-method","html_id":"prefix=(num)-instance-method","name":"prefix=","doc":"Set a new prefix number for the object\n\nThis is useful if you want to change the prefix\nto an object created with IPv4.parse_u32 or\nif the object was created using the classful\nmask.\n\n```crystal\nip = Subnet.parse(\"172.16.100.4\")\n\nputs ip\n  #=> 172.16.100.4/16\n\nip.prefix = 22\n\nputs ip\n  #=> 172.16.100.4/22\n```","summary":"<p>Set a new prefix number for the object</p>","abstract":false,"args":[{"name":"num","doc":null,"default_value":"","external_name":"num","restriction":""}],"args_string":"(num)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L152","def":{"name":"prefix=","args":[{"name":"num","doc":null,"default_value":"","external_name":"num","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix = Prefix32.new(num)"}},{"id":"private?-instance-method","html_id":"private?-instance-method","name":"private?","doc":"Checks if an IPv4 address objects belongs\nto a private network RFC1918\n\nExample:\n\n```\nip = Subnet.parse \"10.1.1.1/24\"\nip.private?\n  #=> true\n```","summary":"<p>Checks if an IPv4 address objects belongs to a private network RFC1918</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L585","def":{"name":"private?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"[IPv4.new(\"10.0.0.0/8\"), IPv4.new(\"172.16.0.0/12\"), IPv4.new(\"192.168.0.0/16\")].any? do |i|\n  i.includes?(self)\nend"}},{"id":"reverse-instance-method","html_id":"reverse-instance-method","name":"reverse","doc":"Returns the IP address in in-addr.arpa format\nfor DNS lookups\n\n```\nip = Subnet.parse(\"172.16.100.50/24\")\n\nip.reverse\n  #=> \"50.100.16.172.in-addr.arpa\"\n```","summary":"<p>Returns the IP address in in-addr.arpa format for DNS lookups</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L642","def":{"name":"reverse","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(@octets.reverse.join(\".\")) + \".in-addr.arpa\""}},{"id":"size-instance-method","html_id":"size-instance-method","name":"size","doc":"Returns the number of IP addresses included\nin the network. It also counts the network\naddress and the broadcast address.\n\n```\nip = Subnet.parse(\"10.0.0.1/29\")\n\nip.size\n  #=> 8\n```","summary":"<p>Returns the number of IP addresses included in the network.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L489","def":{"name":"size","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"2 ** @prefix.host_prefix"}},{"id":"split(subnets=2)-instance-method","html_id":"split(subnets=2)-instance-method","name":"split","doc":"Splits a network into different subnets\n\nIf the IP Address is a network, it can be divided into\nmultiple networks. If `self` is not a network, this\nmethod will calculate the network from the IP and then\nsubnet it.\n\nIf `subnets` is an power of two number, the resulting\nnetworks will be divided evenly from the supernet.\n\n```\nnetwork = Subnet.parse(\"172.16.10.0/24\")\n\nnetwork / 4   # implies map{|i| i.to_string}\n  #=> [\"172.16.10.0/26\",\n  #=>  \"172.16.10.64/26\",\n  #=>  \"172.16.10.128/26\",\n  #=>  \"172.16.10.192/26\"]\n```\n\nIf `num` is any other number, the supernet will be\ndivided into some networks with a even number of hosts and\nother networks with the remaining addresses.\n\n```\nnetwork = Subnet.parse(\"172.16.10.0/24\")\n\nnetwork / 3   # implies map{|i| i.to_string}\n  #=> [\"172.16.10.0/26\",\n  #=>  \"172.16.10.64/26\",\n  #=>  \"172.16.10.128/25\"]\n```\n\nReturns an array of IPv4 objects","summary":"<p>Splits a network into different subnets</p>","abstract":false,"args":[{"name":"subnets","doc":null,"default_value":"2","external_name":"subnets","restriction":""}],"args_string":"(subnets = <span class=\"n\">2</span>)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L706","def":{"name":"split","args":[{"name":"subnets","doc":null,"default_value":"2","external_name":"subnets","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if (1..(2 ** @prefix.host_prefix)).includes?(subnets)\nelse\n  raise(ArgumentError.new(\"Value #{subnets} out of range\"))\nend\nnetworks = subnet(newprefix(subnets))\nwhile !(networks.size == subnets)\n  networks = sum_first_found(networks)\nend\nreturn networks\n"}},{"id":"subnet(subprefix)-instance-method","html_id":"subnet(subprefix)-instance-method","name":"subnet","doc":"This method implements the subnetting function\nsimilar to the one described in RFC3531.\n\nBy specifying a new prefix, the method calculates\nthe network number for the given IPv4 object\nand calculates the subnets associated to the new\nprefix.\n\nFor example, given the following network:\n\n```\nip = Subnet.parse \"172.16.10.0/24\"\n```\n\nwe can calculate the subnets with a /26 prefix\n\n```\nip.subnet(26).map{&:to_string)\n  #=> [\"172.16.10.0/26\", \"172.16.10.64/26\", \"172.16.10.128/26\", \"172.16.10.192/26\"]\n```\n\nThe resulting number of subnets will of course always be\na power of two.","summary":"<p>This method implements the subnetting function similar to the one described in RFC3531.</p>","abstract":false,"args":[{"name":"subprefix","doc":null,"default_value":"","external_name":"subprefix","restriction":""}],"args_string":"(subprefix)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L779","def":{"name":"subnet","args":[{"name":"subprefix","doc":null,"default_value":"","external_name":"subprefix","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"subprefix = subprefix.to_i\nif ((@prefix.to_i)..32).includes?(subprefix)\nelse\n  raise(ArgumentError.new(\"New prefix must be between #@prefix and 32\"))\nend\nArray(IPv4).new(2 ** (subprefix - @prefix.to_i)) do |i|\n  IPv4.parse_u32(network_u32 + (i * (2 ** (32 - subprefix))), subprefix)\nend\n"}},{"id":"supernet(new_prefix)-instance-method","html_id":"supernet(new_prefix)-instance-method","name":"supernet","doc":"Returns a new IPv4 object from the supernetting\nof the instance network.\n\nSupernetting is similar to subnetting, except\nthat you getting as a result a network with a\nsmaller prefix (bigger host space). For example,\ngiven the network\n\n```\nip = Subnet.parse(\"172.16.10.0/24\")\n```\n\nyou can supernet it with a new /23 prefix\n\n```\nip.supernet(23).to_string\n  #=> \"172.16.10.0/23\"\n```\n\nHowever if you supernet it with a /22 prefix, the\nnetwork address will change:\n\n```\nip.supernet(22).to_string\n  #=> \"172.16.8.0/22\"\n```\n\nIf `new_prefix` is less than 1, returns 0.0.0.0/0","summary":"<p>Returns a new IPv4 object from the supernetting of the instance network.</p>","abstract":false,"args":[{"name":"new_prefix","doc":null,"default_value":"","external_name":"new_prefix","restriction":""}],"args_string":"(new_prefix)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L750","def":{"name":"supernet","args":[{"name":"new_prefix","doc":null,"default_value":"","external_name":"new_prefix","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if new_prefix >= @prefix.to_i\n  raise(ArgumentError.new(\"New prefix must be smaller than existing prefix\"))\nend\nif new_prefix < 1\n  return IPv4.new(\"0.0.0.0/0\")\nend\nreturn (IPv4.new(@address + \"/#{new_prefix}\")).network\n"}},{"id":"to(e)-instance-method","html_id":"to(e)-instance-method","name":"to","doc":"Return a list of IP's between @address\nand the supplied IP\n\n```\nip = Subnet..parse(\"172.16.100.51/32\")\n\nip.to(\"172.16.100.100\")\n  #=> [\"172.16.100.51\",\n  #=>  \"172.16.100.52\",\n  #=>  ...\n  #=>  \"172.16.100.99\",\n  #=>  \"172.16.100.100\"]\n```","summary":"<p>Return a list of IP's between @address and the supplied IP</p>","abstract":false,"args":[{"name":"e","doc":null,"default_value":"","external_name":"e","restriction":""}],"args_string":"(e)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L664","def":{"name":"to","args":[{"name":"e","doc":null,"default_value":"","external_name":"e","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if e.is_a?(Subnet::IPv4)\nelse\n  e = IPv4.new(e)\nend\n(Range.new(@u32, e.to_u32)).map do |i|\n  Subnet.ntoa(i)\nend\n"}},{"id":"to_i-instance-method","html_id":"to_i-instance-method","name":"to_i","doc":"Like `IPv4#prefix=`, this method allow you to\nchange the prefix / netmask of an IP address\nobject.\n\n```crystal\nip = Subnet.parse(\"172.16.100.4\")\n\nputs ip\n  #=> 172.16.100.4/16\n\nip.netmask = \"255.255.252.0\"\n\nputs ip\n  #=> 172.16.100.4/22\n```","summary":"<p>Like <code><a href=\"../Subnet/IPv4.html#prefix%3D%28num%29-instance-method\">IPv4#prefix=</a></code>, this method allow you to change the prefix / netmask of an IP address object.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L188","def":{"name":"to_i","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"u32"}},{"id":"to_ipv6-instance-method","html_id":"to_ipv6-instance-method","name":"to_ipv6","doc":"Return the ip address in a format compatible\nwith the IPv6 Mapped IPv4 addresses\n\nExample:\n\n```\nip = Subnet.parse(\"172.16.10.1/24\")\n\nip.to_ipv6\n  #=> \"ac10:0a01\"\n```","summary":"<p>Return the ip address in a format compatible with the IPv6 Mapped IPv4 addresses</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L895","def":{"name":"to_ipv6","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"raise(\"Not implemented\")"}},{"id":"to_s:String-instance-method","html_id":"to_s:String-instance-method","name":"to_s","doc":"Returns a string with the address portion of\nthe IPv4 object\n\n```\nip = Subnet.parse(\"172.16.100.4/22\")\n\nip.to_s\n  #=> \"172.16.100.4\"\n```","summary":"<p>Returns a string with the address portion of the IPv4 object</p>","abstract":false,"args":[],"args_string":" : String","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L1129","def":{"name":"to_s","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@address"}},{"id":"to_string-instance-method","html_id":"to_string-instance-method","name":"to_string","doc":"Returns a string with the IP address in canonical\nform.\n\n```\nip = Subnet.parse(\"172.16.100.4/22\")\n\nip.to_string\n  #=> \"172.16.100.4/22\"\n```","summary":"<p>Returns a string with the IP address in canonical form.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L1142","def":{"name":"to_string","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"\"#{@address}/#{@prefix}\""}},{"id":"to_u32-instance-method","html_id":"to_u32-instance-method","name":"to_u32","doc":"Like `IPv4#prefix=`, this method allow you to\nchange the prefix / netmask of an IP address\nobject.\n\n```crystal\nip = Subnet.parse(\"172.16.100.4\")\n\nputs ip\n  #=> 172.16.100.4/16\n\nip.netmask = \"255.255.252.0\"\n\nputs ip\n  #=> 172.16.100.4/22\n```","summary":"<p>Like <code><a href=\"../Subnet/IPv4.html#prefix%3D%28num%29-instance-method\">IPv4#prefix=</a></code>, this method allow you to change the prefix / netmask of an IP address object.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L193","def":{"name":"to_u32","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"u32"}},{"id":"u32:Int64-instance-method","html_id":"u32:Int64-instance-method","name":"u32","doc":"Returns the address portion in unsigned\n32 bits integer format.\n\nThis method is identical to the C function\ninet_pton to create a 32 bits address family\nstructure.\n\n```crystal\nip = Subnet.parse(\"10.0.0.0/8\")\n\nip.to_i\n  #=> 167772160\n```","summary":"<p>Returns the address portion in unsigned 32 bits integer format.</p>","abstract":false,"args":[],"args_string":" : Int64","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv4.cr#L73","def":{"name":"u32","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Int64","visibility":"Public","body":"@u32"}}],"macros":[],"types":[]},{"html_id":"github.com/watzon/subnet/Subnet/IPv6","path":"Subnet/IPv6.html","kind":"class","full_name":"Subnet::IPv6","name":"IPv6","abstract":false,"superclass":{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/subnet/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"subnet/ipv6.cr","line_number":2,"url":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/ipv6.cr"}],"repository_name":"github.com/watzon/subnet","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"}],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[]},{"html_id":"github.com/watzon/subnet/Subnet/Prefix","path":"Subnet/Prefix.html","kind":"class","full_name":"Subnet::Prefix","name":"Prefix","abstract":true,"superclass":{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/subnet/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"subnet/prefix.cr","line_number":6,"url":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr"}],"repository_name":"github.com/watzon/subnet","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"}],"extended_modules":[],"subclasses":[{"html_id":"github.com/watzon/subnet/Subnet/Prefix128","kind":"class","full_name":"Subnet::Prefix128","name":"Prefix128"},{"html_id":"github.com/watzon/subnet/Subnet/Prefix32","kind":"class","full_name":"Subnet::Prefix32","name":"Prefix32"}],"including_types":[],"namespace":{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},"doc":"The base class for `Prefix32` and `Prefix128` defining some\ncommon methods that exist in both.","summary":"<p>The base class for <code><a href=\"../Subnet/Prefix32.html\">Prefix32</a></code> and <code><a href=\"../Subnet/Prefix128.html\">Prefix128</a></code> defining some common methods that exist in both.</p>","class_methods":[],"constructors":[{"id":"new(num)-class-method","html_id":"new(num)-class-method","name":"new","doc":"Create a new `Prefix`.","summary":"<p>Create a new <code><a href=\"../Subnet/Prefix.html\">Prefix</a></code>.</p>","abstract":false,"args":[{"name":"num","doc":null,"default_value":"","external_name":"num","restriction":""}],"args_string":"(num)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr#L12","def":{"name":"new","args":[{"name":"num","doc":null,"default_value":"","external_name":"num","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(num)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"+(other)-instance-method","html_id":"+(other)-instance-method","name":"+","doc":"Add this Prefix to another.","summary":"<p>Add this Prefix to another.</p>","abstract":false,"args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"args_string":"(other)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr#L32","def":{"name":"+","args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if other.is_a?(Number)\n  @prefix + other\nelse\n  @prefix + other.prefix\nend"}},{"id":"-(other)-instance-method","html_id":"-(other)-instance-method","name":"-","doc":"Subtract another Prefix from this one.","summary":"<p>Subtract another Prefix from this one.</p>","abstract":false,"args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"args_string":"(other)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr#L41","def":{"name":"-","args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if other.is_a?(Number)\n  @prefix - other\nelse\n  (@prefix - other.prefix).abs\nend"}},{"id":"(other)-instance-method","html_id":"(other)-instance-method","name":"<=>","doc":"Compare this Prefix to another.","summary":"<p>Compare this Prefix to another.</p>","abstract":false,"args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"args_string":"(other)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr#L27","def":{"name":"<=>","args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix <=> other.to_i"}},{"id":"prefix:Int32-instance-method","html_id":"prefix:Int32-instance-method","name":"prefix","doc":null,"summary":null,"abstract":false,"args":[],"args_string":" : Int32","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr#L11","def":{"name":"prefix","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Int32","visibility":"Public","body":"@prefix"}},{"id":"prefix=(prefix:Int32)-instance-method","html_id":"prefix=(prefix:Int32)-instance-method","name":"prefix=","doc":null,"summary":null,"abstract":false,"args":[{"name":"prefix","doc":null,"default_value":"","external_name":"prefix","restriction":"Int32"}],"args_string":"(prefix : Int32)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr#L15","def":{"name":"prefix=","args":[{"name":"prefix","doc":null,"default_value":"","external_name":"prefix","restriction":"Int32"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix = prefix"}},{"id":"to_i:Int32-instance-method","html_id":"to_i:Int32-instance-method","name":"to_i","doc":"Return this Prefix as an integer.","summary":"<p>Return this Prefix as an integer.</p>","abstract":false,"args":[],"args_string":" : Int32","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr#L22","def":{"name":"to_i","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix"}},{"id":"to_s(io)-instance-method","html_id":"to_s(io)-instance-method","name":"to_s","doc":"Convert the Prefix to a string.","summary":"<p>Convert the Prefix to a string.</p>","abstract":false,"args":[{"name":"io","doc":null,"default_value":"","external_name":"io","restriction":""}],"args_string":"(io)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr#L17","def":{"name":"to_s","args":[{"name":"io","doc":null,"default_value":"","external_name":"io","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"io << @prefix.to_s"}}],"macros":[],"types":[]},{"html_id":"github.com/watzon/subnet/Subnet/Prefix128","path":"Subnet/Prefix128.html","kind":"class","full_name":"Subnet::Prefix128","name":"Prefix128","abstract":false,"superclass":{"html_id":"github.com/watzon/subnet/Subnet/Prefix","kind":"class","full_name":"Subnet::Prefix","name":"Prefix"},"ancestors":[{"html_id":"github.com/watzon/subnet/Subnet/Prefix","kind":"class","full_name":"Subnet::Prefix","name":"Prefix"},{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/subnet/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"subnet/prefix.cr","line_number":188,"url":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr"}],"repository_name":"github.com/watzon/subnet","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},"doc":null,"summary":null,"class_methods":[],"constructors":[{"id":"new(num=128)-class-method","html_id":"new(num=128)-class-method","name":"new","doc":"Creates a new prefix object for 128 bit IPv6 addresses.","summary":"<p>Creates a new prefix object for 128 bit IPv6 addresses.</p>","abstract":false,"args":[{"name":"num","doc":null,"default_value":"128","external_name":"num","restriction":""}],"args_string":"(num = <span class=\"n\">128</span>)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr#L191","def":{"name":"new","args":[{"name":"num","doc":null,"default_value":"128","external_name":"num","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(num)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"bits-instance-method","html_id":"bits-instance-method","name":"bits","doc":"Transforms the prefix into a string of bits\nrepresenting the netmask","summary":"<p>Transforms the prefix into a string of bits representing the netmask</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr#L201","def":{"name":"bits","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(\"1\" * @prefix) + (\"0\" * (128 - @prefix))"}},{"id":"host_prefix-instance-method","html_id":"host_prefix-instance-method","name":"host_prefix","doc":null,"summary":null,"abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr#L213","def":{"name":"host_prefix","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"128 - @prefix"}},{"id":"to_u128-instance-method","html_id":"to_u128-instance-method","name":"to_u128","doc":"Unsigned 128 bit decimal number representing\nthe prefix.","summary":"<p>Unsigned 128 bit decimal number representing the prefix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr#L207","def":{"name":"to_u128","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"bits.to_big_i(2)"}}],"macros":[],"types":[]},{"html_id":"github.com/watzon/subnet/Subnet/Prefix32","path":"Subnet/Prefix32.html","kind":"class","full_name":"Subnet::Prefix32","name":"Prefix32","abstract":false,"superclass":{"html_id":"github.com/watzon/subnet/Subnet/Prefix","kind":"class","full_name":"Subnet::Prefix","name":"Prefix"},"ancestors":[{"html_id":"github.com/watzon/subnet/Subnet/Prefix","kind":"class","full_name":"Subnet::Prefix","name":"Prefix"},{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/subnet/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"subnet/prefix.cr","line_number":50,"url":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr"}],"repository_name":"github.com/watzon/subnet","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[{"id":"IN4MASK","name":"IN4MASK","value":"4294967295_i64","doc":null,"summary":null}],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},"doc":null,"summary":null,"class_methods":[{"id":"parse_netmask(netmask)-class-method","html_id":"parse_netmask(netmask)-class-method","name":"parse_netmask","doc":"Creates a new prefix by parsing a netmask in\ndotted decimal form\n\n```\nprefix = Subnet::Prefix32::parse_netmask \"255.255.255.0\"\n  #=> 24\n```","summary":"<p>Creates a new prefix by parsing a netmask in dotted decimal form</p>","abstract":false,"args":[{"name":"netmask","doc":null,"default_value":"","external_name":"netmask","restriction":""}],"args_string":"(netmask)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr#L178","def":{"name":"parse_netmask","args":[{"name":"netmask","doc":null,"default_value":"","external_name":"netmask","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"octets = netmask.is_a?(Indexable) ? netmask : netmask.split('.')\nif octets.size == 4\nelse\n  raise(\"netmask must contain 4 octets\")\nend\noctets = octets.map(&.to_u8)\nnum = (((Slice.new(octets.to_unsafe, 4)).hexstring.to_u32(16)).to_s(2)).count(\"1\")\nPrefix32.new(num)\n"}}],"constructors":[{"id":"new(num)-class-method","html_id":"new(num)-class-method","name":"new","doc":"Creates a new prefix object for 32 bits IPv4 addresses\n\n```\nprefix = Subnet::Prefix32.new 24\n  #=> 24\n```","summary":"<p>Creates a new prefix object for 32 bits IPv4 addresses</p>","abstract":false,"args":[{"name":"num","doc":null,"default_value":"","external_name":"num","restriction":""}],"args_string":"(num)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr#L60","def":{"name":"new","args":[{"name":"num","doc":null,"default_value":"","external_name":"num","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(num)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"[](index)-instance-method","html_id":"[](index)-instance-method","name":"[]","doc":"Shortcut for the octecs in the dotted decimal\nrepresentation\n\n```\nprefix = Subnet::Prefix32.new 24\n\nprefix[2]\n  #=> 255\n```","summary":"<p>Shortcut for the octecs in the dotted decimal representation</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"args_string":"(index)","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr#L139","def":{"name":"[]","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"octets[index]"}},{"id":"bits-instance-method","html_id":"bits-instance-method","name":"bits","doc":"Transforms the prefix into a string of bits\nrepresenting the netmask\n\n```\nprefix = Subnet::Prefix32.new 24\n\nprefix.bits\n  #=> \"11111111111111111111111100000000\"\n```","summary":"<p>Transforms the prefix into a string of bits representing the netmask</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr#L90","def":{"name":"bits","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"\"%.32b\" % to_u32"}},{"id":"host_prefix-instance-method","html_id":"host_prefix-instance-method","name":"host_prefix","doc":"Returns the length of the host portion\nof a netmask.\n\n```\nprefix = Prefix32.new 24\n\nprefix.host_prefix\n  #=> 8\n```","summary":"<p>Returns the length of the host portion of a netmask.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr#L77","def":{"name":"host_prefix","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"32 - @prefix"}},{"id":"hostmask-instance-method","html_id":"hostmask-instance-method","name":"hostmask","doc":"The hostmask is the contrary of the subnet mask,\nas it shows the bits that can change within the\nhosts\n\n```\nprefix = Subnet::Prefix32.new 24\n\nprefix.hostmask\n  #=> \"0.0.0.255\"\n```","summary":"<p>The hostmask is the contrary of the subnet mask, as it shows the bits that can change within the hosts</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr#L153","def":{"name":"hostmask","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"hostmask_octets.join('.')"}},{"id":"hostmask_octets-instance-method","html_id":"hostmask_octets-instance-method","name":"hostmask_octets","doc":"Returns an array of octets representing the hostmask\n\n```\nprefix = Subnet::Prefix32.new 24\n\nprefix.hostmask_octets\n  # => StaticArray[\"0\", \"0\", \"0\", \"255\"]\n```","summary":"<p>Returns an array of octets representing the hostmask</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr#L165","def":{"name":"hostmask_octets","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"octets = uninitialized ::StaticArray(UInt8, 4)\nIO::ByteFormat::BigEndian.encode(~to_u32.to_u32, octets.to_slice)\noctets\n"}},{"id":"octets-instance-method","html_id":"octets-instance-method","name":"octets","doc":"An array of octets of the IPv4 dotted decimal\nformat\n\n```\nprefix = Subnet::Prefix32.new 24\n\nprefix.octets\n  #=> [255, 255, 255, 0]\n```","summary":"<p>An array of octets of the IPv4 dotted decimal format</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr#L116","def":{"name":"octets","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(\"%08.64x\" % (bits.to_i64(2))).hexbytes"}},{"id":"to_ip-instance-method","html_id":"to_ip-instance-method","name":"to_ip","doc":"Gives the prefix in IPv4 dotted decimal format,\ni.e. the canonical netmask we're all used to\n\n```\nprefix = Subnet::Prefix32.new 24\n\nprefix.to_ip\n  #=> \"255.255.255.0\"\n```","summary":"<p>Gives the prefix in IPv4 dotted decimal format, i.e.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr#L103","def":{"name":"to_ip","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"octets.join('.')"}},{"id":"to_u32-instance-method","html_id":"to_u32-instance-method","name":"to_u32","doc":"Unsigned 32 bit number representing the prefix.\n\n  prefix = Subnet::Prefix32.new 24\n\n  prefix.to_u32\n    #=> 4294967040","summary":"<p>Unsigned 32 bit number representing the prefix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/68bd9974aa6be4af57b7384d73fec7533f966a8d/src/subnet/prefix.cr#L126","def":{"name":"to_u32","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(IN4MASK >> host_prefix) << host_prefix"}}],"macros":[],"types":[]}]}]}}
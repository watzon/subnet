crystal_doc_search_index_callback({"repository_name":"github.com/watzon/subnet","body":"# Subnet\n\nSubnet is a Crystal library designed to make the use of IPv4 and IPv6 (soon) addresses simple, powerful and enjoyable. It provides a complete set of methods to handle IP addresses for any need, from simple scripting to full network design.\n\nSubnet is written with a full OO interface, and its code is easy to read, maintain and extend. The documentation is full of examples, to let you start being productive immediately.\n\nThis document provides a brief introduction to the library and examples of typical usage. You can check out the full documentation [here](https://watzon.github.io/subnet/).\n\n## Installation\n\n1. Add the dependency to your `shard.yml`:\n\n   ```yaml\n   dependencies:\n     subnet:\n       github: watzon/subnet\n   ```\n\n2. Run `shards install`\n\n## Usage\n\n```crystal\nrequire \"subnet\"\n```\n\nTODO: Write usage instructions here\n\n## Development\n\nTODO: Write development instructions here\n\n## Contributing\n\n1. Fork it (<https://github.com/watzon/subnet/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n## Contributors\n\n- [Chris Watson](https://github.com/watzon) - creator and maintainer\n","program":{"html_id":"github.com/watzon/subnet/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"github.com/watzon/subnet","program":true,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"github.com/watzon/subnet/Subnet","path":"Subnet.html","kind":"module","full_name":"Subnet","name":"Subnet","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"subnet/version.cr","line_number":1,"url":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/version.cr"},{"filename":"subnet/prefix.cr","line_number":3,"url":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr"},{"filename":"subnet/ipv4.cr","line_number":3,"url":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr"},{"filename":"subnet/ipv6.cr","line_number":4,"url":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr"},{"filename":"subnet.cr","line_number":7,"url":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet.cr"}],"repository_name":"github.com/watzon/subnet","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[{"id":"VERSION","name":"VERSION","value":"\"0.1.0\"","doc":null,"summary":null}],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[{"html_id":"github.com/watzon/subnet/Subnet/IPv4","kind":"class","full_name":"Subnet::IPv4","name":"IPv4"},{"html_id":"github.com/watzon/subnet/Subnet/IPv6","kind":"class","full_name":"Subnet::IPv6","name":"IPv6"}],"namespace":null,"doc":"TODO: Write documentation for `Subnet`","summary":"<p><span class=\"flag orange\">TODO</span>  Write documentation for <code><a href=\"Subnet.html\">Subnet</a></code></p>","class_methods":[{"id":"deprecate(message=nil)-class-method","html_id":"deprecate(message=nil)-class-method","name":"deprecate","doc":"Deprecate method\n:nodoc:","summary":"<p>Deprecate method :nodoc:</p>","abstract":false,"args":[{"name":"message","doc":null,"default_value":"nil","external_name":"message","restriction":""}],"args_string":"(message = <span class=\"n\">nil</span>)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet.cr#L227","def":{"name":"deprecate","args":[{"name":"message","doc":null,"default_value":"nil","external_name":"message","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"message || (message = \"You are using deprecated behavior which will be removed from the next major or minor release.\")\nwarn(\"DEPRECATION WARNING: #{message}\")\n"}},{"id":"ntoa(uint)-class-method","html_id":"ntoa(uint)-class-method","name":"ntoa","doc":"Converts a unit32 to IPv4\n\n```\nSubnet::ntoa(167837953)\n  # => \"10.1.1.1\"\n```","summary":"<p>Converts a unit32 to IPv4</p>","abstract":false,"args":[{"name":"uint","doc":null,"default_value":"","external_name":"uint","restriction":""}],"args_string":"(uint)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet.cr#L54","def":{"name":"ntoa","args":[{"name":"uint","doc":null,"default_value":"","external_name":"uint","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if (uint.is_a?(Number) && uint <= 4294967295_i64) && uint >= 0\nelse\n  raise(ArgumentError.new(\"not a long integer: #{uint.inspect}\"))\nend\nret = [] of UInt8 | UInt16 | UInt32 | UInt64 | Int32 | Int64\n4.times do\n  ret.unshift(uint & 255)\n  uint = uint >> 8\nend\nret.join('.')\n"}},{"id":"valid?(addr)-class-method","html_id":"valid?(addr)-class-method","name":"valid?","doc":"Checks if the given string is either a valid IP, either a valid IPv4 subnet\n\nExample:\n\n```\nSubnet::valid? \"10.0.0.0/24\"\n  # => true\n\nSubnet::valid? \"2002::1\"\n  # => true\n\nSubnet::valid? \"10.0.0.256\"\n  # => false\n\nSubnet::valid? \"10.0.0.0/999\"\n  # => false\n```","summary":"<p>Checks if the given string is either a valid IP, either a valid IPv4 subnet</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet.cr#L109","def":{"name":"valid?","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"((valid_ip?(addr)) || (valid_ipv4_subnet?(addr))) || (valid_ipv6_subnet?(addr))"}},{"id":"valid_ip?(addr)-class-method","html_id":"valid_ip?(addr)-class-method","name":"valid_ip?","doc":"Checks if the given string is a valid IP address,\neither IPv4 or IPv6\n\nExample:\n\n```\nSubnet::valid_ip? \"2002::1\"\n  # => true\n\nSubnet::valid_ip? \"10.0.0.256\"\n  # => false\n```","summary":"<p>Checks if the given string is a valid IP address, either IPv4 or IPv6</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet.cr#L125","def":{"name":"valid_ip?","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(valid_ipv4?(addr)) || (valid_ipv6?(addr))"}},{"id":"valid_ipv4?(addr)-class-method","html_id":"valid_ipv4?(addr)-class-method","name":"valid_ipv4?","doc":"Checks if the given string is a valid IPv4 address\n\nExample:\n\n```\nSubnet::valid_ipv4? \"2002::1\"\n  # => false\n\nSubnet::valid_ipv4? \"172.16.10.1\"\n  # => true\n```","summary":"<p>Checks if the given string is a valid IPv4 address</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet.cr#L184","def":{"name":"valid_ipv4?","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if (/\\A(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\Z/) =~ addr\n  return $~.captures.all? do |i|\n    if i.nil?\n    else\n      i.to_i < 256\n    end\n  end\nend\nfalse\n"}},{"id":"valid_ipv4_netmask?(addr)-class-method","html_id":"valid_ipv4_netmask?(addr)-class-method","name":"valid_ipv4_netmask?","doc":"Checks if the argument is a valid IPv4 netmask\nexpressed in dotted decimal format.\n\n```\nSubnet.valid_ipv4_netmask? \"255.255.0.0\"\n  # => true\n```","summary":"<p>Checks if the argument is a valid IPv4 netmask expressed in dotted decimal format.</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet.cr#L198","def":{"name":"valid_ipv4_netmask?","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"begin\n  arr = (addr.split(\".\")).map do |i|\n    i.to_u8\n  end\n  bin = ((Slice.new(arr.to_unsafe, arr.size)).hexstring.to_u32(16)).to_s(2)\n  bits = bin.scan(/01/)\n  bits.empty? && (valid_ipv4?(addr))\nrescue\n  return false\nend"}},{"id":"valid_ipv4_subnet?(addr)-class-method","html_id":"valid_ipv4_subnet?(addr)-class-method","name":"valid_ipv4_subnet?","doc":"Checks if the given string is a valid IPv4 subnet\n\nExample:\n\n```\nSubnet::valid_ipv4_subnet? \"10.0.0.0/24\"\n  # => true\n\nSubnet::valid_ipv4_subnet? \"10.0.0.0/255.255.255.0\"\n  # => true\n\nSubnet::valid_ipv4_subnet? \"10.0.0.0/64\"\n  # => false\n```","summary":"<p>Checks if the given string is a valid IPv4 subnet</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet.cr#L143","def":{"name":"valid_ipv4_subnet?","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"ip, netmask = addr.split('/')\n(valid_ipv4?(ip)) && ((!(netmask =~ (/\\A([12]?\\d|3[0-2])\\z/)).nil?) || (valid_ipv4_netmask?(netmask)))\n"}},{"id":"valid_ipv6?(addr)-class-method","html_id":"valid_ipv6?(addr)-class-method","name":"valid_ipv6?","doc":"Checks if the given string is a valid IPv6 address\n\nExample:\n\n```\nSubnet::valid_ipv6? \"2002::1\"\n  # => true\n\nSubnet::valid_ipv6? \"2002::DEAD::BEEF\"\n  # => false\n```","summary":"<p>Checks if the given string is a valid IPv6 address</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet.cr#L218","def":{"name":"valid_ipv6?","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if (/^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/) =~ addr\n  return true\nend\nfalse\n"}},{"id":"valid_ipv6_subnet?(addr)-class-method","html_id":"valid_ipv6_subnet?(addr)-class-method","name":"valid_ipv6_subnet?","doc":"Checks if the given string is a valid IPv6 subnet\n\nExample:\n\n```\nSubnet::valid_ipv6_subnet? \"::/0\"\n  # => true\n\nSubnet::valid_ipv6_subnet? \"dead:beef:cafe:babe::/64\"\n  # => true\n\nSubnet::valid_ipv6_subnet? \"2001::1/129\"\n  # => false\n```","summary":"<p>Checks if the given string is a valid IPv6 subnet</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet.cr#L163","def":{"name":"valid_ipv6_subnet?","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"begin\n  ip, netmask = addr.split('/')\n  netmask = netmask.to_i(10)\n  ((valid_ipv6?(ip)) && netmask >= 0) && netmask <= 128\nrescue ArgumentError\n  false\nend"}}],"constructors":[{"id":"parse(str):Subnet-class-method","html_id":"parse(str):Subnet-class-method","name":"parse","doc":"Parse the argument string to create a new\nIPv4, IPv6 or Mapped IP object\n\n```\nip  = Subnet.parse 167837953 # 10.1.1.1\nip  = Subnet.parse \"172.16.10.1/24\"\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\nip_mapped = Subnet.parse \"::ffff:172.16.10.1/128\"\n```\n\nAll the object created will be instances of the\ncorrect class:\n\n```\nip.class\n  # => Subnet::IPv4\nip6.class\n  # => Subnet::IPv6\nip_mapped.class\n  # => Subnet::IPv6::Mapped\n```","summary":"<p>Parse the argument string to create a new IPv4, IPv6 or Mapped IP object</p>","abstract":false,"args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"args_string":"(str) : Subnet","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet.cr#L29","def":{"name":"parse","args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Subnet","visibility":"Public","body":"if str.is_a?(Number)\n  return Subnet::IPv4.new(ntoa(str))\nend\ncase str\nwhen /:.+\\./\n  Subnet::IPv6::Mapped.new(str)\nwhen /\\./\n  Subnet::IPv4.new(str)\nwhen /:/\n  Subnet::IPv6.new(str)\nelse\n  raise(ArgumentError.new(\"Unknown IP Address #{str}\"))\nend\n"}}],"instance_methods":[{"id":"ipv4?-instance-method","html_id":"ipv4?-instance-method","name":"ipv4?","doc":"True if the object is an IPv4 address\n\n```\nip = Subnet.parse(\"192.168.10.100/24\")\n\nip.ipv4?\n  # => true\n```","summary":"<p>True if the object is an IPv4 address</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet.cr#L75","def":{"name":"ipv4?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.is_a?(Subnet::IPv4)"}},{"id":"ipv6?-instance-method","html_id":"ipv6?-instance-method","name":"ipv6?","doc":"\nTrue if the object is an IPv6 address\n\n```\nip = Subnet.parse(\"192.168.10.100/24\")\n\nip.ipv6?\n  # => false\n```","summary":"<p>True if the object is an IPv6 address</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet.cr#L88","def":{"name":"ipv6?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.is_a?(Subnet::IPv6)"}}],"macros":[],"types":[{"html_id":"github.com/watzon/subnet/Subnet/IPv4","path":"Subnet/IPv4.html","kind":"class","full_name":"Subnet::IPv4","name":"IPv4","abstract":false,"superclass":{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/subnet/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/subnet/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"subnet/ipv4.cr","line_number":5,"url":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr"}],"repository_name":"github.com/watzon/subnet","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[{"id":"CLASSFUL","name":"CLASSFUL","value":"{/^0../ => 8, /^10./ => 16, /^110/ => 24}","doc":"This Hash contains the prefix values for Classful networks\n\nNote: classes C, D and E will all have a default\nprefix of /24 or 255.255.255.0","summary":"<p>This Hash contains the prefix values for Classful networks</p>"},{"id":"IPV4REGEX","name":"IPV4REGEX","value":"/((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)\\.){3}(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)/","doc":"Regular expression to match an IPv4 address","summary":"<p>Regular expression to match an IPv4 address</p>"}],"included_modules":[{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/subnet/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"}],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},"doc":"Class `Subnet::IPv4` is used to handle IPv4 type addresses.","summary":"<p>Class <code><a href=\"../Subnet/IPv4.html\">Subnet::IPv4</a></code> is used to handle IPv4 type addresses.</p>","class_methods":[{"id":"extract(str)-class-method","html_id":"extract(str)-class-method","name":"extract","doc":"Extract an IPv4 address from a string and\nreturns a new object\n\nExample:\n\n```\nstr = \"foobar172.16.10.1barbaz\"\nip = Subnet::IPv4.extract str\n\nip.to_s\n  #=> \"172.16.10.1\"\n```","summary":"<p>Extract an IPv4 address from a string and returns a new object</p>","abstract":false,"args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"args_string":"(str)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L951","def":{"name":"extract","args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"addr = (IPV4REGEX.match(str)).try do |__arg2|\n  __arg2[0].to_s\nend\nif addr\nelse\n  raise(\"Couldn't extract an address\")\nend\nIPv4.new(addr)\n"}},{"id":"parse_classful(ip)-class-method","html_id":"parse_classful(ip)-class-method","name":"parse_classful","doc":"Creates a new IPv4 address object by parsing the\naddress in a classful way.\n\nClassful addresses have a fixed netmask based on the\nclass they belong to:\n\n* Class A, from 0.0.0.0 to 127.255.255.255\n* Class B, from 128.0.0.0 to 191.255.255.255\n* Class C, D and E, from 192.0.0.0 to 255.255.255.254\n\nExample:\n\n```\nip = Subnet::IPv4.parse_classful \"10.0.0.1\"\n\nip.netmask\n  #=> \"255.0.0.0\"\nip.a?\n  #=> true\n```\n\nNote that classes C, D and E will all have a default\nprefix of /24 or 255.255.255.0\n","summary":"<p>Creates a new IPv4 address object by parsing the address in a classful way.</p>","abstract":false,"args":[{"name":"ip","doc":null,"default_value":"","external_name":"ip","restriction":""}],"args_string":"(ip)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L1081","def":{"name":"parse_classful","args":[{"name":"ip","doc":null,"default_value":"","external_name":"ip","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if Subnet.valid_ipv4?(ip)\nelse\n  raise(ArgumentError.new(\"Invalid IP #{ip.inspect}\"))\nend\naddress = ip.strip\nprefix = CLASSFUL.find do |h, k|\n  h === (\"%08b\" % (address.split('.')).first.to_i)\nend.try(&.last)\nnew(\"#{address}/#{prefix}\")\n"}},{"id":"parse_data(bytes,prefix=32)-class-method","html_id":"parse_data(bytes,prefix=32)-class-method","name":"parse_data","doc":"Creates a new IPv4 object from binary data,\nlike the one you get from a network stream.\n\nFor example, on a network stream the IP 172.16.0.1\nis represented with the binary `Bytes[172, 16, 10, 1]`.\n\n```\nip = Subnet::IPv4.parse_data Bytes[172, 16, 10, 1]\nip.prefix = 24\n\nip.to_string\n  #=> \"172.16.10.1/24\"\n```","summary":"<p>Creates a new IPv4 object from binary data, like the one you get from a network stream.</p>","abstract":false,"args":[{"name":"bytes","doc":null,"default_value":"","external_name":"bytes","restriction":""},{"name":"prefix","doc":null,"default_value":"32","external_name":"prefix","restriction":""}],"args_string":"(bytes, prefix = <span class=\"n\">32</span>)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L935","def":{"name":"parse_data","args":[{"name":"bytes","doc":null,"default_value":"","external_name":"bytes","restriction":""},{"name":"prefix","doc":null,"default_value":"32","external_name":"prefix","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"new((bytes.join('.')) + \"/#{prefix}\")"}},{"id":"parse_u32(u32,prefix=32)-class-method","html_id":"parse_u32(u32,prefix=32)-class-method","name":"parse_u32","doc":"Creates a new IPv4 object from an\nunsigned 32bits integer.\n\n```\nip = Subnet::IPv4.parse_u32(167772160)\n\nip.prefix = 8\nip.to_string\n  #=> \"10.0.0.0/8\"\n```\n\nThe `prefix` parameter is optional:\n\n```\nip = Subnet::IPv4.parse_u32(167772160, 8)\n\nip.to_string\n  #=> \"10.0.0.0/8\"\n```","summary":"<p>Creates a new IPv4 object from an unsigned 32bits integer.</p>","abstract":false,"args":[{"name":"u32","doc":null,"default_value":"","external_name":"u32","restriction":""},{"name":"prefix","doc":null,"default_value":"32","external_name":"prefix","restriction":""}],"args_string":"(u32, prefix = <span class=\"n\">32</span>)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L916","def":{"name":"parse_u32","args":[{"name":"u32","doc":null,"default_value":"","external_name":"u32","restriction":""},{"name":"prefix","doc":null,"default_value":"32","external_name":"prefix","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"octets = uninitialized ::StaticArray(UInt8, 4)\nIO::ByteFormat::BigEndian.encode(u32.to_u32, octets.to_slice)\nnew((octets.join('.')) + \"/#{prefix}\")\n"}},{"id":"summarize(args)-class-method","html_id":"summarize(args)-class-method","name":"summarize","doc":"Summarization (or aggregation) is the process when two or more\nnetworks are taken together to check if a supernet, including all\nand only these networks, exists. If it exists then this supernet\nis called the summarized (or aggregated) network.\n\nIt is very important to understand that summarization can only\noccur if there are no holes in the aggregated network, or, in other\nwords, if the given networks fill completely the address space\nof the supernet. So the two rules are:\n\n1) The aggregate network must contain +all+ the IP addresses of the\n   original networks;\n2) The aggregate network must contain +only+ the IP addresses of the\n   original networks;\n\nA few examples will help clarify the above. Let's consider for\ninstance the following two networks:\n\n```\nip1 = Subnet.parse(\"172.16.10.0/24\")\nip2 = Subnet.parse(\"172.16.11.0/24\")\n```\n\nThese two networks can be expressed using only one IP address\nnetwork if we change the prefix. Let Ruby do the work:\n\n```\nSubnet::IPv4.summarize(ip1,ip2).to_s\n  #=> \"172.16.10.0/23\"\n```\n\nWe note how the network \"172.16.10.0/23\" includes all the addresses\nspecified in the above networks, and (more important) includes\nONLY those addresses.\n\nIf we summarized `ip1` and `ip2` with the following network:\n\n```\n\"172.16.0.0/16\"\n```\n\nwe would have satisfied rule #1 above, but not rule #2. So \"172.16.0.0/16\"\nis not an aggregate network for `ip1` and `ip2`.\n\nIf it's not possible to compute a single aggregated network for all the\noriginal networks, the method returns an array with all the aggregate\nnetworks found. For example, the following four networks can be\naggregated in a single /22:\n\n```\nip1 = Subnet.parse(\"10.0.0.1/24\")\nip2 = Subnet.parse(\"10.0.1.1/24\")\nip3 = Subnet.parse(\"10.0.2.1/24\")\nip4 = Subnet.parse(\"10.0.3.1/24\")\n\nSubnet::IPv4.summarize(ip1,ip2,ip3,ip4).to_string\n  #=> [\"10.0.0.0/22\"]\n```\n\nBut the following networks can't be summarized in a single network:\n\n```\nip1 = Subnet.parse(\"10.0.1.1/24\")\nip2 = Subnet.parse(\"10.0.2.1/24\")\nip3 = Subnet.parse(\"10.0.3.1/24\")\nip4 = Subnet.parse(\"10.0.4.1/24\")\n\nSubnet::IPv4.summarize(ip1,ip2,ip3,ip4).map{|i| i.to_string}\n  #=> [\"10.0.1.0/24\",\"10.0.2.0/23\",\"10.0.4.0/24\"]\n```","summary":"<p>Summarization (or aggregation) is the process when two or more networks are taken together to check if a supernet, including all and only these networks, exists.</p>","abstract":false,"args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(args)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L1027","def":{"name":"summarize","args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if args.size < 1\n  raise(\"Can't summarize an empty network\")\nend\nif args.size == 1\n  return [args.first.not_nil!.network]\nend\ni = 0\nargs = args.to_a\nresult = args.dup.sort.map do |ip|\n  ip.network\nend\nwhile i < (result.size - 1)\n  sum = result[i] + result[i + 1]\n  if sum.size == 1\n    result[i..(i + 1)] = sum.first\n  end\n  i = i + 1\nend\nresult = result.flatten\nif result.size == args.size\n  return result\nelse\n  return self.summarize(result)\nend\n"}},{"id":"summarize(*args)-class-method","html_id":"summarize(*args)-class-method","name":"summarize","doc":"Summarization (or aggregation) is the process when two or more\nnetworks are taken together to check if a supernet, including all\nand only these networks, exists. If it exists then this supernet\nis called the summarized (or aggregated) network.\n\nIt is very important to understand that summarization can only\noccur if there are no holes in the aggregated network, or, in other\nwords, if the given networks fill completely the address space\nof the supernet. So the two rules are:\n\n1) The aggregate network must contain +all+ the IP addresses of the\n   original networks;\n2) The aggregate network must contain +only+ the IP addresses of the\n   original networks;\n\nA few examples will help clarify the above. Let's consider for\ninstance the following two networks:\n\n```\nip1 = Subnet.parse(\"172.16.10.0/24\")\nip2 = Subnet.parse(\"172.16.11.0/24\")\n```\n\nThese two networks can be expressed using only one IP address\nnetwork if we change the prefix. Let Ruby do the work:\n\n```\nSubnet::IPv4.summarize(ip1,ip2).to_s\n  #=> \"172.16.10.0/23\"\n```\n\nWe note how the network \"172.16.10.0/23\" includes all the addresses\nspecified in the above networks, and (more important) includes\nONLY those addresses.\n\nIf we summarized `ip1` and `ip2` with the following network:\n\n```\n\"172.16.0.0/16\"\n```\n\nwe would have satisfied rule #1 above, but not rule #2. So \"172.16.0.0/16\"\nis not an aggregate network for `ip1` and `ip2`.\n\nIf it's not possible to compute a single aggregated network for all the\noriginal networks, the method returns an array with all the aggregate\nnetworks found. For example, the following four networks can be\naggregated in a single /22:\n\n```\nip1 = Subnet.parse(\"10.0.0.1/24\")\nip2 = Subnet.parse(\"10.0.1.1/24\")\nip3 = Subnet.parse(\"10.0.2.1/24\")\nip4 = Subnet.parse(\"10.0.3.1/24\")\n\nSubnet::IPv4.summarize(ip1,ip2,ip3,ip4).to_string\n  #=> [\"10.0.0.0/22\"]\n```\n\nBut the following networks can't be summarized in a single network:\n\n```\nip1 = Subnet.parse(\"10.0.1.1/24\")\nip2 = Subnet.parse(\"10.0.2.1/24\")\nip3 = Subnet.parse(\"10.0.3.1/24\")\nip4 = Subnet.parse(\"10.0.4.1/24\")\n\nSubnet::IPv4.summarize(ip1,ip2,ip3,ip4).map{|i| i.to_string}\n  #=> [\"10.0.1.0/24\",\"10.0.2.0/23\",\"10.0.4.0/24\"]\n```","summary":"<p>Summarization (or aggregation) is the process when two or more networks are taken together to check if a supernet, including all and only these networks, exists.</p>","abstract":false,"args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(*args)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L1053","def":{"name":"summarize","args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":null,"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"summarize(args)"}}],"constructors":[{"id":"new(str:String)-class-method","html_id":"new(str:String)-class-method","name":"new","doc":"Creates a new IPv4 address object.\n\nAn IPv4 address can be expressed in any of the following forms:\n\n* \"10.1.1.1/24\": ip `address` and `prefix`. This is the common and\nsuggested way to create an object.\n\n* \"10.1.1.1/255.255.255.0\": ip `address` and `netmask`. Although\nconvenient sometimes, this format is less clear than the previous\none.\n\n* \"10.1.1.1\": if the address alone is specified, the prefix will be\nset as default 32, also known as the host prefix\n\nExamples:\n\n```crystal\n# These two are the same\nip = Subnet::IPv4.new(\"10.0.0.1/24\")\nip = Subnet.parse(\"10.0.0.1/24\")\n\n# These two are the same\nSubnet::IPv4.new \"10.0.0.1/8\"\nSubnet::IPv4.new \"10.0.0.1/255.0.0.0\"\n```","summary":"<p>Creates a new IPv4 address object.</p>","abstract":false,"args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":"String"}],"args_string":"(str : String)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L100","def":{"name":"new","args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":"String"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(str)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"+(oth)-instance-method","html_id":"+(oth)-instance-method","name":"+","doc":"Returns a new IPv4 object which is the result\nof the summarization, if possible, of the two\nobjects\n\nExample:\n\n```\nip1 = Subnet.parse(\"172.16.10.1/24\")\nip2 = Subnet.parse(\"172.16.11.2/24\")\n\np (ip1 + ip2).map {|i| i.to_string}\n  #=> [\"172.16.10.0/23\"]\n```\n\nIf the networks are not contiguous, returns\nthe two network numbers from the objects\n\n```\nip1 = Subnet.parse(\"10.0.0.1/24\")\nip2 = Subnet.parse(\"10.0.2.1/24\")\n\np (ip1 + ip2).map {|i| i.to_string}\n  #=> [\"10.0.0.0/24\",\"10.0.2.0/24\"]\n```","summary":"<p>Returns a new IPv4 object which is the result of the summarization, if possible, of the two objects</p>","abstract":false,"args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"args_string":"(oth)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L828","def":{"name":"+","args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"tup = [self, oth].sort.map do |i|\n  i.network\nend\naggregate(tup[0], tup[1])\n"}},{"id":"-(oth)-instance-method","html_id":"-(oth)-instance-method","name":"-","doc":"Returns the difference between two IP addresses\nin unsigned int 32 bits format\n\nExample:\n\n```\nip1 = Subnet.parse(\"172.16.10.0/24\")\nip2 = Subnet.parse(\"172.16.11.0/24\")\n\nputs ip1 - ip2\n  #=> 256\n```","summary":"<p>Returns the difference between two IP addresses in unsigned int 32 bits format</p>","abstract":false,"args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"args_string":"(oth)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L800","def":{"name":"-","args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"return (to_u32 - oth.to_u32).abs"}},{"id":"/(subnets)-instance-method","html_id":"/(subnets)-instance-method","name":"/","doc":"Splits a network into different subnets\n\nIf the IP Address is a network, it can be divided into\nmultiple networks. If `self` is not a network, this\nmethod will calculate the network from the IP and then\nsubnet it.\n\nIf `subnets` is an power of two number, the resulting\nnetworks will be divided evenly from the supernet.\n\n```\nnetwork = Subnet.parse(\"172.16.10.0/24\")\n\nnetwork / 4   # implies map{|i| i.to_string}\n  #=> [\"172.16.10.0/26\",\n  #=>  \"172.16.10.64/26\",\n  #=>  \"172.16.10.128/26\",\n  #=>  \"172.16.10.192/26\"]\n```\n\nIf `num` is any other number, the supernet will be\ndivided into some networks with a even number of hosts and\nother networks with the remaining addresses.\n\n```\nnetwork = Subnet.parse(\"172.16.10.0/24\")\n\nnetwork / 3   # implies map{|i| i.to_string}\n  #=> [\"172.16.10.0/26\",\n  #=>  \"172.16.10.64/26\",\n  #=>  \"172.16.10.128/25\"]\n```\n\nReturns an array of IPv4 objects","summary":"<p>Splits a network into different subnets</p>","abstract":false,"args":[{"name":"subnets","doc":null,"default_value":"","external_name":"subnets","restriction":""}],"args_string":"(subnets)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L715","def":{"name":"/","args":[{"name":"subnets","doc":null,"default_value":"","external_name":"subnets","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"split(subnets)"}},{"id":"(oth)-instance-method","html_id":"(oth)-instance-method","name":"<=>","doc":"Spaceship operator to compare IPv4 objects\n\nComparing IPv4 addresses is useful to ordinate\nthem into lists that match our intuitive\nperception of ordered IP addresses.\n\nThe first comparison criteria is the u32 value.\nFor example, 10.100.100.1 will be considered\nto be less than 172.16.0.1, because, in a ordered list,\nwe expect 10.100.100.1 to come before 172.16.0.1.\n\nThe second criteria, in case two IPv4 objects\nhave identical addresses, is the prefix. An higher\nprefix will be considered greater than a lower\nprefix. This is because we expect to see\n10.100.100.0/24 come before 10.100.100.0/25.\n\nExample:\n\n```crystal\nip1 = Subnet.parse \"10.100.100.1/8\"\nip2 = Subnet.parse \"172.16.0.1/16\"\nip3 = Subnet.parse \"10.100.100.1/16\"\n\nip1 < ip2\n  #=> true\nip1 > ip3\n  #=> false\n\n[ip1,ip2,ip3].sort.map{|i| i.to_s }\n  #=> [\"10.100.100.1/8\",\"10.100.100.1/16\",\"172.16.0.1/16\"]\n```","summary":"<p>Spaceship operator to compare IPv4 objects</p>","abstract":false,"args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"args_string":"(oth)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L471","def":{"name":"<=>","args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if to_i == oth.to_i\n  return prefix <=> oth.prefix\nend\nto_i <=> oth.to_i\n"}},{"id":"[](index)-instance-method","html_id":"[](index)-instance-method","name":"[]","doc":"Returns the octet specified by index\n\n```crystal\nip = Subnet.parse(\"172.16.100.50/24\")\n\nip[0]\n  #=> 172\nip[1]\n  #=> 16\nip[2]\n  #=> 100\nip[3]\n  #=> 50\n```","summary":"<p>Returns the octet specified by index</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"args_string":"(index)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L240","def":{"name":"[]","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@octets[index]"}},{"id":"[]=(index,value)-instance-method","html_id":"[]=(index,value)-instance-method","name":"[]=","doc":"Updated the octet specified at index\n\n```crystal\nip = Subnet.parse(\"172.16.100.50/24\")\nip[2] = 200\n\n#=>  #<Subnet::IPv4:0x00000000000000 @address=\"172.16.200.1\",\n#=>       @prefix=32, @octets=[172, 16, 200, 1], @u32=2886780929>\n```","summary":"<p>Updated the octet specified at index</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":""}],"args_string":"(index, value)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L258","def":{"name":"[]=","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@octets[index] = value.to_i\ninitialize(\"#{@octets.join('.')}/#{prefix}\")\n"}},{"id":"a?-instance-method","html_id":"a?-instance-method","name":"a?","doc":"Checks whether the ip address belongs to a\nRFC 791 CLASS A network, no matter\nwhat the subnet mask is.\n\nExample:\n\n```\nip = Subnet.parse(\"10.0.0.1/24\")\n\nip.a?\n  #=> true\n```","summary":"<p>Checks whether the ip address belongs to a RFC 791 CLASS A network, no matter what the subnet mask is.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L845","def":{"name":"a?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(CLASSFUL.key_for(8)) === bits"}},{"id":"address:String-instance-method","html_id":"address:String-instance-method","name":"address","doc":"Returns the address portion of the IPv4 object\nas a string.\n\n```crystal\nip = Subnet.parse(\"172.16.100.4/22\")\n\nip.address\n  #=> \"172.16.100.4\"\n```","summary":"<p>Returns the address portion of the IPv4 object as a string.</p>","abstract":false,"args":[],"args_string":" : String","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L34","def":{"name":"address","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"String","visibility":"Public","body":"@address"}},{"id":"allocate(skip=0)-instance-method","html_id":"allocate(skip=0)-instance-method","name":"allocate","doc":"Allocates a new ip from the current subnet. Optional skip parameter\ncan be used to skip addresses.\n\nWill return `nil` exception when all addresses have been allocated\n\nExample:\n\n```\nip = Subnet.parse(\"10.0.0.0/24\")\nip.allocate\n  #=> \"10.0.0.1/24\"\nip.allocate\n  #=> \"10.0.0.2/24\"\nip.allocate(2)\n  #=> \"10.0.0.5/24\"\n```\n\nUses an internal @allocator which tracks the state of allocated\naddresses.\n","summary":"<p>Allocates a new ip from the current subnet.</p>","abstract":false,"args":[{"name":"skip","doc":null,"default_value":"0","external_name":"skip","restriction":""}],"args_string":"(skip = <span class=\"n\">0</span>)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L1108","def":{"name":"allocate","args":[{"name":"skip","doc":null,"default_value":"0","external_name":"skip","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@allocator = @allocator + (1 + skip)\nnext_ip = network_u32 + @allocator\nif next_ip > (broadcast_u32 + 1)\n  return nil\nend\nIPv4.parse_u32(next_ip, @prefix)\n"}},{"id":"arpa-instance-method","html_id":"arpa-instance-method","name":"arpa","doc":"Returns the IP address in in-addr.arpa format\nfor DNS lookups\n\n```\nip = Subnet.parse(\"172.16.100.50/24\")\n\nip.reverse\n  #=> \"50.100.16.172.in-addr.arpa\"\n```","summary":"<p>Returns the IP address in in-addr.arpa format for DNS lookups</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L644","def":{"name":"arpa","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"reverse"}},{"id":"b?-instance-method","html_id":"b?-instance-method","name":"b?","doc":"Checks whether the ip address belongs to a\nRFC 791 CLASS B network, no matter\nwhat the subnet mask is.\n\nExample:\n\n```\nip = Subnet.parse(\"172.16.10.1/24\")\n\nip.b?\n  #=> true\n```","summary":"<p>Checks whether the ip address belongs to a RFC 791 CLASS B network, no matter what the subnet mask is.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L861","def":{"name":"b?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(CLASSFUL.key_for(16)) === bits"}},{"id":"bits-instance-method","html_id":"bits-instance-method","name":"bits","doc":"Returns the address portion of an IP in binary format,\nas a string containing a sequence of 0 and 1\n\n```crystal\nip = Subnet.parse(\"127.0.0.1\")\n\nip.bits\n  #=> \"01111111000000000000000000000001\"\n```","summary":"<p>Returns the address portion of an IP in binary format, as a string containing a sequence of 0 and 1</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L272","def":{"name":"bits","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"\"%032.32b\" % (hexstring.to_i64(16))"}},{"id":"broadcast-instance-method","html_id":"broadcast-instance-method","name":"broadcast","doc":"Returns the broadcast address for the given IP.\n\n```crystal\nip = Subnet.parse(\"172.16.10.64/24\")\n\nip.broadcast.to_s\n  #=> \"172.16.10.255\"\n```","summary":"<p>Returns the broadcast address for the given IP.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L284","def":{"name":"broadcast","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"case\nwhen prefix <= 30\n  IPv4.parse_u32(broadcast_u32, @prefix)\nwhen prefix == 31\n  IPv4.parse_u32(-1, @prefix)\nelse\n  return self\nend"}},{"id":"broadcast_u32-instance-method","html_id":"broadcast_u32-instance-method","name":"broadcast_u32","doc":"Returns the broadcast address in Unsigned 32bits format\n\n```\nip = Subnet.parse(\"10.0.0.1/29\")\n\nip.broadcast_u32\n  #=> 167772167\n```","summary":"<p>Returns the broadcast address in Unsigned 32bits format</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L528","def":{"name":"broadcast_u32","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(network_u32 + size) - 1"}},{"id":"c?-instance-method","html_id":"c?-instance-method","name":"c?","doc":"Checks whether the ip address belongs to a\nRFC 791 CLASS C network, no matter\nwhat the subnet mask is.\n\nExample:\n\n```\nip = Subnet.parse(\"192.168.1.1/30\")\n\nip.c?\n  #=> true\n```","summary":"<p>Checks whether the ip address belongs to a RFC 791 CLASS C network, no matter what the subnet mask is.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L877","def":{"name":"c?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(CLASSFUL.key_for(24)) === bits"}},{"id":"data-instance-method","html_id":"data-instance-method","name":"data","doc":"Returns the address portion of an IPv4 object\nin a network byte order format.\n\n```crystal\nip = Subnet.parse(\"172.16.10.1/24\")\n\nip.data\n  #=> \"\\254\\020\\n\" + \"\\001\"\n```\n\nIt is usually used to include an IP address\nin a data packet to be sent over a socket.","summary":"<p>Returns the address portion of an IPv4 object in a network byte order format.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L222","def":{"name":"data","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"String.new(hexstring.hexbytes)"}},{"id":"each(&block)-instance-method","html_id":"each(&amp;block)-instance-method","name":"each","doc":"Iterates over all the IP addresses for the given\nnetwork (or IP address).\n\nThe object yielded is a new IPv4 object created\nfrom the iteration.\n\n```crystal\nip = Subnet.parse(\"10.0.0.1/29\")\n\nip.each do |i|\n  p i.address\nend\n  #=> \"10.0.0.0\"\n  #=> \"10.0.0.1\"\n  #=> \"10.0.0.2\"\n  #=> \"10.0.0.3\"\n  #=> \"10.0.0.4\"\n  #=> \"10.0.0.5\"\n  #=> \"10.0.0.6\"\n  #=> \"10.0.0.7\"\n```","summary":"<p>Iterates over all the IP addresses for the given network (or IP address).</p>","abstract":false,"args":[],"args_string":"(&block)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L433","def":{"name":"each","args":[],"double_splat":null,"splat_index":null,"yields":1,"block_arg":null,"return_type":"","visibility":"Public","body":"(network_u32..broadcast_u32).each do |i|\n  yield self.class.parse_u32(i, @prefix)\nend"}},{"id":"each_host(&block)-instance-method","html_id":"each_host(&amp;block)-instance-method","name":"each_host","doc":"Iterates over all the hosts IP addresses for the given\nnetwork (or IP address).\n\n```crystal\nip = Subnet.parse(\"10.0.0.1/29\")\n\nip.each_host do |i|\n  p i.to_s\nend\n  #=> \"10.0.0.1\"\n  #=> \"10.0.0.2\"\n  #=> \"10.0.0.3\"\n  #=> \"10.0.0.4\"\n  #=> \"10.0.0.5\"\n  #=> \"10.0.0.6\"\n```","summary":"<p>Iterates over all the hosts IP addresses for the given network (or IP address).</p>","abstract":false,"args":[],"args_string":"(&block)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L406","def":{"name":"each_host","args":[],"double_splat":null,"splat_index":null,"yields":1,"block_arg":null,"return_type":"","visibility":"Public","body":"((network_u32 + 1)..(broadcast_u32 - 1)).each do |i|\n  yield self.class.parse_u32(i, @prefix)\nend"}},{"id":"first-instance-method","html_id":"first-instance-method","name":"first","doc":"Returns a new IPv4 object with the\nfirst host IP address in the range.\n\nExample: given the 192.168.100.0/24 network, the first\nhost IP address is 192.168.100.1.\n\n```crystal\nip = Subnet.parse(\"192.168.100.0/24\")\n\nip.first.to_s\n  #=> \"192.168.100.1\"\n```\n\nThe object IP doesn't need to be a network: the method\nautomatically gets the network number from it\n\n```crystal\nip = Subnet.parse(\"192.168.100.50/24\")\n\nip.first.to_s\n  #=> \"192.168.100.1\"\n```","summary":"<p>Returns a new IPv4 object with the first host IP address in the range.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L347","def":{"name":"first","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"case\nwhen prefix <= 30\n  IPv4.parse_u32(network_u32 + 1, @prefix)\nwhen prefix == 31\n  IPv4.parse_u32(network_u32, @prefix)\nwhen prefix == 32\n  return self\nend"}},{"id":"hexstring-instance-method","html_id":"hexstring-instance-method","name":"hexstring","doc":"Returns the address portion in\nhex\n\n```crystal\nip = Subnet.parse(\"10.0.0.0\")\n\nip.hexstring\n  #=> \"0a000000\"\n```","summary":"<p>Returns the address portion in hex</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L206","def":{"name":"hexstring","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"\"%08x\" % to_u32"}},{"id":"hosts-instance-method","html_id":"hosts-instance-method","name":"hosts","doc":"Returns an array with the IP addresses of\nall the hosts in the network.\n\n```\nip = Subnet.parse(\"10.0.0.1/29\")\n\nip.hosts.map {|i| i.address}\n  #=> [\"10.0.0.1\",\n  #=>  \"10.0.0.2\",\n  #=>  \"10.0.0.3\",\n  #=>  \"10.0.0.4\",\n  #=>  \"10.0.0.5\",\n  #=>  \"10.0.0.6\"]\n```","summary":"<p>Returns an array with the IP addresses of all the hosts in the network.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L504","def":{"name":"hosts","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"to_a[1..-2]"}},{"id":"includes?(oth:IPv4)-instance-method","html_id":"includes?(oth:IPv4)-instance-method","name":"includes?","doc":"Checks whether a subnet includes the given IP address.\n\nAccepts an Subnet.parse::IPv4 object.\n\n```\nip = Subnet.parse(\"192.168.10.100/24\")\n\naddr = Subnet.parse(\"192.168.10.102/24\")\n\nip.includes? addr\n  #=> true\n\nip.includes? Subnet.parse(\"172.16.0.48/16\")\n  #=> false\n```","summary":"<p>Checks whether a subnet includes the given IP address.</p>","abstract":false,"args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":"IPv4"}],"args_string":"(oth : IPv4)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L547","def":{"name":"includes?","args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":"IPv4"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix <= oth.prefix && (network_u32 == (oth.to_u32 & @prefix.to_u32))"}},{"id":"includes_all?(others)-instance-method","html_id":"includes_all?(others)-instance-method","name":"includes_all?","doc":"Checks whether a subnet includes all the\ngiven IPv4 objects.\n\n```\nip = Subnet.parse(\"192.168.10.100/24\")\n\naddr1 = Subnet.parse(\"192.168.10.102/24\")\naddr2 = Subnet.parse(\"192.168.10.103/24\")\n\nip.includes_all?(addr1,addr2)\n  #=> true\n```","summary":"<p>Checks whether a subnet includes all the given IPv4 objects.</p>","abstract":false,"args":[{"name":"others","doc":null,"default_value":"","external_name":"others","restriction":""}],"args_string":"(others)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L563","def":{"name":"includes_all?","args":[{"name":"others","doc":null,"default_value":"","external_name":"others","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"others.all? do |oth|\n  includes?(oth)\nend"}},{"id":"includes_all?(*others)-instance-method","html_id":"includes_all?(*others)-instance-method","name":"includes_all?","doc":"Checks whether a subnet includes all the\ngiven IPv4 objects.\n\n```\nip = Subnet.parse(\"192.168.10.100/24\")\n\naddr1 = Subnet.parse(\"192.168.10.102/24\")\naddr2 = Subnet.parse(\"192.168.10.103/24\")\n\nip.includes_all?(addr1,addr2)\n  #=> true\n```","summary":"<p>Checks whether a subnet includes all the given IPv4 objects.</p>","abstract":false,"args":[{"name":"others","doc":null,"default_value":"","external_name":"others","restriction":""}],"args_string":"(*others)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L568","def":{"name":"includes_all?","args":[{"name":"others","doc":null,"default_value":"","external_name":"others","restriction":""}],"double_splat":null,"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"includes_all?(others)"}},{"id":"last-instance-method","html_id":"last-instance-method","name":"last","doc":"Like its sibling method IPv4#first, this method\nreturns a new IPv4 object with the\nlast host IP address in the range.\n\nExample: given the 192.168.100.0/24 network, the last\nhost IP address is 192.168.100.254\n\n```crystal\nip = Subnet.parse(\"192.168.100.0/24\")\n\nip.last.to_s\n  #=> \"192.168.100.254\"\n```\n\nThe object IP doesn't need to be a network: the method\nautomatically gets the network number from it\n\n  ip = Subnet.parse(\"192.168.100.50/24\")\n\n  ip.last.to_s\n    #=> \"192.168.100.254\"","summary":"<p>Like its sibling method IPv4#first, this method returns a new IPv4 object with the last host IP address in the range.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L379","def":{"name":"last","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"case\nwhen prefix <= 30\n  self.class.parse_u32(broadcast_u32 - 1, @prefix)\nwhen prefix == 31\n  self.class.parse_u32(broadcast_u32, @prefix)\nwhen prefix == 32\n  return self\nend"}},{"id":"link_local?-instance-method","html_id":"link_local?-instance-method","name":"link_local?","doc":"Checks if an IPv4 address objects belongs\nto a link-local network RFC3927\n\nExample:\n\n```\nip = Subnet \"169.254.0.1\"\nip.link_local?\n  #=> true\n```","summary":"<p>Checks if an IPv4 address objects belongs to a link-local network RFC3927</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L626","def":{"name":"link_local?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"[self.class.new(\"169.254.0.0/16\")].any? do |i|\n  i.includes?(self)\nend"}},{"id":"loopback?-instance-method","html_id":"loopback?-instance-method","name":"loopback?","doc":"Checks if an IPv4 address objects belongs\nto a loopback network RFC1122\n\nExample:\n\n```\nip = Subnet.parse \"127.0.0.1\"\nip.loopback?\n  #=> true\n```","summary":"<p>Checks if an IPv4 address objects belongs to a loopback network RFC1122</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L612","def":{"name":"loopback?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"[self.class.new(\"127.0.0.0/8\")].any? do |i|\n  i.includes?(self)\nend"}},{"id":"multicast?-instance-method","html_id":"multicast?-instance-method","name":"multicast?","doc":"Checks if an IPv4 address objects belongs\nto a multicast network RFC3171\n\nExample:\n\n```\nip = Subnet.parse \"224.0.0.0/4\"\nip.multicast?\n  #=> true\n```","summary":"<p>Checks if an IPv4 address objects belongs to a multicast network RFC3171</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L598","def":{"name":"multicast?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"[self.class.new(\"224.0.0.0/4\")].any? do |i|\n  i.includes?(self)\nend"}},{"id":"netmask-instance-method","html_id":"netmask-instance-method","name":"netmask","doc":"Returns the prefix as a string in IP format\n\n```crystal\nip = Subnet.parse(\"172.16.100.4/22\")\n\nip.netmask\n  #=> \"255.255.252.0\"\n```","summary":"<p>Returns the prefix as a string in IP format</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L164","def":{"name":"netmask","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix.to_ip"}},{"id":"netmask=(addr)-instance-method","html_id":"netmask=(addr)-instance-method","name":"netmask=","doc":"Like `IPv4#prefix=`, this method allow you to\nchange the prefix / netmask of an IP address\nobject.\n\n```crystal\nip = Subnet.parse(\"172.16.100.4\")\n\nputs ip\n  #=> 172.16.100.4/16\n\nip.netmask = \"255.255.252.0\"\n\nputs ip\n  #=> 172.16.100.4/22\n```","summary":"<p>Like <code><a href=\"../Subnet/IPv4.html#prefix%3D%28num%29-instance-method\">IPv4#prefix=</a></code>, this method allow you to change the prefix / netmask of an IP address object.</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L183","def":{"name":"netmask=","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix = Prefix32.parse_netmask(addr)"}},{"id":"network-instance-method","html_id":"network-instance-method","name":"network","doc":"Returns a new IPv4 object with the network number\nfor the given IP.\n\n```crystal\nip = Subnet.parse(\"172.16.10.64/24\")\n\nip.network.to_s\n  #=> \"172.16.10.0\"\n```","summary":"<p>Returns a new IPv4 object with the network number for the given IP.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L321","def":{"name":"network","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"IPv4.parse_u32(network_u32, @prefix)"}},{"id":"network?-instance-method","html_id":"network?-instance-method","name":"network?","doc":"Checks if the IP address is actually a network\n\n```crystal\nip = Subnet.parse(\"172.16.10.64/24\")\n\nip.network?\n  #=> false\n\nip = Subnet.parse(\"172.16.10.64/26\")\n\nip.network?\n  #=> true\n```","summary":"<p>Checks if the IP address is actually a network</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L308","def":{"name":"network?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(@prefix < 32) && ((@u32 | @prefix.to_u32) == @prefix.to_u32)"}},{"id":"network_u32-instance-method","html_id":"network_u32-instance-method","name":"network_u32","doc":"Returns the network number in Unsigned 32bits format\n\n```\nip = Subnet.parse(\"10.0.0.1/29\")\n\nip.network_u32\n  #=> 167772160\n```","summary":"<p>Returns the network number in Unsigned 32bits format</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L516","def":{"name":"network_u32","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@u32 & @prefix.to_u32"}},{"id":"octet(index)-instance-method","html_id":"octet(index)-instance-method","name":"octet","doc":"Returns the octet specified by index\n\n```crystal\nip = Subnet.parse(\"172.16.100.50/24\")\n\nip[0]\n  #=> 172\nip[1]\n  #=> 16\nip[2]\n  #=> 100\nip[3]\n  #=> 50\n```","summary":"<p>Returns the octet specified by index</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"args_string":"(index)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L245","def":{"name":"octet","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self[index]"}},{"id":"octets:Array(Int32)-instance-method","html_id":"octets:Array(Int32)-instance-method","name":"octets","doc":"Returns the address as an array of decimal values\n\n```crystal\nip = Subnet.parse(\"172.16.100.4\")\n\nip.octets\n  #=> [172, 16, 100, 4]\n```","summary":"<p>Returns the address as an array of decimal values</p>","abstract":false,"args":[],"args_string":" : Array(Int32)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L58","def":{"name":"octets","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Array(Int32)","visibility":"Public","body":"@octets"}},{"id":"prefix:Prefix32-instance-method","html_id":"prefix:Prefix32-instance-method","name":"prefix","doc":"Returns the prefix portion of the IPv4 object\nas a Subnet::Prefix32 object\n\n```crystal\nip = Subnet.parse(\"172.16.100.4/22\")\n\nip.prefix\n  #=> 22\n\nip.prefix.class\n  #=> Subnet::Prefix32\n```","summary":"<p>Returns the prefix portion of the IPv4 object as a Subnet::Prefix32 object</p>","abstract":false,"args":[],"args_string":" : Prefix32","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L48","def":{"name":"prefix","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Prefix32","visibility":"Public","body":"@prefix"}},{"id":"prefix=(num)-instance-method","html_id":"prefix=(num)-instance-method","name":"prefix=","doc":"Set a new prefix number for the object\n\nThis is useful if you want to change the prefix\nto an object created with IPv4.parse_u32 or\nif the object was created using the classful\nmask.\n\n```crystal\nip = Subnet.parse(\"172.16.100.4\")\n\nputs ip\n  #=> 172.16.100.4/16\n\nip.prefix = 22\n\nputs ip\n  #=> 172.16.100.4/22\n```","summary":"<p>Set a new prefix number for the object</p>","abstract":false,"args":[{"name":"num","doc":null,"default_value":"","external_name":"num","restriction":""}],"args_string":"(num)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L152","def":{"name":"prefix=","args":[{"name":"num","doc":null,"default_value":"","external_name":"num","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix = Prefix32.new(num)"}},{"id":"private?-instance-method","html_id":"private?-instance-method","name":"private?","doc":"Checks if an IPv4 address objects belongs\nto a private network RFC1918\n\nExample:\n\n```\nip = Subnet.parse \"10.1.1.1/24\"\nip.private?\n  #=> true\n```","summary":"<p>Checks if an IPv4 address objects belongs to a private network RFC1918</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L582","def":{"name":"private?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"[self.class.new(\"10.0.0.0/8\"), self.class.new(\"172.16.0.0/12\"), self.class.new(\"192.168.0.0/16\")].any? do |i|\n  i.includes?(self)\nend"}},{"id":"reverse-instance-method","html_id":"reverse-instance-method","name":"reverse","doc":"Returns the IP address in in-addr.arpa format\nfor DNS lookups\n\n```\nip = Subnet.parse(\"172.16.100.50/24\")\n\nip.reverse\n  #=> \"50.100.16.172.in-addr.arpa\"\n```","summary":"<p>Returns the IP address in in-addr.arpa format for DNS lookups</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L639","def":{"name":"reverse","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(@octets.reverse.join(\".\")) + \".in-addr.arpa\""}},{"id":"size-instance-method","html_id":"size-instance-method","name":"size","doc":"Returns the number of IP addresses included\nin the network. It also counts the network\naddress and the broadcast address.\n\n```\nip = Subnet.parse(\"10.0.0.1/29\")\n\nip.size\n  #=> 8\n```","summary":"<p>Returns the number of IP addresses included in the network.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L486","def":{"name":"size","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"2 ** @prefix.host_prefix"}},{"id":"split(subnets=2)-instance-method","html_id":"split(subnets=2)-instance-method","name":"split","doc":"Splits a network into different subnets\n\nIf the IP Address is a network, it can be divided into\nmultiple networks. If `self` is not a network, this\nmethod will calculate the network from the IP and then\nsubnet it.\n\nIf `subnets` is an power of two number, the resulting\nnetworks will be divided evenly from the supernet.\n\n```\nnetwork = Subnet.parse(\"172.16.10.0/24\")\n\nnetwork / 4   # implies map{|i| i.to_string}\n  #=> [\"172.16.10.0/26\",\n  #=>  \"172.16.10.64/26\",\n  #=>  \"172.16.10.128/26\",\n  #=>  \"172.16.10.192/26\"]\n```\n\nIf `num` is any other number, the supernet will be\ndivided into some networks with a even number of hosts and\nother networks with the remaining addresses.\n\n```\nnetwork = Subnet.parse(\"172.16.10.0/24\")\n\nnetwork / 3   # implies map{|i| i.to_string}\n  #=> [\"172.16.10.0/26\",\n  #=>  \"172.16.10.64/26\",\n  #=>  \"172.16.10.128/25\"]\n```\n\nReturns an array of IPv4 objects","summary":"<p>Splits a network into different subnets</p>","abstract":false,"args":[{"name":"subnets","doc":null,"default_value":"2","external_name":"subnets","restriction":""}],"args_string":"(subnets = <span class=\"n\">2</span>)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L703","def":{"name":"split","args":[{"name":"subnets","doc":null,"default_value":"2","external_name":"subnets","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if (1..(2 ** @prefix.host_prefix)).includes?(subnets)\nelse\n  raise(ArgumentError.new(\"Value #{subnets} out of range\"))\nend\nnetworks = subnet(newprefix(subnets))\nwhile !(networks.size == subnets)\n  networks = sum_first_found(networks)\nend\nreturn networks\n"}},{"id":"subnet(subprefix)-instance-method","html_id":"subnet(subprefix)-instance-method","name":"subnet","doc":"This method implements the subnetting function\nsimilar to the one described in RFC3531.\n\nBy specifying a new prefix, the method calculates\nthe network number for the given IPv4 object\nand calculates the subnets associated to the new\nprefix.\n\nFor example, given the following network:\n\n```\nip = Subnet.parse \"172.16.10.0/24\"\n```\n\nwe can calculate the subnets with a /26 prefix\n\n```\nip.subnet(26).map{&:to_string)\n  #=> [\"172.16.10.0/26\", \"172.16.10.64/26\", \"172.16.10.128/26\", \"172.16.10.192/26\"]\n```\n\nThe resulting number of subnets will of course always be\na power of two.","summary":"<p>This method implements the subnetting function similar to the one described in RFC3531.</p>","abstract":false,"args":[{"name":"subprefix","doc":null,"default_value":"","external_name":"subprefix","restriction":""}],"args_string":"(subprefix)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L776","def":{"name":"subnet","args":[{"name":"subprefix","doc":null,"default_value":"","external_name":"subprefix","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"subprefix = subprefix.to_i\nif ((@prefix.to_i)..32).includes?(subprefix)\nelse\n  raise(ArgumentError.new(\"New prefix must be between #@prefix and 32\"))\nend\nArray(IPv4).new(2 ** (subprefix - @prefix.to_i)) do |i|\n  self.class.parse_u32(network_u32 + (i * (2 ** (32 - subprefix))), subprefix)\nend\n"}},{"id":"supernet(new_prefix)-instance-method","html_id":"supernet(new_prefix)-instance-method","name":"supernet","doc":"Returns a new IPv4 object from the supernetting\nof the instance network.\n\nSupernetting is similar to subnetting, except\nthat you getting as a result a network with a\nsmaller prefix (bigger host space). For example,\ngiven the network\n\n```\nip = Subnet.parse(\"172.16.10.0/24\")\n```\n\nyou can supernet it with a new /23 prefix\n\n```\nip.supernet(23).to_string\n  #=> \"172.16.10.0/23\"\n```\n\nHowever if you supernet it with a /22 prefix, the\nnetwork address will change:\n\n```\nip.supernet(22).to_string\n  #=> \"172.16.8.0/22\"\n```\n\nIf `new_prefix` is less than 1, returns 0.0.0.0/0","summary":"<p>Returns a new IPv4 object from the supernetting of the instance network.</p>","abstract":false,"args":[{"name":"new_prefix","doc":null,"default_value":"","external_name":"new_prefix","restriction":""}],"args_string":"(new_prefix)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L747","def":{"name":"supernet","args":[{"name":"new_prefix","doc":null,"default_value":"","external_name":"new_prefix","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if new_prefix >= @prefix.to_i\n  raise(ArgumentError.new(\"New prefix must be smaller than existing prefix\"))\nend\nif new_prefix < 1\n  return self.class.new(\"0.0.0.0/0\")\nend\nreturn (self.class.new(@address + \"/#{new_prefix}\")).network\n"}},{"id":"to(e)-instance-method","html_id":"to(e)-instance-method","name":"to","doc":"Return a list of IP's between @address\nand the supplied IP\n\n```\nip = Subnet..parse(\"172.16.100.51/32\")\n\nip.to(\"172.16.100.100\")\n  #=> [\"172.16.100.51\",\n  #=>  \"172.16.100.52\",\n  #=>  ...\n  #=>  \"172.16.100.99\",\n  #=>  \"172.16.100.100\"]\n```","summary":"<p>Return a list of IP's between @address and the supplied IP</p>","abstract":false,"args":[{"name":"e","doc":null,"default_value":"","external_name":"e","restriction":""}],"args_string":"(e)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L661","def":{"name":"to","args":[{"name":"e","doc":null,"default_value":"","external_name":"e","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if e.is_a?(Subnet::IPv4)\nelse\n  e = self.class.new(e)\nend\n(Range.new(@u32, e.to_u32)).map do |i|\n  Subnet.ntoa(i)\nend\n"}},{"id":"to_i-instance-method","html_id":"to_i-instance-method","name":"to_i","doc":"Like `IPv4#prefix=`, this method allow you to\nchange the prefix / netmask of an IP address\nobject.\n\n```crystal\nip = Subnet.parse(\"172.16.100.4\")\n\nputs ip\n  #=> 172.16.100.4/16\n\nip.netmask = \"255.255.252.0\"\n\nputs ip\n  #=> 172.16.100.4/22\n```","summary":"<p>Like <code><a href=\"../Subnet/IPv4.html#prefix%3D%28num%29-instance-method\">IPv4#prefix=</a></code>, this method allow you to change the prefix / netmask of an IP address object.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L188","def":{"name":"to_i","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"u32"}},{"id":"to_ipv6-instance-method","html_id":"to_ipv6-instance-method","name":"to_ipv6","doc":"Return the ip address in a format compatible\nwith the IPv6 Mapped IPv4 addresses\n\nExample:\n\n```\nip = Subnet.parse(\"172.16.10.1/24\")\n\nip.to_ipv6\n  #=> \"ac10:0a01\"\n```","summary":"<p>Return the ip address in a format compatible with the IPv6 Mapped IPv4 addresses</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L892","def":{"name":"to_ipv6","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(hexstring.scan(/..../)).map(&.[](0)).join(\":\")"}},{"id":"to_s:String-instance-method","html_id":"to_s:String-instance-method","name":"to_s","doc":"Returns a string with the address portion of\nthe IPv4 object\n\n```\nip = Subnet.parse(\"172.16.100.4/22\")\n\nip.to_s\n  #=> \"172.16.100.4\"\n```","summary":"<p>Returns a string with the address portion of the IPv4 object</p>","abstract":false,"args":[],"args_string":" : String","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L1128","def":{"name":"to_s","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@address"}},{"id":"to_string-instance-method","html_id":"to_string-instance-method","name":"to_string","doc":"Returns a string with the IP address in canonical\nform.\n\n```\nip = Subnet.parse(\"172.16.100.4/22\")\n\nip.to_string\n  #=> \"172.16.100.4/22\"\n```","summary":"<p>Returns a string with the IP address in canonical form.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L1141","def":{"name":"to_string","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"\"#{@address}/#{@prefix}\""}},{"id":"to_u32-instance-method","html_id":"to_u32-instance-method","name":"to_u32","doc":"Like `IPv4#prefix=`, this method allow you to\nchange the prefix / netmask of an IP address\nobject.\n\n```crystal\nip = Subnet.parse(\"172.16.100.4\")\n\nputs ip\n  #=> 172.16.100.4/16\n\nip.netmask = \"255.255.252.0\"\n\nputs ip\n  #=> 172.16.100.4/22\n```","summary":"<p>Like <code><a href=\"../Subnet/IPv4.html#prefix%3D%28num%29-instance-method\">IPv4#prefix=</a></code>, this method allow you to change the prefix / netmask of an IP address object.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L193","def":{"name":"to_u32","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"u32"}},{"id":"u32:Int64-instance-method","html_id":"u32:Int64-instance-method","name":"u32","doc":"Returns the address portion in unsigned\n32 bits integer format.\n\nThis method is identical to the C function\ninet_pton to create a 32 bits address family\nstructure.\n\n```crystal\nip = Subnet.parse(\"10.0.0.0/8\")\n\nip.to_i\n  #=> 167772160\n```","summary":"<p>Returns the address portion in unsigned 32 bits integer format.</p>","abstract":false,"args":[],"args_string":" : Int64","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv4.cr#L73","def":{"name":"u32","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Int64","visibility":"Public","body":"@u32"}}],"macros":[],"types":[]},{"html_id":"github.com/watzon/subnet/Subnet/IPv6","path":"Subnet/IPv6.html","kind":"class","full_name":"Subnet::IPv6","name":"IPv6","abstract":false,"superclass":{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/subnet/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/subnet/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"subnet/ipv6.cr","line_number":55,"url":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr"}],"repository_name":"github.com/watzon/subnet","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[{"id":"IN6FORMAT","name":"IN6FORMAT","value":"(\"%04x:\" * 8).chomp(':')","doc":"Format string to pretty print IPv6 addresses","summary":"<p>Format string to pretty print IPv6 addresses</p>"}],"included_modules":[{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/subnet/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"}],"extended_modules":[],"subclasses":[{"html_id":"github.com/watzon/subnet/Subnet/IPv6/Mapped","kind":"class","full_name":"Subnet::IPv6::Mapped","name":"Mapped"},{"html_id":"github.com/watzon/subnet/Subnet/IPv6/Unspecified","kind":"class","full_name":"Subnet::IPv6::Unspecified","name":"Unspecified"}],"including_types":[],"namespace":{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},"doc":"Class Subnet::IPv6 is used to handle IPv6 type addresses.\n\n## IPv6 addresses\n\nIPv6 addresses are 128 bits long, in contrast with IPv4 addresses\nwhich are only 32 bits long. An IPv6 address is generally written as\neight groups of four hexadecimal digits, each group representing 16\nbits or two octect. For example, the following is a valid IPv6\naddress:\n\n```\n2001:0db8:0000:0000:0008:0800:200c:417a\n```\n\nLetters in an IPv6 address are usually written downcase, as per\nRFC. You can create a new IPv6 object using uppercase letters, but\nthey will be converted.\n\n### Compression\n\nSince IPv6 addresses are very long to write, there are some\nsemplifications and compressions that you can use to shorten them.\n\n* Leading zeroes: all the leading zeroes within a group can be\n  omitted: \"0008\" would become \"8\"\n\n* A string of consecutive zeroes can be replaced by the string\n  \"::\". This can be only applied once.\n\nUsing compression, the IPv6 address written above can be shorten into\nthe following, equivalent, address\n\n```\n2001:db8::8:800:200c:417a\n```\n\nThis short version is often used in human representation.\n\n### Network Mask\n\nAs we used to do with IPv4 addresses, an IPv6 address can be written\nusing the prefix notation to specify the subnet mask:\n\n```\n2001:db8::8:800:200c:417a/64\n```\n\nThe /64 part means that the first 64 bits of the address are\nrepresenting the network portion, and the last 64 bits are the host\nportion.","summary":"<p>Class Subnet::IPv6 is used to handle IPv6 type addresses.</p>","class_methods":[{"id":"compress(str)-class-method","html_id":"compress(str)-class-method","name":"compress","doc":"Compress an IPv6 address in its compressed form\n\n```\nSubnet::IPv6.compress \"2001:0DB8:0000:CD30:0000:0000:0000:0000\"\n  #=> \"2001:db8:0:cd30::\"\n```","summary":"<p>Compress an IPv6 address in its compressed form</p>","abstract":false,"args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"args_string":"(str)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L544","def":{"name":"compress","args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(self.new(str)).compressed"}},{"id":"expand(str)-class-method","html_id":"expand(str)-class-method","name":"expand","doc":"Expands an IPv6 address in the canocical form\n\n```\nSubnet::IPv6.expand \"2001:0DB8:0:CD30::\"\n  #=> \"2001:0DB8:0000:CD30:0000:0000:0000:0000\"\n```","summary":"<p>Expands an IPv6 address in the canocical form</p>","abstract":false,"args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"args_string":"(str)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L534","def":{"name":"expand","args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(self.new(str)).address"}},{"id":"groups(str)-class-method","html_id":"groups(str)-class-method","name":"groups","doc":"Extract 16 bits groups from a string","summary":"<p>Extract 16 bits groups from a string</p>","abstract":false,"args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"args_string":"(str)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L574","def":{"name":"groups","args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"l, r = if str =~ (/^(.*)::(.*)$/)\n  [$~[1], $~[2]].map do |i|\n    i.split(\":\")\n  end\nelse\n  [str.split(\":\"), [] of String]\nend\n((l + (Array.new((8 - l.size) - r.size, \"0\"))) + r).map do |s|\n  s.empty? ? \"0\" : s\nend.map(&.to_i(16))\n"}},{"id":"parse_data(data)-class-method","html_id":"parse_data(data)-class-method","name":"parse_data","doc":"Creates a new IPv6 object from binary data,\nlike the one you get from a network stream.\n\nFor example, on a network stream the IP\n\n```\n\"2001:db8::8:800:200c:417a\"\n```\n\nis represented with the binary data\n\n```\n\" \\001\\r\\270\\000\\000\\000\\000\\000\\b\\b\\000 \\fAz\"\n```\n\nWith that data you can create a new IPv6 object:\n\n```\nip6 = Subnet::IPv6::parse_data \" \\001\\r\\270\\000\\000\\000\\000\\000\\b\\b\\000 \\fAz\"\nip6.prefix = 64\n\nip6.to_s\n  #=> \"2001:db8::8:800:200c:417a/64\"\n```","summary":"<p>Creates a new IPv6 object from binary data, like the one you get from a network stream.</p>","abstract":false,"args":[{"name":"data","doc":null,"default_value":"","external_name":"data","restriction":""}],"args_string":"(data)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L612","def":{"name":"parse_data","args":[{"name":"data","doc":null,"default_value":"","external_name":"data","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.parse_hex(data.to_slice.hexstring)"}},{"id":"parse_hex(hexstring,prefix=128)-class-method","html_id":"parse_hex(hexstring,prefix=128)-class-method","name":"parse_hex","doc":"Creates a new IPv6 object from a number expressed in\nhexdecimal format:\n\n```\nip6 = Subnet::IPv6::parse_hex(\"20010db80000000000080800200c417a\")\nip6.prefix = 64\n\nip6.to_string\n  #=> \"2001:db8::8:800:200c:417a/64\"\n```\n\nThe +prefix+ parameter is optional:\n\n```\nip6 = Subnet::IPv6::parse_hex(\"20010db80000000000080800200c417a\", 64)\n\nip6.to_string\n  #=> \"2001:db8::8:800:200c:417a/64\"\n```","summary":"<p>Creates a new IPv6 object from a number expressed in hexdecimal format:</p>","abstract":false,"args":[{"name":"hexstring","doc":null,"default_value":"","external_name":"hexstring","restriction":""},{"name":"prefix","doc":null,"default_value":"128","external_name":"prefix","restriction":""}],"args_string":"(hexstring, prefix = <span class=\"n\">128</span>)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L659","def":{"name":"parse_hex","args":[{"name":"hexstring","doc":null,"default_value":"","external_name":"hexstring","restriction":""},{"name":"prefix","doc":null,"default_value":"128","external_name":"prefix","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.parse_u128(hexstring.to_big_i(16), prefix)"}},{"id":"parse_u128(u128,prefix=128)-class-method","html_id":"parse_u128(u128,prefix=128)-class-method","name":"parse_u128","doc":"Creates a new IPv6 object from an\nunsigned 128 bits integer.\n\n```\nip6 = Subnet::IPv6::parse_u128(42540766411282592856906245548098208122)\nip6.prefix = 64\n\nip6.to_string\n  #=> \"2001:db8::8:800:200c:417a/64\"\n```\n\nThe +prefix+ parameter is optional:\n\n```\nip6 = Subnet::IPv6::parse_u128(42540766411282592856906245548098208122, 64)\n\nip6.to_string\n  #=> \"2001:db8::8:800:200c:417a/64\"\n```","summary":"<p>Creates a new IPv6 object from an unsigned 128 bits integer.</p>","abstract":false,"args":[{"name":"u128","doc":null,"default_value":"","external_name":"u128","restriction":""},{"name":"prefix","doc":null,"default_value":"128","external_name":"prefix","restriction":""}],"args_string":"(u128, prefix = <span class=\"n\">128</span>)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L635","def":{"name":"parse_u128","args":[{"name":"u128","doc":null,"default_value":"","external_name":"u128","restriction":""},{"name":"prefix","doc":null,"default_value":"128","external_name":"prefix","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"str = IN6FORMAT % (0..7).map do |i|\n  (u128 >> (112 - (16 * i))) & 65535\nend\nself.new(\"#{str}/#{prefix}\")\n"}}],"constructors":[{"id":"new(str:String)-class-method","html_id":"new(str:String)-class-method","name":"new","doc":"Creates a new IPv6 address object.\n\nAn IPv6 address can be expressed in any of the following forms:\n\n* \"2001:0db8:0000:0000:0008:0800:200C:417A\": IPv6 address with no compression\n* \"2001:db8:0:0:8:800:200C:417A\": IPv6 address with leading zeros compression\n* \"2001:db8::8:800:200C:417A\": IPv6 address with full compression\n\nIn all these 3 cases, a new IPv6 address object will be created, using the default\nsubnet mask /128\n\nYou can also specify the subnet mask as with IPv4 addresses:\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n```","summary":"<p>Creates a new IPv6 address object.</p>","abstract":false,"args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":"String"}],"args_string":"(str : String)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L112","def":{"name":"new","args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":"String"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(str)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"(oth)-instance-method","html_id":"(oth)-instance-method","name":"<=>","doc":"Spaceship operator to compare IPv6 objects\n\nComparing IPv6 addresses is useful to ordinate\nthem into lists that match our intuitive\nperception of ordered IP addresses.\n\nThe first comparison criteria is the u128 value.\nFor example, 2001:db8:1::1 will be considered\nto be less than 2001:db8:2::1, because, in a ordered list,\nwe expect 2001:db8:1::1 to come before 2001:db8:2::1.\n\nThe second criteria, in case two IPv6 objects\nhave identical addresses, is the prefix. An higher\nprefix will be considered greater than a lower\nprefix. This is because we expect to see\n2001:db8:1::1/64 come before 2001:db8:1::1/65\n\nExample:\n\n```\nip1 = Subnet.parse \"2001:db8:1::1/64\"\nip2 = Subnet.parse \"2001:db8:2::1/64\"\nip3 = Subnet.parse \"2001:db8:1::1/65\"\n\nip1 < ip2\n  #=> true\nip1 < ip3\n  #=> false\n\n[ip1,ip2,ip3].sort.map{|i| i.to_string}\n  #=> [\"2001:db8:1::1/64\",\"2001:db8:1::1/65\",\"2001:db8:2::1/64\"]\n```","summary":"<p>Spaceship operator to compare IPv6 objects</p>","abstract":false,"args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"args_string":"(oth)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L510","def":{"name":"<=>","args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if to_i == oth.to_i\n  return prefix <=> oth.prefix\nend\nto_i <=> oth.to_i\n"}},{"id":"[](index)-instance-method","html_id":"[](index)-instance-method","name":"[]","doc":"Returns the 16-bits value specified by index\n\n```\nip = Subnet::IPv6.new(\"2001:db8::8:800:200c:417a/64\")\n\nip[0]\n  #=> 8193\nip[1]\n  #=> 3512\nip[2]\n  #=> 0\nip[3]\n  #=> 0\n```","summary":"<p>Returns the 16-bits value specified by index</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"args_string":"(index)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L247","def":{"name":"[]","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@groups[index]"}},{"id":"[]=(index,value)-instance-method","html_id":"[]=(index,value)-instance-method","name":"[]=","doc":"Updated the octet specified at index\n","summary":"<p>Updated the octet specified at index </p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":""}],"args_string":"(index, value)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L258","def":{"name":"[]=","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@groups[index] = value\ninitialize(\"#{IN6FORMAT % @groups}/#{prefix}\")\n"}},{"id":"address:String-instance-method","html_id":"address:String-instance-method","name":"address","doc":"Returns the IPv6 address in uncompressed form:\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.address\n  #=> \"2001:0db8:0000:0000:0008:0800:200c:417a\"\n```","summary":"<p>Returns the IPv6 address in uncompressed form:</p>","abstract":false,"args":[],"args_string":" : String","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L81","def":{"name":"address","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"String","visibility":"Public","body":"@address"}},{"id":"allocate(skip=0)-instance-method","html_id":"allocate(skip=0)-instance-method","name":"allocate","doc":"Allocates a new ip from the current subnet. Optional skip parameter\ncan be used to skip addresses.\n\nWill raise StopIteration exception when all addresses have been allocated\n\nExample:\n\n```\nip = Subnet::IPv6.new(\"10.0.0.0/24\")\nip.allocate\n  #=> \"10.0.0.1/24\"\nip.allocate\n  #=> \"10.0.0.2/24\"\nip.allocate(2)\n  #=> \"10.0.0.5/24\"\n```\n\nUses an internal @allocator which tracks the state of allocated\naddresses.\n","summary":"<p>Allocates a new ip from the current subnet.</p>","abstract":false,"args":[{"name":"skip","doc":null,"default_value":"0","external_name":"skip","restriction":""}],"args_string":"(skip = <span class=\"n\">0</span>)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L683","def":{"name":"allocate","args":[{"name":"skip","doc":null,"default_value":"0","external_name":"skip","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@allocator = @allocator + (1 + skip)\nnext_ip = network_u128 + @allocator\nif next_ip > broadcast_u128\n  return nil\nend\nself.class.parse_u128(next_ip, @prefix)\n"}},{"id":"arpa-instance-method","html_id":"arpa-instance-method","name":"arpa","doc":"Returns the IPv6 address in a DNS reverse lookup\nstring, as per RFC3172 and RFC2874.\n\n```\nip6 = Subnet.parse \"3ffe:505:2::f\"\n\nip6.reverse\n  #=> \"f.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.0.0.0.5.0.5.0.e.f.f.3.ip6.arpa\"\n```","summary":"<p>Returns the IPv6 address in a DNS reverse lookup string, as per RFC3172 and RFC2874.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L322","def":{"name":"arpa","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"reverse"}},{"id":"bits-instance-method","html_id":"bits-instance-method","name":"bits","doc":"Returns the address portion of an IP in binary format,\nas a string containing a sequence of 0 and 1\n\n```\nip6 = Subnet::IPv6.new(\"2001:db8::8:800:200c:417a\")\n\nip6.bits\n  #=> \"0010000000000001000011011011100000 [...] \"\n```","summary":"<p>Returns the address portion of an IP in binary format, as a string containing a sequence of 0 and 1</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L524","def":{"name":"bits","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"\"%0128b\" % to_i"}},{"id":"broadcast_u128-instance-method","html_id":"broadcast_u128-instance-method","name":"broadcast_u128","doc":"Returns the broadcast address in Unsigned 128bits format\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.broadcast_u128\n  #=> 42540766411282592875350729025363378175\n```\n\nPlease note that there is no Broadcast concept in IPv6\naddresses as in IPv4 addresses, and this method is just\nan helper to other functions.\n","summary":"<p>Returns the broadcast address in Unsigned 128bits format</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L351","def":{"name":"broadcast_u128","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(network_u128 + size) - 1"}},{"id":"compressed:String-instance-method","html_id":"compressed:String-instance-method","name":"compressed","doc":"Compressed form of the IPv6 address\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.compressed\n  #=> \"2001:db8::8:800:200c:417a\"\n```","summary":"<p>Compressed form of the IPv6 address</p>","abstract":false,"args":[],"args_string":" : String","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L395","def":{"name":"compressed","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@compressed"}},{"id":"data-instance-method","html_id":"data-instance-method","name":"data","doc":"Returns the address portion of an IPv6 object\nin a network byte order format.\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.data\n  #=> \" \\001\\r\\270\\000\\000\\000\\000\\000\\b\\b\\000 \\fAz\"\n```\n\nIt is usually used to include an IP address\nin a data packet to be sent over a socket","summary":"<p>Returns the address portion of an IPv6 object in a network byte order format.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L288","def":{"name":"data","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"String.new(hexstring.hexbytes)"}},{"id":"each(&block)-instance-method","html_id":"each(&amp;block)-instance-method","name":"each","doc":"Iterates over all the IP addresses for the given\nnetwork (or IP address).\n\nThe object yielded is a new IPv6 object created\nfrom the iteration.\n\n```\nip6 = Subnet::IPv6.new(\"2001:db8::4/125\")\n\nip6.each do |i|\n  p i.compressed\nend\n  #=> \"2001:db8::\"\n  #=> \"2001:db8::1\"\n  #=> \"2001:db8::2\"\n  #=> \"2001:db8::3\"\n  #=> \"2001:db8::4\"\n  #=> \"2001:db8::5\"\n  #=> \"2001:db8::6\"\n  #=> \"2001:db8::7\"\n```\n\nWARNING: if the host portion is very large, this method\ncan be very slow and possibly hang your system!","summary":"<p>Iterates over all the IP addresses for the given network (or IP address).</p>","abstract":false,"args":[],"args_string":"(&block)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L472","def":{"name":"each","args":[],"double_splat":null,"splat_index":null,"yields":1,"block_arg":null,"return_type":"","visibility":"Public","body":"(network_u128..broadcast_u128).each do |i|\n  yield self.class.parse_u128(i, @prefix)\nend"}},{"id":"group(index)-instance-method","html_id":"group(index)-instance-method","name":"group","doc":"Returns the 16-bits value specified by index\n\n```\nip = Subnet::IPv6.new(\"2001:db8::8:800:200c:417a/64\")\n\nip[0]\n  #=> 8193\nip[1]\n  #=> 3512\nip[2]\n  #=> 0\nip[3]\n  #=> 0\n```","summary":"<p>Returns the 16-bits value specified by index</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"args_string":"(index)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L252","def":{"name":"group","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self[index]"}},{"id":"groups:Array(Int32)-instance-method","html_id":"groups:Array(Int32)-instance-method","name":"groups","doc":"Returns an array with the 16 bits groups in decimal\nformat:\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.groups\n  #=> [8193, 3512, 0, 0, 8, 2048, 8204, 16762]\n```","summary":"<p>Returns an array with the 16 bits groups in decimal format:</p>","abstract":false,"args":[],"args_string":" : Array(Int32)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L71","def":{"name":"groups","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Array(Int32)","visibility":"Public","body":"@groups"}},{"id":"hex_groups-instance-method","html_id":"hex_groups-instance-method","name":"hex_groups","doc":"Returns an array of the 16 bits groups in hexdecimal\nformat:\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.hex_groups\n  #=> [\"2001\", \"0db8\", \"0000\", \"0000\", \"0008\", \"0800\", \"200c\", \"417a\"]\n```\n\nNot to be confused with the similar `IPv6#hexstring` method.\n","summary":"<p>Returns an array of the 16 bits groups in hexdecimal format:</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L304","def":{"name":"hex_groups","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@address.split(\":\")"}},{"id":"hexstring-instance-method","html_id":"hexstring-instance-method","name":"hexstring","doc":"Returns a Base16 number representing the IPv6\naddress\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.hexstring\n  #=> \"20010db80000000000080800200c417a\"\n```","summary":"<p>Returns a Base16 number representing the IPv6 address</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L272","def":{"name":"hexstring","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"hex_groups.join(\"\")"}},{"id":"includes?(oth)-instance-method","html_id":"includes?(oth)-instance-method","name":"includes?","doc":"Checks whether a subnet includes the given IP address.\n\nExample:\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\naddr = Subnet.parse \"2001:db8::8:800:200c:1/128\"\n\nip6.includes? addr\n  #=> true\n\nip6.includes? Subnet::IPv6.new(\"2001:db8:1::8:800:200c:417a/76\")\n  #=> false\n```","summary":"<p>Checks whether a subnet includes the given IP address.</p>","abstract":false,"args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"args_string":"(oth)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L383","def":{"name":"includes?","args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix <= oth.prefix && (network_u128 == (self.class.new(oth.address + \"/#{@prefix}\")).network_u128)"}},{"id":"link_local?-instance-method","html_id":"link_local?-instance-method","name":"link_local?","doc":"Checks if an IPv6 address objects belongs\nto a link-local network RFC4291\n\nExample:\n\n```\nip = Subnet.parse \"fe80::1\"\nip.link_local?\n  #=> true\n```","summary":"<p>Checks if an IPv6 address objects belongs to a link-local network RFC4291</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L423","def":{"name":"link_local?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(self.class.new(\"fe80::/10\")).includes?(self)"}},{"id":"literal-instance-method","html_id":"literal-instance-method","name":"literal","doc":"Literal version of the IPv6 address\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.literal\n  #=> \"2001-0db8-0000-0000-0008-0800-200c-417a.ipv6-literal.net\"\n ```","summary":"<p>Literal version of the IPv6 address</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L556","def":{"name":"literal","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(@address.gsub(\":\", \"-\")) + \".ipv6-literal.net\""}},{"id":"loopback?-instance-method","html_id":"loopback?-instance-method","name":"loopback?","doc":"Returns true if the address is a loopback address\n\nSee Subnet::IPv6::Loopback for more information","summary":"<p>Returns true if the address is a loopback address</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L409","def":{"name":"loopback?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(@prefix == 128) && (@compressed == \"::1\")"}},{"id":"mapped?-instance-method","html_id":"mapped?-instance-method","name":"mapped?","doc":"Returns true if the address is a mapped address\n\nSee Subnet::IPv6::Mapped for more information","summary":"<p>Returns true if the address is a mapped address</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L444","def":{"name":"mapped?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(to_u128 >> 32) == 65535"}},{"id":"network-instance-method","html_id":"network-instance-method","name":"network","doc":"Returns a new IPv6 object with the network number\nfor the given IP.\n\n```\nip = Subnet.parse \"2001:db8:1:1:1:1:1:1/32\"\n\nip.network.to_string\n  #=> \"2001:db8::/32\"\n```","summary":"<p>Returns a new IPv6 object with the network number for the given IP.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L569","def":{"name":"network","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.class.parse_u128(network_u128, @prefix)"}},{"id":"network?-instance-method","html_id":"network?-instance-method","name":"network?","doc":"True if the IPv6 address is a network\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.network?\n  #=> false\n\nip6 = Subnet.parse \"2001:db8:8:800::/64\"\n\nip6.network?\n  #=> true\n```","summary":"<p>True if the IPv6 address is a network</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L229","def":{"name":"network?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(to_u128 | @prefix.to_u128) == @prefix.to_u128"}},{"id":"network_u128-instance-method","html_id":"network_u128-instance-method","name":"network_u128","doc":"Returns the network number in Unsigned 128bits format\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.network_u128\n  #=> 42540766411282592856903984951653826560\n```","summary":"<p>Returns the network number in Unsigned 128bits format</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L334","def":{"name":"network_u128","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"to_u128 & @prefix.to_u128"}},{"id":"prefix:Prefix128-instance-method","html_id":"prefix:Prefix128-instance-method","name":"prefix","doc":"Returns an instance of the prefix object\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.prefix\n  #=> 64\n```","summary":"<p>Returns an instance of the prefix object</p>","abstract":false,"args":[],"args_string":" : Prefix128","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L93","def":{"name":"prefix","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Prefix128","visibility":"Public","body":"@prefix"}},{"id":"prefix=(num)-instance-method","html_id":"prefix=(num)-instance-method","name":"prefix=","doc":"Set a new prefix number for the object\n\nThis is useful if you want to change the prefix\nto an object created with IPv6::parse_u128 or\nif the object was created using the default prefix\nof 128 bits.\n\n```\nip6 = Subnet::IPv6.new(\"2001:db8::8:800:200c:417a\")\n\nputs ip6.to_string\n  #=> \"2001:db8::8:800:200c:417a/128\"\n\nip6.prefix = 64\nputs ip6.to_string\n  #=> \"2001:db8::8:800:200c:417a/64\"\n```","summary":"<p>Set a new prefix number for the object</p>","abstract":false,"args":[{"name":"num","doc":null,"default_value":"","external_name":"num","restriction":""}],"args_string":"(num)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L149","def":{"name":"prefix=","args":[{"name":"num","doc":null,"default_value":"","external_name":"num","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix = Prefix128.new(num)"}},{"id":"reverse-instance-method","html_id":"reverse-instance-method","name":"reverse","doc":"Returns the IPv6 address in a DNS reverse lookup\nstring, as per RFC3172 and RFC2874.\n\n```\nip6 = Subnet.parse \"3ffe:505:2::f\"\n\nip6.reverse\n  #=> \"f.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.0.0.0.5.0.5.0.e.f.f.3.ip6.arpa\"\n```","summary":"<p>Returns the IPv6 address in a DNS reverse lookup string, as per RFC3172 and RFC2874.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L317","def":{"name":"reverse","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(hexstring.reverse.gsub(/./) do |c|\n  c + \".\"\nend) + \"ip6.arpa\""}},{"id":"size-instance-method","html_id":"size-instance-method","name":"size","doc":"Returns the number of IP addresses included\nin the network. It also counts the network\naddress and the broadcast address.\n\n```\nip6 = Subnet::IPv6.new(\"2001:db8::8:800:200c:417a/64\")\n\nip6.size\n  #=> 18446744073709551616\n```","summary":"<p>Returns the number of IP addresses included in the network.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L365","def":{"name":"size","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"2.to_big_i ** @prefix.host_prefix.to_big_i"}},{"id":"to_big_i-instance-method","html_id":"to_big_i-instance-method","name":"to_big_i","doc":"Return the address as a `BigInt`","summary":"<p>Return the address as a <code>BigInt</code></p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L212","def":{"name":"to_big_i","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"hexstring.to_big_i(16)"}},{"id":"to_i-instance-method","html_id":"to_i-instance-method","name":"to_i","doc":"Returns a the address in as a `BigInt` (will return a\n`UInt128` once support for that is finished in\nthe stdlib)\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.to_i\n  #=> 42540766411282592856906245548098208122\n```","summary":"<p>Returns a the address in as a <code>BigInt</code> (will return a <code>UInt128</code> once support for that is finished in the stdlib)</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L202","def":{"name":"to_i","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"to_big_i"}},{"id":"to_s:String-instance-method","html_id":"to_s:String-instance-method","name":"to_s","doc":"Returns the IPv6 address in a human readable form,\nusing the compressed address.\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.to_s\n  #=> \"2001:db8::8:800:200c:417a\"\n```","summary":"<p>Returns the IPv6 address in a human readable form, using the compressed address.</p>","abstract":false,"args":[],"args_string":" : String","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L188","def":{"name":"to_s","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@compressed"}},{"id":"to_string-instance-method","html_id":"to_string-instance-method","name":"to_string","doc":"Returns the IPv6 address in a human readable form,\nusing the compressed address.\n\n```\nip6 = Subnet.parse \"2001:0db8:0000:0000:0008:0800:200c:417a/64\"\n\nip6.to_string\n  #=> \"2001:db8::8:800:200c:417a/64\"\n```","summary":"<p>Returns the IPv6 address in a human readable form, using the compressed address.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L175","def":{"name":"to_string","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"\"#{@compressed}/#{@prefix}\""}},{"id":"to_string_uncompressed-instance-method","html_id":"to_string_uncompressed-instance-method","name":"to_string_uncompressed","doc":"Unlike its counterpart IPv6#to_string method, IPv6#to_string_uncompressed\nreturns the whole IPv6 address and prefix in an uncompressed form\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.to_string_uncompressed\n  #=> \"2001:0db8:0000:0000:0008:0800:200c:417a/64\"\n```","summary":"<p>Unlike its counterpart IPv6#to_string method, IPv6#to_string_uncompressed returns the whole IPv6 address and prefix in an uncompressed form</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L162","def":{"name":"to_string_uncompressed","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"\"#{@address}/#{@prefix}\""}},{"id":"to_u128-instance-method","html_id":"to_u128-instance-method","name":"to_u128","doc":"Returns a the address in as a `BigInt` (will return a\n`UInt128` once support for that is finished in\nthe stdlib)\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.to_i\n  #=> 42540766411282592856906245548098208122\n```","summary":"<p>Returns a the address in as a <code>BigInt</code> (will return a <code>UInt128</code> once support for that is finished in the stdlib)</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L207","def":{"name":"to_u128","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"to_big_i"}},{"id":"unique_local?-instance-method","html_id":"unique_local?-instance-method","name":"unique_local?","doc":"Checks if an IPv6 address objects belongs\nto a unique-local network RFC4193\n\nExample:\n\n```\nip = Subnet.parse \"fc00::1\"\nip.unique_local?\n  #=> true\n```","summary":"<p>Checks if an IPv6 address objects belongs to a unique-local network RFC4193</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L437","def":{"name":"unique_local?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(self.class.new(\"fc00::/7\")).includes?(self)"}},{"id":"unspecified?-instance-method","html_id":"unspecified?-instance-method","name":"unspecified?","doc":"Returns true if the address is an unspecified address\n\nSee Subnet::IPv6::Unspecified for more information","summary":"<p>Returns true if the address is an unspecified address</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L402","def":{"name":"unspecified?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(@prefix == 128) && (@compressed == \"::\")"}}],"macros":[],"types":[{"html_id":"github.com/watzon/subnet/Subnet/IPv6/Mapped","path":"Subnet/IPv6/Mapped.html","kind":"class","full_name":"Subnet::IPv6::Mapped","name":"Mapped","abstract":false,"superclass":{"html_id":"github.com/watzon/subnet/Subnet/IPv6","kind":"class","full_name":"Subnet::IPv6","name":"IPv6"},"ancestors":[{"html_id":"github.com/watzon/subnet/Subnet/IPv6","kind":"class","full_name":"Subnet::IPv6","name":"IPv6"},{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/subnet/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/subnet/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"subnet/ipv6.cr","line_number":862,"url":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr"}],"repository_name":"github.com/watzon/subnet","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/watzon/subnet/Subnet/IPv6","kind":"class","full_name":"Subnet::IPv6","name":"IPv6"},"doc":"It is usually identified as a IPv4 mapped IPv6 address, a particular\nIPv6 address which aids the transition from IPv4 to IPv6. The\nstructure of the address is\n\n```\n::ffff:w.y.x.z\n```\n\nwhere w.x.y.z is a normal IPv4 address. For example, the following is\na mapped IPv6 address:\n\n```\n::ffff:192.168.100.1\n```\n\nSubnet is very powerful in handling mapped IPv6 addresses, as the\nIPv4 portion is stored internally as a normal IPv4 object. Let's have\na look at some examples. To create a new mapped address, just use the\nclass builder itself\n\n```\nip6 = Subnet::IPv6::Mapped.new \"::ffff:172.16.10.1/128\"\n```\n\nor just use the wrapper method\n\n```\nip6 = Subnet.parse \"::ffff:172.16.10.1/128\"\n```\n\nLet's check it's really a mapped address:\n\n```\nip6.mapped?\n  #=> true\n\nip6.to_string\n  #=> \"::FFFF:172.16.10.1/128\"\n```\n\nNow with the +ipv4+ attribute, we can easily access the IPv4 portion\nof the mapped IPv6 address:\n\n```\nip6.ipv4.address\n  #=> \"172.16.10.1\"\n```\n\nInternally, the IPv4 address is stored as two 16 bits\ngroups. Therefore all the usual methods for an IPv6 address are\nworking perfectly fine:\n\n```\nip6.hexstring\n  #=> \"00000000000000000000ffffac100a01\"\n\nip6.address\n  #=> \"0000:0000:0000:0000:0000:ffff:ac10:0a01\"\n```\n\nA mapped IPv6 can also be created just by specify the address in the\nfollowing format:\n\n```\nip6 = Subnet.parse \"::172.16.10.1\"\n```\n\nThat is, two colons and the IPv4 address. However, as by RFC, the ffff\ngroup will be automatically added at the beginning\n\n```\nip6.to_string\n  => \"::ffff:172.16.10.1/128\"\n```\n\nmaking it a mapped IPv6 compatible address.","summary":"<p>It is usually identified as a IPv4 mapped IPv6 address, a particular IPv6 address which aids the transition from IPv4 to IPv6.</p>","class_methods":[],"constructors":[{"id":"new(str)-class-method","html_id":"new(str)-class-method","name":"new","doc":"Creates a new IPv6 IPv4-mapped address\n\n```\nip6 = Subnet::IPv6::Mapped.new \"::ffff:172.16.10.1/128\"\n\nipv6.ipv4.class\n  #=> Subnet::IPv4\n```\n\nAn IPv6 IPv4-mapped address can also be created using the\nIPv6 only format of the address:\n\n```\nip6 = Subnet::IPv6::Mapped.new \"::0d01:4403\"\n\nip6.to_string\n  #=> \"::ffff:13.1.68.3\"\n```","summary":"<p>Creates a new IPv6 IPv4-mapped address</p>","abstract":false,"args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"args_string":"(str)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L885","def":{"name":"new","args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(str)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"ipv4:IPv4-instance-method","html_id":"ipv4:IPv4-instance-method","name":"ipv4","doc":"The internal IPv4 address.","summary":"<p>The internal IPv4 address.</p>","abstract":false,"args":[],"args_string":" : IPv4","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L867","def":{"name":"ipv4","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"IPv4","visibility":"Public","body":"@ipv4"}},{"id":"mapped?-instance-method","html_id":"mapped?-instance-method","name":"mapped?","doc":"Checks if the IPv6 address is IPv4 mapped\n\n```\nip6 = Subnet.parse \"::ffff:172.16.10.1/128\"\n\nip6.mapped?\n  #=> true\n```","summary":"<p>Checks if the IPv6 address is IPv4 mapped</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L930","def":{"name":"mapped?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"true"}},{"id":"to_s-instance-method","html_id":"to_s-instance-method","name":"to_s","doc":"Similar to IPv6#to_s, but prints out the IPv4 address\nin dotted decimal format\n\n```\nip6 = Subnet.parse \"::ffff:172.16.10.1/128\"\n\nip6.to_s\n  #=> \"::ffff:172.16.10.1\"\n```","summary":"<p>Similar to IPv6#to_s, but prints out the IPv4 address in dotted decimal format</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L905","def":{"name":"to_s","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"\"::ffff:#{@ipv4.address}\""}},{"id":"to_string-instance-method","html_id":"to_string-instance-method","name":"to_string","doc":"Similar to IPv6#to_string, but prints out the IPv4 address\nin dotted decimal format\n\n```\nip6 = Subnet.parse \"::ffff:172.16.10.1/128\"\n\nip6.to_string\n  #=> \"::ffff:172.16.10.1/128\"\n```","summary":"<p>Similar to IPv6#to_string, but prints out the IPv4 address in dotted decimal format</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L918","def":{"name":"to_string","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"\"::ffff:#{@ipv4.address}/#@prefix\""}}],"macros":[],"types":[]},{"html_id":"github.com/watzon/subnet/Subnet/IPv6/Unspecified","path":"Subnet/IPv6/Unspecified.html","kind":"class","full_name":"Subnet::IPv6::Unspecified","name":"Unspecified","abstract":false,"superclass":{"html_id":"github.com/watzon/subnet/Subnet/IPv6","kind":"class","full_name":"Subnet::IPv6","name":"IPv6"},"ancestors":[{"html_id":"github.com/watzon/subnet/Subnet/IPv6","kind":"class","full_name":"Subnet::IPv6","name":"IPv6"},{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/subnet/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/subnet/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"subnet/ipv6.cr","line_number":768,"url":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr"}],"repository_name":"github.com/watzon/subnet","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/watzon/subnet/Subnet/IPv6","kind":"class","full_name":"Subnet::IPv6","name":"IPv6"},"doc":"The address with all zero bits is called the +unspecified+ address\n(corresponding to 0.0.0.0 in IPv4). It should be something like this:\n\n```\n0000:0000:0000:0000:0000:0000:0000:0000\n```\n\nbut, with the use of compression, it is usually written as just two\ncolons:\n\n```\n::\n```\n\nor, specifying the netmask:\n\n```\n::/128\n```\n\nWith Subnet, create a new unspecified IPv6 address using its own\nsubclass:\n\n```\nip = Subnet::IPv6::Unspecified.new\n\nip.to_s\n  #=> => \"::/128\"\n```\n\nYou can easily check if an IPv6 object is an unspecified address by\nusing the IPv6#unspecified? method\n\n```\nip.unspecified?\n  #=> true\n```\n\nAn unspecified IPv6 address can also be created with the wrapper\nmethod, like we've seen before\n\n```\nip = Subnet.parse \"::\"\n\nip.unspecified?\n  #=> true\n```\n\nThis address must never be assigned to an interface and is to be used\nonly in software before the application has learned its host's source\naddress appropriate for a pending connection. Routers must not forward\npackets with the unspecified address.","summary":"<p>The address with all zero bits is called the +unspecified+ address (corresponding to 0.0.0.0 in IPv4).</p>","class_methods":[],"constructors":[{"id":"new(bla=nil)-class-method","html_id":"new(bla=nil)-class-method","name":"new","doc":"Creates a new IPv6 unspecified address\n\n```\nip = Subnet::IPv6::Loopback.new\n\nip.to_string\n  #=> \"::1/128\"\n```","summary":"<p>Creates a new IPv6 unspecified address</p>","abstract":false,"args":[{"name":"bla","doc":null,"default_value":"nil","external_name":"bla","restriction":""}],"args_string":"(bla = <span class=\"n\">nil</span>)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/ipv6.cr#L777","def":{"name":"new","args":[{"name":"bla","doc":null,"default_value":"nil","external_name":"bla","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(bla)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[],"macros":[],"types":[]}]},{"html_id":"github.com/watzon/subnet/Subnet/Prefix","path":"Subnet/Prefix.html","kind":"class","full_name":"Subnet::Prefix","name":"Prefix","abstract":true,"superclass":{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/subnet/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"subnet/prefix.cr","line_number":6,"url":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr"}],"repository_name":"github.com/watzon/subnet","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"}],"extended_modules":[],"subclasses":[{"html_id":"github.com/watzon/subnet/Subnet/Prefix128","kind":"class","full_name":"Subnet::Prefix128","name":"Prefix128"},{"html_id":"github.com/watzon/subnet/Subnet/Prefix32","kind":"class","full_name":"Subnet::Prefix32","name":"Prefix32"}],"including_types":[],"namespace":{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},"doc":"The base class for `Prefix32` and `Prefix128` defining some\ncommon methods that exist in both.","summary":"<p>The base class for <code><a href=\"../Subnet/Prefix32.html\">Prefix32</a></code> and <code><a href=\"../Subnet/Prefix128.html\">Prefix128</a></code> defining some common methods that exist in both.</p>","class_methods":[],"constructors":[{"id":"new(num)-class-method","html_id":"new(num)-class-method","name":"new","doc":"Create a new `Prefix`.","summary":"<p>Create a new <code><a href=\"../Subnet/Prefix.html\">Prefix</a></code>.</p>","abstract":false,"args":[{"name":"num","doc":null,"default_value":"","external_name":"num","restriction":""}],"args_string":"(num)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr#L12","def":{"name":"new","args":[{"name":"num","doc":null,"default_value":"","external_name":"num","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(num)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"+(other)-instance-method","html_id":"+(other)-instance-method","name":"+","doc":"Add this Prefix to another.","summary":"<p>Add this Prefix to another.</p>","abstract":false,"args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"args_string":"(other)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr#L32","def":{"name":"+","args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if other.is_a?(Number)\n  @prefix + other\nelse\n  @prefix + other.prefix\nend"}},{"id":"-(other)-instance-method","html_id":"-(other)-instance-method","name":"-","doc":"Subtract another Prefix from this one.","summary":"<p>Subtract another Prefix from this one.</p>","abstract":false,"args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"args_string":"(other)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr#L41","def":{"name":"-","args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if other.is_a?(Number)\n  @prefix - other\nelse\n  (@prefix - other.prefix).abs\nend"}},{"id":"(other)-instance-method","html_id":"(other)-instance-method","name":"<=>","doc":"Compare this Prefix to another.","summary":"<p>Compare this Prefix to another.</p>","abstract":false,"args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"args_string":"(other)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr#L27","def":{"name":"<=>","args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix <=> other.to_i"}},{"id":"prefix:Int32-instance-method","html_id":"prefix:Int32-instance-method","name":"prefix","doc":null,"summary":null,"abstract":false,"args":[],"args_string":" : Int32","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr#L11","def":{"name":"prefix","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Int32","visibility":"Public","body":"@prefix"}},{"id":"prefix=(prefix:Int32)-instance-method","html_id":"prefix=(prefix:Int32)-instance-method","name":"prefix=","doc":null,"summary":null,"abstract":false,"args":[{"name":"prefix","doc":null,"default_value":"","external_name":"prefix","restriction":"Int32"}],"args_string":"(prefix : Int32)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr#L15","def":{"name":"prefix=","args":[{"name":"prefix","doc":null,"default_value":"","external_name":"prefix","restriction":"Int32"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix = prefix"}},{"id":"to_i:Int32-instance-method","html_id":"to_i:Int32-instance-method","name":"to_i","doc":"Return this Prefix as an integer.","summary":"<p>Return this Prefix as an integer.</p>","abstract":false,"args":[],"args_string":" : Int32","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr#L22","def":{"name":"to_i","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix"}},{"id":"to_s(io)-instance-method","html_id":"to_s(io)-instance-method","name":"to_s","doc":"Convert the Prefix to a string.","summary":"<p>Convert the Prefix to a string.</p>","abstract":false,"args":[{"name":"io","doc":null,"default_value":"","external_name":"io","restriction":""}],"args_string":"(io)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr#L17","def":{"name":"to_s","args":[{"name":"io","doc":null,"default_value":"","external_name":"io","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"io << @prefix.to_s"}}],"macros":[],"types":[]},{"html_id":"github.com/watzon/subnet/Subnet/Prefix128","path":"Subnet/Prefix128.html","kind":"class","full_name":"Subnet::Prefix128","name":"Prefix128","abstract":false,"superclass":{"html_id":"github.com/watzon/subnet/Subnet/Prefix","kind":"class","full_name":"Subnet::Prefix","name":"Prefix"},"ancestors":[{"html_id":"github.com/watzon/subnet/Subnet/Prefix","kind":"class","full_name":"Subnet::Prefix","name":"Prefix"},{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/subnet/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"subnet/prefix.cr","line_number":188,"url":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr"}],"repository_name":"github.com/watzon/subnet","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},"doc":null,"summary":null,"class_methods":[],"constructors":[{"id":"new(num=128)-class-method","html_id":"new(num=128)-class-method","name":"new","doc":"Creates a new prefix object for 128 bits IPv6 addresses\n\n```\nprefix = Subnet::Prefix128.new 64\n  #=> 64\n```","summary":"<p>Creates a new prefix object for 128 bits IPv6 addresses</p>","abstract":false,"args":[{"name":"num","doc":null,"default_value":"128","external_name":"num","restriction":""}],"args_string":"(num = <span class=\"n\">128</span>)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr#L196","def":{"name":"new","args":[{"name":"num","doc":null,"default_value":"128","external_name":"num","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(num)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"bits-instance-method","html_id":"bits-instance-method","name":"bits","doc":"Transforms the prefix into a string of bits\nrepresenting the netmask\n\n```\nprefix = Subnet::Prefix128.new 64\n\nprefix.bits\n  #=> \"1111111111111111111111111111111111111111111111111111111111111111 \\\n  #=>   0000000000000000000000000000000000000000000000000000000000000000\"\n```","summary":"<p>Transforms the prefix into a string of bits representing the netmask</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr#L214","def":{"name":"bits","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(\"1\" * @prefix) + (\"0\" * (128 - @prefix))"}},{"id":"host_prefix-instance-method","html_id":"host_prefix-instance-method","name":"host_prefix","doc":"Returns the length of the host portion\nof a netmask.\n\n```\nprefix = Prefix128.new 96\n\nprefix.host_prefix\n  #=> 32\n```","summary":"<p>Returns the length of the host portion of a netmask.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr#L242","def":{"name":"host_prefix","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"128 - @prefix"}},{"id":"to_u128-instance-method","html_id":"to_u128-instance-method","name":"to_u128","doc":"Unsigned 128 bits decimal number representing\nthe prefix\n\n```\nprefix = Subnet::Prefix128.new 64\n\nprefix.to_u128\n  #=> 340282366920938463444927863358058659840\n```","summary":"<p>Unsigned 128 bits decimal number representing the prefix</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr#L227","def":{"name":"to_u128","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"bits.to_big_i(2)"}}],"macros":[],"types":[]},{"html_id":"github.com/watzon/subnet/Subnet/Prefix32","path":"Subnet/Prefix32.html","kind":"class","full_name":"Subnet::Prefix32","name":"Prefix32","abstract":false,"superclass":{"html_id":"github.com/watzon/subnet/Subnet/Prefix","kind":"class","full_name":"Subnet::Prefix","name":"Prefix"},"ancestors":[{"html_id":"github.com/watzon/subnet/Subnet/Prefix","kind":"class","full_name":"Subnet::Prefix","name":"Prefix"},{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/subnet/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"subnet/prefix.cr","line_number":50,"url":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr"}],"repository_name":"github.com/watzon/subnet","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[{"id":"IN4MASK","name":"IN4MASK","value":"4294967295_i64","doc":null,"summary":null}],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},"doc":null,"summary":null,"class_methods":[{"id":"parse_netmask(netmask)-class-method","html_id":"parse_netmask(netmask)-class-method","name":"parse_netmask","doc":"Creates a new prefix by parsing a netmask in\ndotted decimal form\n\n```\nprefix = Subnet::Prefix32::parse_netmask \"255.255.255.0\"\n  #=> 24\n```","summary":"<p>Creates a new prefix by parsing a netmask in dotted decimal form</p>","abstract":false,"args":[{"name":"netmask","doc":null,"default_value":"","external_name":"netmask","restriction":""}],"args_string":"(netmask)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr#L178","def":{"name":"parse_netmask","args":[{"name":"netmask","doc":null,"default_value":"","external_name":"netmask","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"octets = netmask.is_a?(Indexable) ? netmask : netmask.split('.')\nif octets.size == 4\nelse\n  raise(\"netmask must contain 4 octets\")\nend\noctets = octets.map(&.to_u8)\nnum = (((Slice.new(octets.to_unsafe, 4)).hexstring.to_u32(16)).to_s(2)).count(\"1\")\nPrefix32.new(num)\n"}}],"constructors":[{"id":"new(num)-class-method","html_id":"new(num)-class-method","name":"new","doc":"Creates a new prefix object for 32 bits IPv4 addresses\n\n```\nprefix = Subnet::Prefix32.new 24\n  #=> 24\n```","summary":"<p>Creates a new prefix object for 32 bits IPv4 addresses</p>","abstract":false,"args":[{"name":"num","doc":null,"default_value":"","external_name":"num","restriction":""}],"args_string":"(num)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr#L60","def":{"name":"new","args":[{"name":"num","doc":null,"default_value":"","external_name":"num","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(num)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"[](index)-instance-method","html_id":"[](index)-instance-method","name":"[]","doc":"Shortcut for the octecs in the dotted decimal\nrepresentation\n\n```\nprefix = Subnet::Prefix32.new 24\n\nprefix[2]\n  #=> 255\n```","summary":"<p>Shortcut for the octecs in the dotted decimal representation</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"args_string":"(index)","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr#L139","def":{"name":"[]","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"octets[index]"}},{"id":"bits-instance-method","html_id":"bits-instance-method","name":"bits","doc":"Transforms the prefix into a string of bits\nrepresenting the netmask\n\n```\nprefix = Subnet::Prefix32.new 24\n\nprefix.bits\n  #=> \"11111111111111111111111100000000\"\n```","summary":"<p>Transforms the prefix into a string of bits representing the netmask</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr#L90","def":{"name":"bits","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"\"%.32b\" % to_u32"}},{"id":"host_prefix-instance-method","html_id":"host_prefix-instance-method","name":"host_prefix","doc":"Returns the length of the host portion\nof a netmask.\n\n```\nprefix = Prefix32.new 24\n\nprefix.host_prefix\n  #=> 8\n```","summary":"<p>Returns the length of the host portion of a netmask.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr#L77","def":{"name":"host_prefix","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"32 - @prefix"}},{"id":"hostmask-instance-method","html_id":"hostmask-instance-method","name":"hostmask","doc":"The hostmask is the contrary of the subnet mask,\nas it shows the bits that can change within the\nhosts\n\n```\nprefix = Subnet::Prefix32.new 24\n\nprefix.hostmask\n  #=> \"0.0.0.255\"\n```","summary":"<p>The hostmask is the contrary of the subnet mask, as it shows the bits that can change within the hosts</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr#L153","def":{"name":"hostmask","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"hostmask_octets.join('.')"}},{"id":"hostmask_octets-instance-method","html_id":"hostmask_octets-instance-method","name":"hostmask_octets","doc":"Returns an array of octets representing the hostmask\n\n```\nprefix = Subnet::Prefix32.new 24\n\nprefix.hostmask_octets\n  # => StaticArray[\"0\", \"0\", \"0\", \"255\"]\n```","summary":"<p>Returns an array of octets representing the hostmask</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr#L165","def":{"name":"hostmask_octets","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"octets = uninitialized ::StaticArray(UInt8, 4)\nIO::ByteFormat::BigEndian.encode(~to_u32.to_u32, octets.to_slice)\noctets\n"}},{"id":"octets-instance-method","html_id":"octets-instance-method","name":"octets","doc":"An array of octets of the IPv4 dotted decimal\nformat\n\n```\nprefix = Subnet::Prefix32.new 24\n\nprefix.octets\n  #=> [255, 255, 255, 0]\n```","summary":"<p>An array of octets of the IPv4 dotted decimal format</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr#L116","def":{"name":"octets","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(\"%08.64x\" % (bits.to_i64(2))).hexbytes"}},{"id":"to_ip-instance-method","html_id":"to_ip-instance-method","name":"to_ip","doc":"Gives the prefix in IPv4 dotted decimal format,\ni.e. the canonical netmask we're all used to\n\n```\nprefix = Subnet::Prefix32.new 24\n\nprefix.to_ip\n  #=> \"255.255.255.0\"\n```","summary":"<p>Gives the prefix in IPv4 dotted decimal format, i.e.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr#L103","def":{"name":"to_ip","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"octets.join('.')"}},{"id":"to_u32-instance-method","html_id":"to_u32-instance-method","name":"to_u32","doc":"Unsigned 32 bit number representing the prefix.\n\n  prefix = Subnet::Prefix32.new 24\n\n  prefix.to_u32\n    #=> 4294967040","summary":"<p>Unsigned 32 bit number representing the prefix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/615465ab49f296eebf14b24655abaf4dee4fc52c/src/subnet/prefix.cr#L126","def":{"name":"to_u32","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(IN4MASK >> host_prefix) << host_prefix"}}],"macros":[],"types":[]}]}]}})
crystal_doc_search_index_callback({"repository_name":"github.com/watzon/subnet","body":"# Subnet\n\nSubnet is a Crystal library designed to make the use of IPv4 and IPv6 addresses simple, powerful and enjoyable. It provides a complete set of methods to handle IP addresses for any need, from simple scripting to full network design.\n\nSubnet is written with a full OO interface, and its code is easy to read, maintain and extend. The documentation is full of examples, to let you start being productive immediately.\n\nThis document provides a brief introduction to the library and examples of typical usage. You can check out the full documentation [here](https://watzon.github.io/subnet/).\n\n# Table of Contents\n\n- [Subnet](#Subnet)\n- [Table of Contents](#Table-of-Contents)\n  - [Installation](#Installation)\n  - [IPv4](#IPv4)\n    - [Create a new IPv4 address](#Create-a-new-IPv4-address)\n    - [Handling IPv4 addresses](#Handling-IPv4-addresses)\n    - [Changing netmask](#Changing-netmask)\n    - [Working with networks, broadcasts, and addresses](#Working-with-networks-broadcasts-and-addresses)\n      - [Networks](#Networks)\n      - [Broadcast](#Broadcast)\n    - [Addresses, ranges, and iterators](#Addresses-ranges-and-iterators)\n    - [Special formats](#Special-formats)\n    - [Classful networks](#Classful-networks)\n    - [Network design with Subnet](#Network-design-with-Subnet)\n      - [Subnetting](#Subnetting)\n      - [Summarization](#Summarization)\n      - [Supernetting](#Supernetting)\n  - [IPv6](#IPv6)\n    - [IPv6 addresses](#IPv6-addresses)\n      - [Compression](#Compression)\n      - [Network Mask](#Network-Mask)\n    - [Using Subnet with IPv6 addresses](#Using-Subnet-with-IPv6-addresses)\n    - [Handling IPv6 addresses](#Handling-IPv6-addresses)\n    - [Compressing and uncompressing](#Compressing-and-uncompressing)\n    - [Other formats](#Other-formats)\n    - [Special IPv6 addresses](#Special-IPv6-addresses)\n      - [Unspecified addresses](#Unspecified-addresses)\n      - [Loopback addresses](#Loopback-addresses)\n      - [Mapped addresses](#Mapped-addresses)\n  - [Development](#Development)\n  - [Contributing](#Contributing)\n  - [Contributors](#Contributors)\n\n## Installation\n\n1. Add the dependency to your `shard.yml`:\n\n   ```yaml\n   dependencies:\n     subnet:\n       github: watzon/subnet\n   ```\n\n2. Run `shards install`\n\n3. Require it in your project\n\n   ```crystal\n   require \"subnet\"\n   ```\n\n## IPv4\n\nThe class `Subnet::IPv4` is used to handle IPv4 type addresses. This, and other classes, are almost 1/1 the same as the [IPAddress](https://github.com/ipaddress-gem/ipaddress) ruby gem which this was based off of.\n\n### Create a new IPv4 address\n\nCreating a IPv4 address is simple\n\n```crystal\nip = Subnet::IPv4.new(\"172.16.10.1\")\n```\n\nand supports prefixes.\n\n```crystal\nip = Subnet::IPv4.new(\"172.16.10.1/24\")\n```\n\nYou can also use the somewhat easier\n\n```crystal\nip = Subnet.parse(\"172.16.10.1/24\")\n```\n\nwhich parses both IPv4 and IPv6 addresses. The result from this will be of type `Subnet` though and will only freely have the methods that both `Subnet::IPv4` and `Subnet::IPv6` share in common. For now to circumvent this you can do `.as(Subnet::IPv4)` or just use `IPv4.new`.\n\nIf you don't explicitly specify the prefix (or the subnet mask), Subnet will think you're dealing with host addresses and not with networks. Therefore, the default prefix will be `/32`, or `255.255.255.255`. For example:\n\n```crystal\n# let's declare an host address\nhost = Subnet::IPv4.new(\"10.1.1.1\")\n\nputs host.to_string\n# => \"10.1.1.1/32\"\n```\n\nYou can also parse a `UInt32` to create a new IPv4 object\n\n```crystal\nip = IPv4.parse_u32(167837953)\nputs ip.to_string\n# => \"10.1.1.1/32\"\n```\n\n### Handling IPv4 addresses\n\nOnce created, you can obtain the attributes for an IPv4 object\n\n```crystal\nip = Subnet::IPv4.new(\"172.16.10.1/24\")\n\nip.address\n# => \"172.16.10.1\"\nip.prefix\n# => 24\n```\n\nIf you need to retrieve the netmask in IPv4 format, you can use the `IPv4#netmask` method:\n\n```crystal\nip.netmask\n# => \"255.255.255.0\"\n```\n\nA special attribute, `IPv4#octets`, is available to get the four decimal octets from the IP address:\n\n```crystal\nip.octets\n# => [172, 16, 10, 1]\n```\n\nThe shortcut method `IPv4#[]`, provides access to a given octet at the specified index:\n\n```\nip[1]\n# => 16\n```\n\nIf you need to print out the IPv4 address in a canonical form, you can use `IPv4#to_string`:\n\n```crystal\nip.to_string\n# => \"172.16.10.1/24\"\n```\n\n`IPv4#to_s` is also available and prints the address without the prefix\n\n```crystal\nip.to_s\n# => \"172.16.10.1\"\n```\n\n### Changing netmask\n\nYou can set a new prefix (netmask) after creating an IPv4 object. For example\n\n```\nip.prefix = 25\n\nip.to_string\n# => \"172.16.10.1/25\"\n```\n\nIf you need to use a netmask in IPv4 format, you can do so by using the `IPv4#netmask=` method\n\n```crystal\nip.netmask = \"255.255.255.252\"\n\nip.to_string\n# => \"172.16.10.1/30\"\n```\n\n### Working with networks, broadcasts, and addresses\n\nSome very important topics in dealing with IP addresses are the concepts of `network` and `broadcast`, as well as the addresses included in a range.\n\nWhen you specify an IPv4 address such as `172.16.10.1/24`, you are actually handling two different types of information:\n\n- The IP address itself, `172.16.10.1`\n- The subnet mask which indicates the network\n\nThe network number is the IP which has all zeroes in the host portion. In our example, because the prefix is 24, we identify our network number to have the last 8 (32-24) bits all zeroes. Thus, IP address `172.16.10.1/24` belongs to network `172.16.10.0/24`.\n\nThis is very important because, for instance, IP `172.16.10.1/16` is very different to the previous one, belonging to the very different network `172.16.0.0/16`.\n\n#### Networks\n\nWith Subnet it's very easy to calculate the network for an IP address\n\n```crystal\nip = Subnet::IPv4.new(\"172.16.10.1/24\")\n\nnet = ip.network\n# => #<Subnet::IPv4:0xb7a5ab24 @octets=[172, 16, 10, 0], \n                               @prefix=24,\n                               @address=\"172.16.10.0\">\nnet.to_string\n# => \"172.16.10.0/24\"\n```\nThe method `IPv4#network` creates a new IPv4 object from the network number, calculated after the original object. I want to outline here that the network address is a perfectly legitimate IPv4 address, which just happen to have all zeroes in the host portion.\n\nYou can use method `IPv4#network?` to check whether an IP address is a network or not\n\n```crystal\nip1 = Subnet::IPv4.new(\"172.16.10.1/24\")\nip2 = Subnet::IPv4.new(\"172.16.10.4/30\")\n\nip1.network?\n# => false\nip2.network?\n# => true\n```\n\n#### Broadcast\n\nThe broadcast address is the oposite of the network number: where the network number has all zeroes in the host portion, the broadcast address has all one's. For example, the ip `172.16.10.1/24` has the broadcast `172.16.10.255/24`, where the ip `172.16.10.1/16` has the broadcast `172.16.255.255/16`.\n\nThe method `IPv4#broadcast` has the same behavior as its `#network` counterpart: it creates a new IPv4 object to handle the broadcast address\n\n```crystal\nip = Subnet::IPv4.new(\"172.16.10.1/24\")\n\nbcast = ip.broadcast\n# => #<Subnet::IPv4:0xb7a406fc @octets=[172, 16, 10, 255],\n                               @prefix=24, \n                               @address=\"172.16.10.255\">\nbcast.to_string\n# => \"172.16.10.255/24\"\n```\n\n### Addresses, ranges, and iterators\n\nClass `IPv4` includes the `Iterator` and `Enumberable` modules, as well as having the methods `succ` and `pred` which allow it to be used with `Range`. This makes creating sets of addresses very easy, and very powerful.\n\nLet's start with `IPv4#each`, which iterates over all addresses in a range\n\n```crystal\nip = Subnet::IPv4.new(\"172.16.10.1/24\")\n\nip.each do |addr|\n  puts addr\nend\n```\n\nIt is important to note that it doesn't matter if the original IP is a host IP or a network number (or a broadcast address): the `#each` method only considers the range that the original IP specifies.\n\nIf you only want to iterate over hosts IP, use the `IPv4#each_host` method\n\n```crystal\nip = Subnet::IPv4.new(\"172.16.10.1/24\")\n\nip.each_host do |host|\n  puts host\nend\n```\n\nMethods `IPv4#first` and `IPv4#last` return a new object containing respectively the first and the last host address in the range\n\n```crystal\nip = Subnet:IPv4.new(\"172.16.10.100/24\")\n\nip.first.to_string\n# => \"172.16.10.1/24\"\n\nip.last.to_string\n# => \"172.16.10.254/24\"\n```\n\nChecking if an address is loopback is easy with the `IPv4#loopback?` method\n\n```crystal\nip = Subnet::IPv4.new(\"127.0.0.1\")\n\nip.loopback?\n# => true\n```\n\nChecking if an address is in the multicast range can be done using the `IPv4#multicast?` method\n\n```crystal\nip = Subnet::IPv4.new(\"224.0.0.1/32\")\n\nip.multicast?\n# => true\n```\n\nThe ability to generate a range also exists by using the `IPv4#to()` method. This allows you to create a subnet agnostic range based off a fixed amount.\n\n```crystal\nip = Subnet::IPv4.new(\"172.16.10.100/24\")\nip.to(\"172.16.10.110\")\n# => [\"172.16.10.100\", ..., \"172.16.10.110\"]\n```\n\nAs mentioned previously, you can also create Crystal Ranges using the Range literal\n\n```crystal\nrange = Subnet.parse(\"192.168.0.1\")..Subnet.parse(\"192.168.0.255\")\nputs range.size\n# => 255\n```\n\n### Special formats\n\nThe Subnet library provides a complete set of methods to access an IPv4 object in special formats such as binary, hexidecimal, 32 bit unsigned int, and a raw data string.\n\nLet's check out the following IPv4 for example\n\n```crystal\nip = Subnet::IPv4.new(\"172.16.10.1/24\")\n\nip.address\n# => \"172.16.10.1\"\n```\n\nThe first thing to highlight here is that all these conversion methods only take into consideration the address portion of an IPv4 object and not the prefix (netmask).\n\nSo, to express the address in binary format, use the `IPv4#bits` method\n\n```crystal\nip.bits\n# => \"10101100000100000000101000000001\"\n```\n\nTo calculate the 32 bits unsigned int format of the ip address, use the `IPv4#to_u32` method\n\n```crystal\nip.to_u32\n# => 2886732289\n```\n\nThis method is the equivalent of the Unix call `pton()`, expressing an IP address in the so called *network byte order* notation.\n\nTo maintain compatibility with the Ruby library the `IPv4#data` was included. Apparently it's useful for transmitting data over a network socket\n\n```crystal\nip.data\n# => \"\\254\\020\\n\\001\n```\n\nYou can also transform IPv4 addresses into a format which is suitable to use in IPv4-IPv6 mapped addresses\n\n```crystal\nip.to_ipv6\n# => \"ac10:0a01\"\n```\n\nFinally, much like `IPv4#to_ipv6` you can use the `IPv4#hexstring` method to return a non-semicolon delineated string (useful with pcap/byte level usage)\n\n```crystal\nip.hexstring\n# => \"ac100a01\"\n```\n\n### Classful networks\n\nSubnet allows you to create and manipulate objects using the old and deprecated (but apparently still popular) classful networks concept.\n\nClassful networks and addresses don't have a prefix: their subnet mask is univocally identified by their address, and therefore divided in classes. As per RFC 791, these classes are:\n\n- Class A, from 0.0.0.0 to 127.255.255.255\n- Class B, from 128.0.0.0 to 191.255.255.255\n- Class C, from 192.0.0.0 to 255.255.255.255\n\nSince classful networks here are only considered to calculate the default prefix number, classes D and E are not considered.\n\nTo create a classful IP and prefix from an IP address, use the `IPv4::parse_classful` method\n\n```crystal\n# classful ip \nip = Subnet::IPv4::parse_classful(\"10.1.1.1\")\n\nip.prefix\n# => 8\n```\n\nThe method automatically creates a new IPv4 object and assigned it the correct prefix.\n\nYou can easily check which CLASSFUL network an IPv4 object belongs to\n\n```crystal\nip = Subnet::IPv4.new(\"10.0.0.1/24\")\nip.a?\n# => true\n\nip = Subnet::IPv4.new(\"172.16.10.1/24\")\nip.b?\n# => true\n\nip = Subnet::IPv4.new(\"192.168.1.1/30\")\nip.c?\n# => true\n```\n\nRemember that these methods are only checking the address portion of an IP, and are independent from its prefix, as classful networks have no concept of prefix.\n\nFor more information on CLASSFUL networks visit the [Wikipedia page](http://en.wikipedia.org/wiki/Classful_network).\n\n### Network design with Subnet\n\nSubnet includes several useful methods to manipulate IPv4 and IPv6 networks and do some basic network design.\n\n#### Subnetting\n\nThe process of subnetting is the division of a network into smaller (in terms of hosts capacity) networks, called subnets, so that they all share a common root, which is the starting network.\n\nFor example, if you have network `172.16.10.0/24`, we can subnet it into 4 smaller subnets. The new prefix will be /26, because 4 is 2^2 and therefore we add 2 bits to the network prefix (24+2=26).\n\nSubnetting is easy with Subnet. You actually have two options:\n\n- `IPv4#subnet`: specify a new prefix\n- `IPv4#split`: tell Subnet how many subnets you want to create\n\nLet's examine `IPv4#subnet` first. Say you have network `172.16.10.0/24` and you want to subnet it into /26 networks. With Subnet it's extremely simple\n\n```crystal\nnetwork = Subnet::IPv4.new(\"172.16.10.0/24\")\n\nsubnets = network.subnet(26)\n\nsubnets.map(&.to_string)\n# => [\"172.16.10.0/26\", \n      \"172.16.10.64/26\", \n      \"172.16.10.128/26\", \n      \"172.16.10.192/26\"]\n```\n\nAs you can see, an Array has been created, containing 4 new IPv4 objects representing the new subnets.\n\nAnother way to create subnets is to tell Subnet how many subnets you'd like to have, and letting the library calculate the new prefix for you.\n\nLet's see how it works, using `IPv4#split` method. Say you want 4 new subnets\n\n```crystal\nnetwork = Subnet::IPv4.new(\"172.16.10.0/24\")\n\nsubnets = network.split(4)\n\nsubnets.map(&.to_string)\n# => [\"172.16.10.0/26\", \n      \"172.16.10.64/26\", \n      \"172.16.10.128/26\", \n      \"172.16.10.192/26\"]\n```\n\nHey, that's the same result as before! This actually makes sense, as the two operations are complementary. When you use `IPv4#subnet` with the new prefix, Subnet will always create a number of subnets that is a power of two. This is equivalent to use `IPv4#split` with a power of 2.\n\nWhere `IPv4#split` really shines is with the so called *uneven subnetting*. You are not limited to splitting a network into a power-of-two number of subnets: Subnet lets you create any number of subnets, and it will try to organize the new created network in the best possible way, making an efficient allocation of the space.\n\nAn example here is worth a thousand words. Let's use the same network as the previous examples\n\n```crystal\nnetwork = Subnet::IPv4.parse(\"172.16.10.0/24\")\n```\n\nHow do we split this network into 3 subnets? Very easy\n\n```crystal\nsubnets = network.split(3)\n\nsubnets.map(&.to_string)\n# => [\"172.16.10.0/26\",\n      \"172.16.10.64/26\",\n      \"172.16.10.128/25\"]\n```\n\nAs you can see, Subnet tried to perform an efficient allocation by filling up all the address space from the original network. There is no point in splitting a network into 3 subnets like `172.16.10.0/26`, `172.16.10.64/26` and `172.16.10.128/26`, as you would end up having `172.16.10.192/26` wasted.\n\nWe can go even further and split into 11 subnets\n\n```crystal\nsubnets = network.split(11)\n\nsubnets.map(&.to_string)\n# => [\"172.16.10.0/28\", \"172.16.10.16/28\", \"172.16.10.32/28\",\n      \"172.16.10.48/28\", \"172.16.10.64/28\", \"172.16.10.80/28\",\n      \"172.16.10.96/28\", \"172.16.10.112/28\", \"172.16.10.128/27\",\n      \"172.16.10.160/27\", \"172.16.10.192/26\"]\n```\n\nAs you can see, most of the networks are `/28`, with a few `/27` and one `/26` to fill up the remaining space.\n\n#### Summarization\n\nSummarization (or aggregation) is the process when two or more networks are taken together to check if a supernet, including all and only these networks, exists. If it exists then this supernet is called the summarized (or aggregated) network. It is very important to understand that summarization can only occur if there are no holes in the aggregated network, or, in other words, if the given networks fills completely the address space of the supernet. So the two rules are\n\n1. The aggregate network must contain all the IP addresses of the original networks\n2. The aggregate network must contain only the IP addresses of the original networks\n\nA few examples will help clarify the above. Let's consider for instance the following two networks\n\n```crystal\nip1 = Subnet::IPv4.new(\"172.16.10.0/24\")\nip2 = Subnet::IPv4.new(\"172.16.11.0/24\")\n```\n\nThese two networks can be expressed using only one IP address network if we change the prefix. Let Crystal do the work\n\n```crystal\nSubnet::IPv4::summarize(ip1, ip2).map(&.to_string)\n# => \"172.16.10.0/23\"\n```\n\nWe note how the network `172.16.10.0/23` includes all the addresses specified in the above networks, and (more importantly) includes ONLY those addresses.\n\nIf we summarized `ip1` and `ip2` with the following network\n\n```crystal\n\"172.16.0.0/16\"\n```\n\nwe would have satisfied rule #1 above, but not rule #2. So\n\n```crystal\n\"172.16.0.0/16\"\n```\n\nis not an aggregate network for ip1 and ip2.\n\nIf it's not possible to compute a single aggregated network for all the original networks, the method returns an array with all the aggregate networks found. For example, the following four networks can be aggregated in a single `/22`\n\n```crystal\nip1 = Subnet::IPv4.new(\"10.0.0.1/24\")\nip2 = Subnet::IPv4.new(\"10.0.1.1/24\")\nip3 = Subnet::IPv4.new(\"10.0.2.1/24\")\nip4 = Subnet::IPv4.new(\"10.0.3.1/24\")\n\nSubnet::IPv4::summarize(ip1, ip2, ip3, ip4).map(&.to_string)\n# => [\"10.0.0.0/22\"]\n```\n\nBut the following networks can't be summarized in a single network:\n\n```crystal\nip1 = Subnet::IPv4.new(\"10.0.1.1/24\")\nip2 = Subnet::IPv4.new(\"10.0.2.1/24\")\nip3 = Subnet::IPv4.new(\"10.0.3.1/24\")\nip4 = Subnet::IPv4.new(\"10.0.4.1/24\")\n\nSubnet::IPv4::summarize(ip1, ip2, ip3, ip4).map(&.to_string)\n# => [\"10.0.1.0/24\", \"10.0.2.0/23\", \"10.0.4.0/24\"]\n```\n\nIn this case, the two summarizables networks have been aggregated into a single `/23`, while the other two networks have been left untouched.\n\n#### Supernetting\n\nSupernetting is a different operation than aggregation, as it only works on a single network and returns a new single IPv4 object, representing the supernet.\n\nSupernetting is similar to subnetting, except that you getting as a result a network with a smaller prefix (bigger host space). For example, given the network\n\n```crystal\nip = Subnet::IPv4.new(\"172.16.10.0/24\")\n```\n\nyou can supernet it with a new `/23` prefix\n\n```crystal\nip.supernet(23).to_string\n# => \"172.16.10.0/23\"\n```\n\nHowever if you supernet it with a `/22` prefix, the network address will change\n\n```crystal\nip.supernet(22).to_string\n# => \"172.16.8.0/22\"\n```\n\nThis is because `172.16.10.0/22` is not a network anymore, but a host address.\n\n## IPv6\n\nIPv6 support in Subnet is still being tested and won't be super efficient until Crystal fully supports `UInt128`. The current implementation uses `BigInt` to handle math operations which may not be very efficient, but is necessary.\n\nThat being said, Subnet fully supports IPv6 and allows you to perform an array of complex operations with IPv6 addresses.\n\n### IPv6 addresses\n\nIPv6 addresses are 128 bits long (hence the need for `UInt128`), in contrast with IPv4 addresses which are only 32 bits long. An IPv6 address is generally written as eight groups of four hexadecimal digits, each group representing 16 bits or two octet. For example, the following is a valid IPv6 address\n\n```\n2001:0db8:0000:0000:0008:0800:200c:417a\n```\n\nLetters in an IPv6 address are usually written lowercase, as per the RFC. You can create a new IPv6 object using uppercase letters, but they will be converted\n\n#### Compression\n\nSince IPv6 addresses are long (32 characters, not including colons), there are compression standards you can use to shorten the addresses:\n\n- Leading zeroes: all the leading zeroes within a group can be omitted: “0008” would become “8”.\n- A string of consecutive zeroes can be replaced by the string “::”. This can be only applied once.\n\nUsing compression, the IPv6 address written above can be shorten into the following, equivalent, address\n\n```\n2001:db8::8:800:200c:417a\n```\n\nThis shorter version is often used and is perfectly valid.\n\n#### Network Mask\n\nAs we used to do with IPv4 addresses, an IPv6 address can be written using the prefix notation to specify the subnet mask\n\n```\n2001:db8::8:800:200c:417a/64\n```\n\nThe `/64` part means that the first 64 bits of the address are representing the network portion, and the last 64 bits are the host portion.\n\n### Using Subnet with IPv6 addresses\n\nAll the IPv6 representations we've just seen are perfectly fine when you want to create a new IPv6 address\n\n```crystal\nip6 = Subnet::IPv6.new(\"2001:0db8:0000:0000:0008:0800:200C:417A\")\n\nip6 = Subnet::IPv6.new(\"2001:db8:0:0:8:800:200C:417A\")\n\nip6 = Subnet::IPv6.new(\"2001:db8:8:800:200C:417A\")\n```\n\nAll three return the same IPv6 object. The default subnet mask for an IPv6 is 128, as IPv6 addresses don't have classes like IPv4 addresses. If you want a different mask, you can go ahead and include it explicitly\n\n```crystal\nip6 = Subnet::IPv6.new(\"2001:db8::8:800:200c:417a/64\")\n```\n\nAccess the address portion and the prefix by using their respective methods\n\n```crystal\nip6 = Subnet::IPv6.parse(\"2001:db8::8:800:200c:417a/64\")\n\nip6.address\n# => \"2001:0db8:0000:0000:0008:0800:200c:417a\"\n\nip6.prefix\n# => 64\n```\n\nA compressed version of the IPv6 address can be obtained with the `IPv6#compressed` method\n\n```crystal\nip6 = Subnet::IPv6.new(\"2001:0db8:0000:0000:0008:200c:417a:00ab/64\")\n\nip6.compressed\n# => \"2001:db8::8:800:200c:417a\"\n```\n\n### Handling IPv6 addresses\n\nAccessing the groups that form an IPv6 address is very easy with the `IPv6#groups` method\n\n```crystal\nip6 = Subnet::IPv6.new(\"2001:db8::8:800:200c:417a/64\")\n\nip6.groups\n# => [8193, 3512, 0, 0, 8, 2048, 8204, 16762]\n```\n\nAs with IPv4 addresses, each individual group can be accessed using the `IPv6#[]` shortcut method\n\n```crystal\nip6[0]\n# => 8193\n\nip6[1]\n# => 3512\n\nip6[2]\n# => 0\n\nip6[3]\n# => 0\n```\n\nNote that each 16 bits group is expressed in its decimal form. You can also obtain the groups into hexadecimal format using the `IPv6#hex_groups` method\n\n```crystal\nip6.hex_groups\n# => [\"2001\", \"0db8\", \"0000\", \"0000\", \"0008\", \"0800\", \"200c\", \"417a\"]\n```\n\nYou can transform the address into it's decimal representation with `IPv6#to_i`. For now this returns a `BigInt`, but a `UInt128` will be returned in the future.\n\n```crystal\nip6.to_i\n# => 42540766411282592856906245548098208122\n```\n\nYou can also get the full hexidecimal representation of the address.\n\n```crystal\nip6.hexstring\n# => \"20010db80000000000080800200c417a\"\n```\n\nLike IPv4, IPv6 includes both the `#to_s` and `#to_string` methods with the former returning the address without the netmask, and the latter containing the netmask. IPv6 also includes a `#to_string_uncompressed` to return the full, uncompressed address\n\n```crystal\nip6 = Subnet::IPv6.new(\"2001:db8::8:800:200c:417a/64\")\n\nip6.to_s\n# => \"2001:db8::8:800:200c:417a\"\n\nip6.to_string\n# => \"2001:db8::8:800:200c:417a/96\"\n\nip6.to_string_uncompressed\n# => \"2001:0db8:0000:0000:0008:0800:200c:417a/96\"\n```\n\n### Compressing and uncompressing\n\nIf you have a string representing an IPv6 address, you can easily compress it and uncompress it using the two class methods `IPv6.expand` and `IPv6.compress`.\n\nFor example, let's say you have the following uncompressed IPv6 address\n\n```crystal\nip6str = \"2001:0DB8:0000:CD30:0000:0000:0000:0000\"\n```\n\nHere is the compressed version\n\n```crystal\nSubnet::IPv6.compress(ip6str)\n# => \"2001:db8:0:cd30::\"\n```\n\nThe other way works as well\n\n```crystal\nip6str = \"2001:db8:0:cd30::\"\n\nSubnet::IPv6.expand(ip6str)\n# => \"2001:0DB8:0000:CD30:0000:0000:0000:0000\"\n```\n\nThese methods can be used when you don't want to create a new object just for expanding or compressing an address (although a new object is actually created internally).\n\n### Other formats\n\nYou can create a new IPv6 address from different formats than just a string representing the colon-hex groups.\n\nFor instance, if you have a data stream, you can use `IPv6::parse_data`, like in the following example\n\n```crystal\ndata = \" \\001\\r\\270\\000\\000\\000\\000\\000\\b\\b\\000 \\fAz\"\n\nip6 = Subnet::IPv6::parse_data(data)\nip6.prefix = 64\n\nip6.to_string\n# => \"2001:db8::8:800:200c:417a/64\"\n```\n\nA new IPv6 address can also be created from an unsigned 128 bit (BigInt) integer. Once again, BigInt is being used until `UInt128` is supported by the Crystal compiler.\n\n```crystal\nu128 = BigInt.new(\"42540766411282592856906245548098208122\")\n\nip6 = Subnet::IPv6::parse_u128(u128)\nip6.prefix = 64\n\nip6.to_string\n# =>\"2001:db8::8:800:200c:417a/64\"\n```\n\nFinally, a new IPv6 address can be created from an hex string:\n\n```crystal\nhex = \"20010db80000000000080800200c417a\"   \n\nip6 = Subnet::IPv6::parse_hex(hex)\nip6.prefix = 64\n\nip6.to_string\n# => \"2001:db8::8:800:200c:417a/64\"\n```\n\n### Special IPv6 addresses\n\nSome IPv6 have a special meaning and are expressed in a special form, quite different than an usual IPv6 address. IPAddress has built-in support for unspecified, loopback and mapped IPv6 addresses\n\n#### Unspecified addresses\n\nThe address with all zero bits is called the `unspecified address` (corresponding to `0.0.0.0` in IPv4). It should be something like this\n\n```\n0000:0000:0000:0000:0000:0000:0000:0000\n```\n\nbut, with the use of compression, it is usually written as just two colons\n\n```\n::\n```\n\nor, specifying the netmask\n\n```\n::/128\n```\n\nWith Subnet, create a new unspecified IPv6 address using the `Unspecified` subclass\n\n```crystal\nip = Subnet::IPv6::Unspecified.new\n\nip.to_string\n# => \"::/128\"\n```\n\nYou can easily check if an IPv6 object is an unspecified address by using the `IPv6#unspecified?` method\n\n```crystal\nip.unspecified?\n# => true\n```\n\nThis address must never be assigned to an interface and is to be used only in software before the application has learned its host's source address appropriate for a pending connection. Routers must not forward packets with the unspecified address.\n\n#### Loopback addresses\n\nThe loopback address is a unicast localhost address. If an application in a host sends packets to this address, the IPv6 stack will loop these packets back on the same virtual interface.\n\nLoopback addresses are expressed in the following form\n\n```\n::1\n```\n\nor with its appropriate prefix\n\n```\n::1/128\n```\n\nAs for the unspecified addresses, IPv6 loopbacks can be created with Subnet calling its own class\n\n```\nip = Subnet::IPv6::Loopback.new\n\nip.to_string\n# => \"::1/128\"\n```\n\nChecking if an address is loopback is easy with the `IPv6#loopback?` method\n\n```crystal\nip.loopback?\n# => true\n```\n\nThe IPv6 loopback address corresponds to `127.0.0.1` in IPv4.\n\n#### Mapped addresses\n\nIt is usually identified as a IPv4 mapped IPv6 address, a particular IPv6 address which aids the transition from IPv4 to IPv6. The structure of the address is\n\n```\n::ffff:w.y.x.z\n```\n\nwhere `w.x.y.z` is a normal IPv4 address. For example, the following is a mapped IPv6 address\n\n```\n::ffff:192.168.100.1\n```\n\nSubnet is very powerful at handling mapped IPv6 addresses, as the IPv4 portion is stored internally as a normal IPv4 object. Let's have a look at some examples. To create a new mapped address, just use the class builder itself\n\n```crystal\nip6 = Subnet::IPv6::Mapped.new(\"::ffff:172.16.10.1/128\")\n```\n\nLet's check it's really a mapped address:\n\n```\nip6.mapped?\n# => true\n\nip6.to_string\n# => \"::ffff:172.16.10.1/128\"\n```\n\nNow with the `#ipv4` attribute, we can easily access the IPv4 portion of the mapped IPv6 address\n\n```crystal\nip6.ipv4.address\n# => \"172.16.10.1\"\n```\n\nInternally, the IPv4 address is stored as two 16 bits groups. Therefore all the usual methods for an IPv6 address are working perfectly fine\n\n```crystal\nip6.to_hex\n# => \"00000000000000000000ffffac100a01\"\n\nip6.address\n# => \"0000:0000:0000:0000:0000:ffff:ac10:0a01\"\n```\n\nA mapped IPv6 can also be created just by specify the address in the following format\n\n```crystal\nip6 = Subnet.parse(\"::172.16.10.1\")\n```\n\nThat is, two colons and the IPv4 address. However, as by RFC, the `ffff` group will be automatically added at the beginning\n\n```crystal\nip6.to_string\n# => \"::ffff:172.16.10.1/128\"\n```\n\nmaking it a mapped IPv6 compatible address.\n\n## Development\n\nSubnet should be feature complete at the moment, but if there is anything missing feel free to create an issue and open a PR. The API may change as it is currently heavily based on the Ruby implementation, so please bear with me.\n\n## Contributing\n\n1. Fork it (<https://github.com/watzon/subnet/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n## Contributors\n\n- [Chris Watson](https://github.com/watzon) - creator and maintainer\n","program":{"html_id":"github.com/watzon/subnet/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"superclass":null,"ancestors":[],"locations":[],"repository_name":"github.com/watzon/subnet","program":true,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":null,"doc":null,"summary":null,"class_methods":[],"constructors":[],"instance_methods":[],"macros":[],"types":[{"html_id":"github.com/watzon/subnet/Subnet","path":"Subnet.html","kind":"module","full_name":"Subnet","name":"Subnet","abstract":false,"superclass":null,"ancestors":[],"locations":[{"filename":"subnet/version.cr","line_number":1,"url":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/version.cr"},{"filename":"subnet/prefix.cr","line_number":3,"url":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr"},{"filename":"subnet/ipv4.cr","line_number":3,"url":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr"},{"filename":"subnet/ipv6.cr","line_number":4,"url":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr"},{"filename":"subnet.cr","line_number":6,"url":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet.cr"}],"repository_name":"github.com/watzon/subnet","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[{"id":"VERSION","name":"VERSION","value":"\"0.1.0\"","doc":null,"summary":null}],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[{"html_id":"github.com/watzon/subnet/Subnet/IPv4","kind":"class","full_name":"Subnet::IPv4","name":"IPv4"},{"html_id":"github.com/watzon/subnet/Subnet/IPv6","kind":"class","full_name":"Subnet::IPv6","name":"IPv6"}],"namespace":null,"doc":"TODO: Write documentation for `Subnet`","summary":"<p><span class=\"flag orange\">TODO</span>  Write documentation for <code><a href=\"Subnet.html\">Subnet</a></code></p>","class_methods":[{"id":"deprecate(message=nil)-class-method","html_id":"deprecate(message=nil)-class-method","name":"deprecate","doc":"Deprecate method\n:nodoc:","summary":"<p>Deprecate method :nodoc:</p>","abstract":false,"args":[{"name":"message","doc":null,"default_value":"nil","external_name":"message","restriction":""}],"args_string":"(message = <span class=\"n\">nil</span>)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet.cr#L225","def":{"name":"deprecate","args":[{"name":"message","doc":null,"default_value":"nil","external_name":"message","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"message || (message = \"You are using deprecated behavior which will be removed from the next major or minor release.\")\nwarn(\"DEPRECATION WARNING: #{message}\")\n"}},{"id":"ntoa(uint)-class-method","html_id":"ntoa(uint)-class-method","name":"ntoa","doc":"Converts a unit32 to IPv4\n\n```\nSubnet::ntoa(167837953)\n  # => \"10.1.1.1\"\n```","summary":"<p>Converts a unit32 to IPv4</p>","abstract":false,"args":[{"name":"uint","doc":null,"default_value":"","external_name":"uint","restriction":""}],"args_string":"(uint)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet.cr#L52","def":{"name":"ntoa","args":[{"name":"uint","doc":null,"default_value":"","external_name":"uint","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if (uint.is_a?(Number) && uint <= 4294967295_i64) && uint >= 0\nelse\n  raise(ArgumentError.new(\"not a long integer: #{uint.inspect}\"))\nend\nret = [] of UInt8 | UInt16 | UInt32 | UInt64 | Int32 | Int64 | BigInt\n4.times do\n  ret.unshift(uint & 255)\n  uint = uint >> 8\nend\nret.join('.')\n"}},{"id":"valid?(addr)-class-method","html_id":"valid?(addr)-class-method","name":"valid?","doc":"Checks if the given string is either a valid IP, either a valid IPv4 subnet\n\nExample:\n\n```\nSubnet::valid? \"10.0.0.0/24\"\n  # => true\n\nSubnet::valid? \"2002::1\"\n  # => true\n\nSubnet::valid? \"10.0.0.256\"\n  # => false\n\nSubnet::valid? \"10.0.0.0/999\"\n  # => false\n```","summary":"<p>Checks if the given string is either a valid IP, either a valid IPv4 subnet</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet.cr#L107","def":{"name":"valid?","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"((valid_ip?(addr)) || (valid_ipv4_subnet?(addr))) || (valid_ipv6_subnet?(addr))"}},{"id":"valid_ip?(addr)-class-method","html_id":"valid_ip?(addr)-class-method","name":"valid_ip?","doc":"Checks if the given string is a valid IP address,\neither IPv4 or IPv6\n\nExample:\n\n```\nSubnet::valid_ip? \"2002::1\"\n  # => true\n\nSubnet::valid_ip? \"10.0.0.256\"\n  # => false\n```","summary":"<p>Checks if the given string is a valid IP address, either IPv4 or IPv6</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet.cr#L123","def":{"name":"valid_ip?","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(valid_ipv4?(addr)) || (valid_ipv6?(addr))"}},{"id":"valid_ipv4?(addr)-class-method","html_id":"valid_ipv4?(addr)-class-method","name":"valid_ipv4?","doc":"Checks if the given string is a valid IPv4 address\n\nExample:\n\n```\nSubnet::valid_ipv4? \"2002::1\"\n  # => false\n\nSubnet::valid_ipv4? \"172.16.10.1\"\n  # => true\n```","summary":"<p>Checks if the given string is a valid IPv4 address</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet.cr#L182","def":{"name":"valid_ipv4?","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if (/\\A(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\Z/) =~ addr\n  return $~.captures.all? do |i|\n    if i.nil?\n    else\n      i.to_i < 256\n    end\n  end\nend\nfalse\n"}},{"id":"valid_ipv4_netmask?(addr)-class-method","html_id":"valid_ipv4_netmask?(addr)-class-method","name":"valid_ipv4_netmask?","doc":"Checks if the argument is a valid IPv4 netmask\nexpressed in dotted decimal format.\n\n```\nSubnet.valid_ipv4_netmask? \"255.255.0.0\"\n# => true\n```","summary":"<p>Checks if the argument is a valid IPv4 netmask expressed in dotted decimal format.</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet.cr#L196","def":{"name":"valid_ipv4_netmask?","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"begin\n  arr = (addr.split(\".\")).map do |i|\n    i.to_u8\n  end\n  bin = ((Slice.new(arr.to_unsafe, arr.size)).hexstring.to_u32(16)).to_s(2)\n  bits = bin.scan(/01/)\n  bits.empty? && (valid_ipv4?(addr))\nrescue\n  return false\nend"}},{"id":"valid_ipv4_subnet?(addr)-class-method","html_id":"valid_ipv4_subnet?(addr)-class-method","name":"valid_ipv4_subnet?","doc":"Checks if the given string is a valid IPv4 subnet\n\nExample:\n\n```\nSubnet::valid_ipv4_subnet? \"10.0.0.0/24\"\n  # => true\n\nSubnet::valid_ipv4_subnet? \"10.0.0.0/255.255.255.0\"\n  # => true\n\nSubnet::valid_ipv4_subnet? \"10.0.0.0/64\"\n  # => false\n```","summary":"<p>Checks if the given string is a valid IPv4 subnet</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet.cr#L141","def":{"name":"valid_ipv4_subnet?","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"ip, netmask = addr.split('/')\n(valid_ipv4?(ip)) && ((!(netmask =~ (/\\A([12]?\\d|3[0-2])\\z/)).nil?) || (valid_ipv4_netmask?(netmask)))\n"}},{"id":"valid_ipv6?(addr)-class-method","html_id":"valid_ipv6?(addr)-class-method","name":"valid_ipv6?","doc":"Checks if the given string is a valid IPv6 address\n\nExample:\n\n```\nSubnet::valid_ipv6? \"2002::1\"\n  # => true\n\nSubnet::valid_ipv6? \"2002::DEAD::BEEF\"\n  # => false\n```","summary":"<p>Checks if the given string is a valid IPv6 address</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet.cr#L216","def":{"name":"valid_ipv6?","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if (/^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$/) =~ addr\n  return true\nend\nfalse\n"}},{"id":"valid_ipv6_subnet?(addr)-class-method","html_id":"valid_ipv6_subnet?(addr)-class-method","name":"valid_ipv6_subnet?","doc":"Checks if the given string is a valid IPv6 subnet\n\nExample:\n\n```\nSubnet::valid_ipv6_subnet? \"::/0\"\n  # => true\n\nSubnet::valid_ipv6_subnet? \"dead:beef:cafe:babe::/64\"\n  # => true\n\nSubnet::valid_ipv6_subnet? \"2001::1/129\"\n  # => false\n```","summary":"<p>Checks if the given string is a valid IPv6 subnet</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet.cr#L161","def":{"name":"valid_ipv6_subnet?","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"begin\n  ip, netmask = addr.split('/')\n  netmask = netmask.to_i(10)\n  ((valid_ipv6?(ip)) && netmask >= 0) && netmask <= 128\nrescue ArgumentError\n  false\nend"}}],"constructors":[{"id":"new(value:JSON::PullParser):Subnet-class-method","html_id":"new(value:JSON::PullParser):Subnet-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"JSON::PullParser"}],"args_string":"(value : JSON::PullParser) : Subnet","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet.cr#L230","def":{"name":"new","args":[{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"JSON::PullParser"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Subnet","visibility":"Public","body":"Subnet.parse(value.read_string)"}},{"id":"parse(str):Subnet-class-method","html_id":"parse(str):Subnet-class-method","name":"parse","doc":"Parse the argument string to create a new\nIPv4, IPv6 or Mapped IP object\n\n```\nip = Subnet.parse 167837953 # 10.1.1.1\nip = Subnet.parse \"172.16.10.1/24\"\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\nip_mapped = Subnet.parse \"::ffff:172.16.10.1/128\"\n```\n\nAll the object created will be instances of the\ncorrect class:\n\n```\nip.class\n# => Subnet::IPv4\nip6.class\n# => Subnet::IPv6\nip_mapped.class\n# => Subnet::IPv6::Mapped\n```","summary":"<p>Parse the argument string to create a new IPv4, IPv6 or Mapped IP object</p>","abstract":false,"args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"args_string":"(str) : Subnet","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet.cr#L28","def":{"name":"parse","args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Subnet","visibility":"Public","body":"if str.is_a?(Number)\n  return Subnet::IPv4.new(ntoa(str))\nend\ncase str\nwhen /:.+\\./\n  Subnet::IPv6::Mapped.new(str)\nwhen /\\./\n  Subnet::IPv4.new(str)\nwhen /:/\n  Subnet::IPv6.new(str)\nelse\n  raise(ArgumentError.new(\"Unknown IP Address #{str}\"))\nend\n"}}],"instance_methods":[{"id":"ipv4?-instance-method","html_id":"ipv4?-instance-method","name":"ipv4?","doc":"True if the object is an IPv4 address\n\n```\nip = Subnet.parse(\"192.168.10.100/24\")\n\nip.ipv4?\n# => true\n```","summary":"<p>True if the object is an IPv4 address</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet.cr#L73","def":{"name":"ipv4?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.is_a?(Subnet::IPv4)"}},{"id":"ipv6?-instance-method","html_id":"ipv6?-instance-method","name":"ipv6?","doc":"\nTrue if the object is an IPv6 address\n\n```\nip = Subnet.parse(\"192.168.10.100/24\")\n\nip.ipv6?\n# => false\n```","summary":"<p>True if the object is an IPv6 address</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet.cr#L86","def":{"name":"ipv6?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.is_a?(Subnet::IPv6)"}},{"id":"to_json(json:JSON::Builder)-instance-method","html_id":"to_json(json:JSON::Builder)-instance-method","name":"to_json","doc":null,"summary":null,"abstract":false,"args":[{"name":"json","doc":null,"default_value":"","external_name":"json","restriction":"JSON::Builder"}],"args_string":"(json : JSON::Builder)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet.cr#L234","def":{"name":"to_json","args":[{"name":"json","doc":null,"default_value":"","external_name":"json","restriction":"JSON::Builder"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"json.string(to_string)"}}],"macros":[],"types":[{"html_id":"github.com/watzon/subnet/Subnet/IPv4","path":"Subnet/IPv4.html","kind":"class","full_name":"Subnet::IPv4","name":"IPv4","abstract":false,"superclass":{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/subnet/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/subnet/Iterator","kind":"module","full_name":"Iterator","name":"Iterator"},{"html_id":"github.com/watzon/subnet/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/subnet/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"subnet/ipv4.cr","line_number":5,"url":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr"}],"repository_name":"github.com/watzon/subnet","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[{"id":"CLASSFUL","name":"CLASSFUL","value":"{/^0../ => 8, /^10./ => 16, /^110/ => 24}","doc":"This Hash contains the prefix values for Classful networks\n\nNote: classes C, D and E will all have a default\nprefix of /24 or 255.255.255.0","summary":"<p>This Hash contains the prefix values for Classful networks</p>"},{"id":"IPV4REGEX","name":"IPV4REGEX","value":"/((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)\\.){3}(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)/","doc":"Regular expression to match an IPv4 address","summary":"<p>Regular expression to match an IPv4 address</p>"}],"included_modules":[{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/subnet/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/subnet/Iterator","kind":"module","full_name":"Iterator","name":"Iterator"},{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"}],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},"doc":"Class `Subnet::IPv4` is used to handle IPv4 type addresses.","summary":"<p>Class <code><a href=\"../Subnet/IPv4.html\">Subnet::IPv4</a></code> is used to handle IPv4 type addresses.</p>","class_methods":[{"id":"extract(str)-class-method","html_id":"extract(str)-class-method","name":"extract","doc":"Extract an IPv4 address from a string and\nreturns a new object\n\nExample:\n\n```\nstr = \"foobar172.16.10.1barbaz\"\nip = Subnet::IPv4.extract str\n\nip.to_s\n# => \"172.16.10.1\"\n```","summary":"<p>Extract an IPv4 address from a string and returns a new object</p>","abstract":false,"args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"args_string":"(str)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L989","def":{"name":"extract","args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"addr = (IPV4REGEX.match(str)).try do |__arg2|\n  __arg2[0].to_s\nend\nif addr\nelse\n  raise(\"Couldn't extract an address\")\nend\nIPv4.new(addr)\n"}},{"id":"parse_classful(ip)-class-method","html_id":"parse_classful(ip)-class-method","name":"parse_classful","doc":"Creates a new IPv4 address object by parsing the\naddress in a classful way.\n\nClassful addresses have a fixed netmask based on the\nclass they belong to:\n\n* Class A, from 0.0.0.0 to 127.255.255.255\n* Class B, from 128.0.0.0 to 191.255.255.255\n* Class C, D and E, from 192.0.0.0 to 255.255.255.254\n\nExample:\n\n```\nip = Subnet::IPv4.parse_classful \"10.0.0.1\"\n\nip.netmask\n# => \"255.0.0.0\"\nip.a?\n# => true\n```\n\nNote that classes C, D and E will all have a default\nprefix of /24 or 255.255.255.0\n","summary":"<p>Creates a new IPv4 address object by parsing the address in a classful way.</p>","abstract":false,"args":[{"name":"ip","doc":null,"default_value":"","external_name":"ip","restriction":""}],"args_string":"(ip)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L1119","def":{"name":"parse_classful","args":[{"name":"ip","doc":null,"default_value":"","external_name":"ip","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if Subnet.valid_ipv4?(ip)\nelse\n  raise(ArgumentError.new(\"Invalid IP #{ip.inspect}\"))\nend\naddress = ip.strip\nprefix = CLASSFUL.find do |h, k|\n  h === (\"%08b\" % (address.split('.')).first.to_i)\nend.try(&.last)\nnew(\"#{address}/#{prefix}\")\n"}},{"id":"parse_data(bytes,prefix=32)-class-method","html_id":"parse_data(bytes,prefix=32)-class-method","name":"parse_data","doc":"Creates a new IPv4 object from binary data,\nlike the one you get from a network stream.\n\nFor example, on a network stream the IP 172.16.0.1\nis represented with the binary `Bytes[172, 16, 10, 1]`.\n\n```\nip = Subnet::IPv4.parse_data Bytes[172, 16, 10, 1]\nip.prefix = 24\n\nip.to_string\n# => \"172.16.10.1/24\"\n```","summary":"<p>Creates a new IPv4 object from binary data, like the one you get from a network stream.</p>","abstract":false,"args":[{"name":"bytes","doc":null,"default_value":"","external_name":"bytes","restriction":""},{"name":"prefix","doc":null,"default_value":"32","external_name":"prefix","restriction":""}],"args_string":"(bytes, prefix = <span class=\"n\">32</span>)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L973","def":{"name":"parse_data","args":[{"name":"bytes","doc":null,"default_value":"","external_name":"bytes","restriction":""},{"name":"prefix","doc":null,"default_value":"32","external_name":"prefix","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"new((bytes.join('.')) + \"/#{prefix}\")"}},{"id":"parse_u32(u32,prefix=32)-class-method","html_id":"parse_u32(u32,prefix=32)-class-method","name":"parse_u32","doc":"Creates a new IPv4 object from an\nunsigned 32bits integer.\n\n```\nip = Subnet::IPv4.parse_u32(167772160)\n\nip.prefix = 8\nip.to_string\n# => \"10.0.0.0/8\"\n```\n\nThe `prefix` parameter is optional:\n\n```\nip = Subnet::IPv4.parse_u32(167772160, 8)\n\nip.to_string\n# => \"10.0.0.0/8\"\n```","summary":"<p>Creates a new IPv4 object from an unsigned 32bits integer.</p>","abstract":false,"args":[{"name":"u32","doc":null,"default_value":"","external_name":"u32","restriction":""},{"name":"prefix","doc":null,"default_value":"32","external_name":"prefix","restriction":""}],"args_string":"(u32, prefix = <span class=\"n\">32</span>)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L954","def":{"name":"parse_u32","args":[{"name":"u32","doc":null,"default_value":"","external_name":"u32","restriction":""},{"name":"prefix","doc":null,"default_value":"32","external_name":"prefix","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"octets = uninitialized ::StaticArray(UInt8, 4)\nIO::ByteFormat::BigEndian.encode(u32.to_u32, octets.to_slice)\nnew((octets.join('.')) + \"/#{prefix}\")\n"}},{"id":"summarize(args)-class-method","html_id":"summarize(args)-class-method","name":"summarize","doc":"Summarization (or aggregation) is the process when two or more\nnetworks are taken together to check if a supernet, including all\nand only these networks, exists. If it exists then this supernet\nis called the summarized (or aggregated) network.\n\nIt is very important to understand that summarization can only\noccur if there are no holes in the aggregated network, or, in other\nwords, if the given networks fill completely the address space\nof the supernet. So the two rules are:\n\n1) The aggregate network must contain +all+ the IP addresses of the\n   original networks;\n2) The aggregate network must contain +only+ the IP addresses of the\n   original networks;\n\nA few examples will help clarify the above. Let's consider for\ninstance the following two networks:\n\n```\nip1 = Subnet.parse(\"172.16.10.0/24\")\nip2 = Subnet.parse(\"172.16.11.0/24\")\n```\n\nThese two networks can be expressed using only one IP address\nnetwork if we change the prefix. Let Ruby do the work:\n\n```\nSubnet::IPv4.summarize(ip1, ip2).to_s\n# => \"172.16.10.0/23\"\n```\n\nWe note how the network \"172.16.10.0/23\" includes all the addresses\nspecified in the above networks, and (more important) includes\nONLY those addresses.\n\nIf we summarized `ip1` and `ip2` with the following network:\n\n```\n\"172.16.0.0/16\"\n```\n\nwe would have satisfied rule #1 above, but not rule #2. So \"172.16.0.0/16\"\nis not an aggregate network for `ip1` and `ip2`.\n\nIf it's not possible to compute a single aggregated network for all the\noriginal networks, the method returns an array with all the aggregate\nnetworks found. For example, the following four networks can be\naggregated in a single /22:\n\n```\nip1 = Subnet.parse(\"10.0.0.1/24\")\nip2 = Subnet.parse(\"10.0.1.1/24\")\nip3 = Subnet.parse(\"10.0.2.1/24\")\nip4 = Subnet.parse(\"10.0.3.1/24\")\n\nSubnet::IPv4.summarize(ip1, ip2, ip3, ip4).to_string\n# => [\"10.0.0.0/22\"]\n```\n\nBut the following networks can't be summarized in a single network:\n\n```\nip1 = Subnet.parse(\"10.0.1.1/24\")\nip2 = Subnet.parse(\"10.0.2.1/24\")\nip3 = Subnet.parse(\"10.0.3.1/24\")\nip4 = Subnet.parse(\"10.0.4.1/24\")\n\nSubnet::IPv4.summarize(ip1, ip2, ip3, ip4).map { |i| i.to_string }\n# => [\"10.0.1.0/24\",\"10.0.2.0/23\",\"10.0.4.0/24\"]\n```","summary":"<p>Summarization (or aggregation) is the process when two or more networks are taken together to check if a supernet, including all and only these networks, exists.</p>","abstract":false,"args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(args)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L1065","def":{"name":"summarize","args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if args.size < 1\n  raise(\"Can't summarize an empty network\")\nend\nif args.size == 1\n  return [args.first.not_nil!.network]\nend\ni = 0\nargs = args.to_a\nresult = args.dup.sort.map do |ip|\n  ip.network\nend\nwhile i < (result.size - 1)\n  sum = result[i] + result[i + 1]\n  if sum.size == 1\n    result[i..(i + 1)] = sum.first\n  end\n  i = i + 1\nend\nresult = result.flatten\nif result.size == args.size\n  return result\nelse\n  return self.summarize(result)\nend\n"}},{"id":"summarize(*args)-class-method","html_id":"summarize(*args)-class-method","name":"summarize","doc":"Summarization (or aggregation) is the process when two or more\nnetworks are taken together to check if a supernet, including all\nand only these networks, exists. If it exists then this supernet\nis called the summarized (or aggregated) network.\n\nIt is very important to understand that summarization can only\noccur if there are no holes in the aggregated network, or, in other\nwords, if the given networks fill completely the address space\nof the supernet. So the two rules are:\n\n1) The aggregate network must contain +all+ the IP addresses of the\n   original networks;\n2) The aggregate network must contain +only+ the IP addresses of the\n   original networks;\n\nA few examples will help clarify the above. Let's consider for\ninstance the following two networks:\n\n```\nip1 = Subnet.parse(\"172.16.10.0/24\")\nip2 = Subnet.parse(\"172.16.11.0/24\")\n```\n\nThese two networks can be expressed using only one IP address\nnetwork if we change the prefix. Let Ruby do the work:\n\n```\nSubnet::IPv4.summarize(ip1, ip2).to_s\n# => \"172.16.10.0/23\"\n```\n\nWe note how the network \"172.16.10.0/23\" includes all the addresses\nspecified in the above networks, and (more important) includes\nONLY those addresses.\n\nIf we summarized `ip1` and `ip2` with the following network:\n\n```\n\"172.16.0.0/16\"\n```\n\nwe would have satisfied rule #1 above, but not rule #2. So \"172.16.0.0/16\"\nis not an aggregate network for `ip1` and `ip2`.\n\nIf it's not possible to compute a single aggregated network for all the\noriginal networks, the method returns an array with all the aggregate\nnetworks found. For example, the following four networks can be\naggregated in a single /22:\n\n```\nip1 = Subnet.parse(\"10.0.0.1/24\")\nip2 = Subnet.parse(\"10.0.1.1/24\")\nip3 = Subnet.parse(\"10.0.2.1/24\")\nip4 = Subnet.parse(\"10.0.3.1/24\")\n\nSubnet::IPv4.summarize(ip1, ip2, ip3, ip4).to_string\n# => [\"10.0.0.0/22\"]\n```\n\nBut the following networks can't be summarized in a single network:\n\n```\nip1 = Subnet.parse(\"10.0.1.1/24\")\nip2 = Subnet.parse(\"10.0.2.1/24\")\nip3 = Subnet.parse(\"10.0.3.1/24\")\nip4 = Subnet.parse(\"10.0.4.1/24\")\n\nSubnet::IPv4.summarize(ip1, ip2, ip3, ip4).map { |i| i.to_string }\n# => [\"10.0.1.0/24\",\"10.0.2.0/23\",\"10.0.4.0/24\"]\n```","summary":"<p>Summarization (or aggregation) is the process when two or more networks are taken together to check if a supernet, including all and only these networks, exists.</p>","abstract":false,"args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"args_string":"(*args)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L1091","def":{"name":"summarize","args":[{"name":"args","doc":null,"default_value":"","external_name":"args","restriction":""}],"double_splat":null,"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"summarize(args)"}}],"constructors":[{"id":"new(str:String)-class-method","html_id":"new(str:String)-class-method","name":"new","doc":"Creates a new IPv4 address object.\n\nAn IPv4 address can be expressed in any of the following forms:\n\n* \"10.1.1.1/24\": ip `address` and `prefix`. This is the common and\nsuggested way to create an object.\n\n* \"10.1.1.1/255.255.255.0\": ip `address` and `netmask`. Although\nconvenient sometimes, this format is less clear than the previous\none.\n\n* \"10.1.1.1\": if the address alone is specified, the prefix will be\nset as default 32, also known as the host prefix\n\nExamples:\n\n```crystal\n# These two are the same\nip = Subnet::IPv4.new(\"10.0.0.1/24\")\nip = Subnet.parse(\"10.0.0.1/24\")\n\n# These two are the same\nSubnet::IPv4.new \"10.0.0.1/8\"\nSubnet::IPv4.new \"10.0.0.1/255.0.0.0\"\n```","summary":"<p>Creates a new IPv4 address object.</p>","abstract":false,"args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":"String"}],"args_string":"(str : String)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L101","def":{"name":"new","args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":"String"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(str)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}},{"id":"new(value:JSON::PullParser):Subnet::IPv4-class-method","html_id":"new(value:JSON::PullParser):Subnet::IPv4-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"JSON::PullParser"}],"args_string":"(value : JSON::PullParser) : Subnet::IPv4","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L1183","def":{"name":"new","args":[{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"JSON::PullParser"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Subnet::IPv4","visibility":"Public","body":"Subnet.parse(value.read_string)"}}],"instance_methods":[{"id":"+(oth)-instance-method","html_id":"+(oth)-instance-method","name":"+","doc":"Returns a new IPv4 object which is the result\nof the summarization, if possible, of the two\nobjects\n\nExample:\n\n```\nip1 = Subnet.parse(\"172.16.10.1/24\")\nip2 = Subnet.parse(\"172.16.11.2/24\")\n\np (ip1 + ip2).map { |i| i.to_string }\n# => [\"172.16.10.0/23\"]\n```\n\nIf the networks are not contiguous, returns\nthe two network numbers from the objects\n\n```\nip1 = Subnet.parse(\"10.0.0.1/24\")\nip2 = Subnet.parse(\"10.0.2.1/24\")\n\np (ip1 + ip2).map { |i| i.to_string }\n# => [\"10.0.0.0/24\",\"10.0.2.0/24\"]\n```","summary":"<p>Returns a new IPv4 object which is the result of the summarization, if possible, of the two objects</p>","abstract":false,"args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"args_string":"(oth)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L866","def":{"name":"+","args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"tup = [self, oth].sort.map do |i|\n  i.network\nend\naggregate(tup[0], tup[1])\n"}},{"id":"-(oth)-instance-method","html_id":"-(oth)-instance-method","name":"-","doc":"Returns the difference between two IP addresses\nin unsigned int 32 bits format\n\nExample:\n\n```\nip1 = Subnet.parse(\"172.16.10.0/24\")\nip2 = Subnet.parse(\"172.16.11.0/24\")\n\nputs ip1 - ip2\n# => 256\n```","summary":"<p>Returns the difference between two IP addresses in unsigned int 32 bits format</p>","abstract":false,"args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"args_string":"(oth)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L838","def":{"name":"-","args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"return (to_u32 - oth.to_u32).abs"}},{"id":"/(subnets)-instance-method","html_id":"/(subnets)-instance-method","name":"/","doc":"Splits a network into different subnets\n\nIf the IP Address is a network, it can be divided into\nmultiple networks. If `self` is not a network, this\nmethod will calculate the network from the IP and then\nsubnet it.\n\nIf `subnets` is an power of two number, the resulting\nnetworks will be divided evenly from the supernet.\n\n```\nnetwork = Subnet.parse(\"172.16.10.0/24\")\n\nnetwork / 4 # implies map{|i| i.to_string}\n# => [\"172.16.10.0/26\",\n# => \"172.16.10.64/26\",\n# => \"172.16.10.128/26\",\n# => \"172.16.10.192/26\"]\n```\n\nIf `num` is any other number, the supernet will be\ndivided into some networks with a even number of hosts and\nother networks with the remaining addresses.\n\n```\nnetwork = Subnet.parse(\"172.16.10.0/24\")\n\nnetwork / 3 # implies map{|i| i.to_string}\n# => [\"172.16.10.0/26\",\n# => \"172.16.10.64/26\",\n# => \"172.16.10.128/25\"]\n```\n\nReturns an array of IPv4 objects","summary":"<p>Splits a network into different subnets</p>","abstract":false,"args":[{"name":"subnets","doc":null,"default_value":"","external_name":"subnets","restriction":""}],"args_string":"(subnets)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L753","def":{"name":"/","args":[{"name":"subnets","doc":null,"default_value":"","external_name":"subnets","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"split(subnets)"}},{"id":"(oth)-instance-method","html_id":"(oth)-instance-method","name":"<=>","doc":"Spaceship operator to compare IPv4 objects\n\nComparing IPv4 addresses is useful to ordinate\nthem into lists that match our intuitive\nperception of ordered IP addresses.\n\nThe first comparison criteria is the u32 value.\nFor example, 10.100.100.1 will be considered\nto be less than 172.16.0.1, because, in a ordered list,\nwe expect 10.100.100.1 to come before 172.16.0.1.\n\nThe second criteria, in case two IPv4 objects\nhave identical addresses, is the prefix. An higher\nprefix will be considered greater than a lower\nprefix. This is because we expect to see\n10.100.100.0/24 come before 10.100.100.0/25.\n\nExample:\n\n```crystal\nip1 = Subnet.parse \"10.100.100.1/8\"\nip2 = Subnet.parse \"172.16.0.1/16\"\nip3 = Subnet.parse \"10.100.100.1/16\"\n\nip1 < ip2\n# => true\nip1 > ip3\n# => false\n\n[ip1, ip2, ip3].sort.map { |i| i.to_s }\n# => [\"10.100.100.1/8\",\"10.100.100.1/16\",\"172.16.0.1/16\"]\n```","summary":"<p>Spaceship operator to compare IPv4 objects</p>","abstract":false,"args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"args_string":"(oth)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L509","def":{"name":"<=>","args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if to_i == oth.to_i\n  return prefix <=> oth.prefix\nend\nto_i <=> oth.to_i\n"}},{"id":"[](index)-instance-method","html_id":"[](index)-instance-method","name":"[]","doc":"Returns the octet specified by index\n\n```crystal\nip = Subnet.parse(\"172.16.100.50/24\")\n\nip[0]\n# => 172\nip[1]\n# => 16\nip[2]\n# => 100\nip[3]\n# => 50\n```","summary":"<p>Returns the octet specified by index</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"args_string":"(index)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L241","def":{"name":"[]","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@octets[index]"}},{"id":"[]=(index,value)-instance-method","html_id":"[]=(index,value)-instance-method","name":"[]=","doc":"Updated the octet specified at index\n\n```crystal\nip = Subnet.parse(\"172.16.100.50/24\")\nip[2] = 200\n\n# => #<Subnet::IPv4:0x00000000000000 @address=\"172.16.200.1\",\n# => @prefix=32, @octets=[172, 16, 200, 1], @u32=2886780929>\n```","summary":"<p>Updated the octet specified at index</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":""}],"args_string":"(index, value)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L259","def":{"name":"[]=","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@octets[index] = value.to_i\ninitialize(\"#{@octets.join('.')}/#{prefix}\")\n"}},{"id":"a?-instance-method","html_id":"a?-instance-method","name":"a?","doc":"Checks whether the ip address belongs to a\nRFC 791 CLASS A network, no matter\nwhat the subnet mask is.\n\nExample:\n\n```\nip = Subnet.parse(\"10.0.0.1/24\")\n\nip.a?\n# => true\n```","summary":"<p>Checks whether the ip address belongs to a RFC 791 CLASS A network, no matter what the subnet mask is.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L883","def":{"name":"a?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(CLASSFUL.key_for(8)) === bits"}},{"id":"address:String-instance-method","html_id":"address:String-instance-method","name":"address","doc":"Returns the address portion of the IPv4 object\nas a string.\n\n```crystal\nip = Subnet.parse(\"172.16.100.4/22\")\n\nip.address\n# => \"172.16.100.4\"\n```","summary":"<p>Returns the address portion of the IPv4 object as a string.</p>","abstract":false,"args":[],"args_string":" : String","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L35","def":{"name":"address","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"String","visibility":"Public","body":"@address"}},{"id":"allocate(skip=0)-instance-method","html_id":"allocate(skip=0)-instance-method","name":"allocate","doc":"Allocates a new ip from the current subnet. Optional skip parameter\ncan be used to skip addresses.\n\nWill return `nil` exception when all addresses have been allocated\n\nExample:\n\n```\nip = Subnet.parse(\"10.0.0.0/24\")\nip.allocate\n# => \"10.0.0.1/24\"\nip.allocate\n# => \"10.0.0.2/24\"\nip.allocate(2)\n# => \"10.0.0.5/24\"\n```\n\nUses an internal @allocator which tracks the state of allocated\naddresses.\n","summary":"<p>Allocates a new ip from the current subnet.</p>","abstract":false,"args":[{"name":"skip","doc":null,"default_value":"0","external_name":"skip","restriction":""}],"args_string":"(skip = <span class=\"n\">0</span>)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L1146","def":{"name":"allocate","args":[{"name":"skip","doc":null,"default_value":"0","external_name":"skip","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@allocator = @allocator + (1 + skip)\nnext_ip = network_u32 + @allocator\nif next_ip > (broadcast_u32 + 1)\n  return nil\nend\nIPv4.parse_u32(next_ip, @prefix)\n"}},{"id":"arpa-instance-method","html_id":"arpa-instance-method","name":"arpa","doc":"Returns the IP address in in-addr.arpa format\nfor DNS lookups\n\n```\nip = Subnet.parse(\"172.16.100.50/24\")\n\nip.reverse\n# => \"50.100.16.172.in-addr.arpa\"\n```","summary":"<p>Returns the IP address in in-addr.arpa format for DNS lookups</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L682","def":{"name":"arpa","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"reverse"}},{"id":"b?-instance-method","html_id":"b?-instance-method","name":"b?","doc":"Checks whether the ip address belongs to a\nRFC 791 CLASS B network, no matter\nwhat the subnet mask is.\n\nExample:\n\n```\nip = Subnet.parse(\"172.16.10.1/24\")\n\nip.b?\n# => true\n```","summary":"<p>Checks whether the ip address belongs to a RFC 791 CLASS B network, no matter what the subnet mask is.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L899","def":{"name":"b?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(CLASSFUL.key_for(16)) === bits"}},{"id":"bits-instance-method","html_id":"bits-instance-method","name":"bits","doc":"Returns the address portion of an IP in binary format,\nas a string containing a sequence of 0 and 1\n\n```crystal\nip = Subnet.parse(\"127.0.0.1\")\n\nip.bits\n# => \"01111111000000000000000000000001\"\n```","summary":"<p>Returns the address portion of an IP in binary format, as a string containing a sequence of 0 and 1</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L273","def":{"name":"bits","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"\"%032.32b\" % (hexstring.to_i64(16))"}},{"id":"broadcast-instance-method","html_id":"broadcast-instance-method","name":"broadcast","doc":"Returns the broadcast address for the given IP.\n\n```crystal\nip = Subnet.parse(\"172.16.10.64/24\")\n\nip.broadcast.to_s\n# => \"172.16.10.255\"\n```","summary":"<p>Returns the broadcast address for the given IP.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L285","def":{"name":"broadcast","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"case\nwhen prefix <= 30\n  IPv4.parse_u32(broadcast_u32, @prefix)\nwhen prefix == 31\n  IPv4.parse_u32(-1, @prefix)\nelse\n  return self\nend"}},{"id":"broadcast_u32-instance-method","html_id":"broadcast_u32-instance-method","name":"broadcast_u32","doc":"Returns the broadcast address in Unsigned 32bits format\n\n```\nip = Subnet.parse(\"10.0.0.1/29\")\n\nip.broadcast_u32\n# => 167772167\n```","summary":"<p>Returns the broadcast address in Unsigned 32bits format</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L566","def":{"name":"broadcast_u32","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(network_u32 + size) - 1"}},{"id":"c?-instance-method","html_id":"c?-instance-method","name":"c?","doc":"Checks whether the ip address belongs to a\nRFC 791 CLASS C network, no matter\nwhat the subnet mask is.\n\nExample:\n\n```\nip = Subnet.parse(\"192.168.1.1/30\")\n\nip.c?\n# => true\n```","summary":"<p>Checks whether the ip address belongs to a RFC 791 CLASS C network, no matter what the subnet mask is.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L915","def":{"name":"c?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(CLASSFUL.key_for(24)) === bits"}},{"id":"data-instance-method","html_id":"data-instance-method","name":"data","doc":"Returns the address portion of an IPv4 object\nin a network byte order format.\n\n```crystal\nip = Subnet.parse(\"172.16.10.1/24\")\n\nip.data\n# => \"\\254\\020\\n\" + \"\\001\"\n```\n\nIt is usually used to include an IP address\nin a data packet to be sent over a socket.","summary":"<p>Returns the address portion of an IPv4 object in a network byte order format.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L223","def":{"name":"data","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"String.new(hexstring.hexbytes)"}},{"id":"each(&block)-instance-method","html_id":"each(&amp;block)-instance-method","name":"each","doc":"Iterates over all the IP addresses for the given\nnetwork (or IP address).\n\nThe object yielded is a new IPv4 object created\nfrom the iteration.\n\n```crystal\nip = Subnet.parse(\"10.0.0.1/29\")\n\nip.each do |i|\n  p i.address\nend\n# => \"10.0.0.0\"\n# => \"10.0.0.1\"\n# => \"10.0.0.2\"\n# => \"10.0.0.3\"\n# => \"10.0.0.4\"\n# => \"10.0.0.5\"\n# => \"10.0.0.6\"\n# => \"10.0.0.7\"\n```","summary":"<p>Iterates over all the IP addresses for the given network (or IP address).</p>","abstract":false,"args":[],"args_string":"(&block)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L434","def":{"name":"each","args":[],"double_splat":null,"splat_index":null,"yields":1,"block_arg":null,"return_type":"","visibility":"Public","body":"(network_u32..broadcast_u32).each do |i|\n  yield self.class.parse_u32(i, @prefix)\nend"}},{"id":"each_host(&block)-instance-method","html_id":"each_host(&amp;block)-instance-method","name":"each_host","doc":"Iterates over all the hosts IP addresses for the given\nnetwork (or IP address).\n\n```crystal\nip = Subnet.parse(\"10.0.0.1/29\")\n\nip.each_host do |i|\n  p i.to_s\nend\n# => \"10.0.0.1\"\n# => \"10.0.0.2\"\n# => \"10.0.0.3\"\n# => \"10.0.0.4\"\n# => \"10.0.0.5\"\n# => \"10.0.0.6\"\n```","summary":"<p>Iterates over all the hosts IP addresses for the given network (or IP address).</p>","abstract":false,"args":[],"args_string":"(&block)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L407","def":{"name":"each_host","args":[],"double_splat":null,"splat_index":null,"yields":1,"block_arg":null,"return_type":"","visibility":"Public","body":"((network_u32 + 1)..(broadcast_u32 - 1)).each do |i|\n  yield self.class.parse_u32(i, @prefix)\nend"}},{"id":"first-instance-method","html_id":"first-instance-method","name":"first","doc":"Returns a new IPv4 object with the\nfirst host IP address in the range.\n\nExample: given the 192.168.100.0/24 network, the first\nhost IP address is 192.168.100.1.\n\n```crystal\nip = Subnet.parse(\"192.168.100.0/24\")\n\nip.first.to_s\n# => \"192.168.100.1\"\n```\n\nThe object IP doesn't need to be a network: the method\nautomatically gets the network number from it\n\n```crystal\nip = Subnet.parse(\"192.168.100.50/24\")\n\nip.first.to_s\n# => \"192.168.100.1\"\n```","summary":"<p>Returns a new IPv4 object with the first host IP address in the range.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L348","def":{"name":"first","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"case\nwhen prefix <= 30\n  IPv4.parse_u32(network_u32 + 1, @prefix)\nwhen prefix == 31\n  IPv4.parse_u32(network_u32, @prefix)\nwhen prefix == 32\n  return self\nend"}},{"id":"hexstring-instance-method","html_id":"hexstring-instance-method","name":"hexstring","doc":"Returns the address portion in\nhex\n\n```crystal\nip = Subnet.parse(\"10.0.0.0\")\n\nip.hexstring\n# => \"0a000000\"\n```","summary":"<p>Returns the address portion in hex</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L207","def":{"name":"hexstring","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"\"%08x\" % to_u32"}},{"id":"hosts-instance-method","html_id":"hosts-instance-method","name":"hosts","doc":"Returns an array with the IP addresses of\nall the hosts in the network.\n\n```\nip = Subnet.parse(\"10.0.0.1/29\")\n\nip.hosts.map { |i| i.address }\n# => [\"10.0.0.1\",\n# => \"10.0.0.2\",\n# => \"10.0.0.3\",\n# => \"10.0.0.4\",\n# => \"10.0.0.5\",\n# => \"10.0.0.6\"]\n```","summary":"<p>Returns an array with the IP addresses of all the hosts in the network.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L542","def":{"name":"hosts","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"to_a[1..-2]"}},{"id":"includes?(oth:IPv4)-instance-method","html_id":"includes?(oth:IPv4)-instance-method","name":"includes?","doc":"Checks whether a subnet includes the given IP address.\n\nAccepts an Subnet.parse::IPv4 object.\n\n```\nip = Subnet.parse(\"192.168.10.100/24\")\n\naddr = Subnet.parse(\"192.168.10.102/24\")\n\nip.includes? addr\n# => true\n\nip.includes? Subnet.parse(\"172.16.0.48/16\")\n# => false\n```","summary":"<p>Checks whether a subnet includes the given IP address.</p>","abstract":false,"args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":"IPv4"}],"args_string":"(oth : IPv4)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L585","def":{"name":"includes?","args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":"IPv4"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix <= oth.prefix && (network_u32 == (oth.to_u32 & @prefix.to_u32))"}},{"id":"includes_all?(*others)-instance-method","html_id":"includes_all?(*others)-instance-method","name":"includes_all?","doc":"Checks whether a subnet includes all the\ngiven IPv4 objects.\n\n```\nip = Subnet.parse(\"192.168.10.100/24\")\n\naddr1 = Subnet.parse(\"192.168.10.102/24\")\naddr2 = Subnet.parse(\"192.168.10.103/24\")\n\nip.includes_all?(addr1, addr2)\n# => true\n```","summary":"<p>Checks whether a subnet includes all the given IPv4 objects.</p>","abstract":false,"args":[{"name":"others","doc":null,"default_value":"","external_name":"others","restriction":""}],"args_string":"(*others)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L606","def":{"name":"includes_all?","args":[{"name":"others","doc":null,"default_value":"","external_name":"others","restriction":""}],"double_splat":null,"splat_index":0,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"includes_all?(others)"}},{"id":"includes_all?(others)-instance-method","html_id":"includes_all?(others)-instance-method","name":"includes_all?","doc":"Checks whether a subnet includes all the\ngiven IPv4 objects.\n\n```\nip = Subnet.parse(\"192.168.10.100/24\")\n\naddr1 = Subnet.parse(\"192.168.10.102/24\")\naddr2 = Subnet.parse(\"192.168.10.103/24\")\n\nip.includes_all?(addr1, addr2)\n# => true\n```","summary":"<p>Checks whether a subnet includes all the given IPv4 objects.</p>","abstract":false,"args":[{"name":"others","doc":null,"default_value":"","external_name":"others","restriction":""}],"args_string":"(others)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L601","def":{"name":"includes_all?","args":[{"name":"others","doc":null,"default_value":"","external_name":"others","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"others.all? do |oth|\n  includes?(oth)\nend"}},{"id":"last-instance-method","html_id":"last-instance-method","name":"last","doc":"Like its sibling method IPv4#first, this method\nreturns a new IPv4 object with the\nlast host IP address in the range.\n\nExample: given the 192.168.100.0/24 network, the last\nhost IP address is 192.168.100.254\n\n```crystal\nip = Subnet.parse(\"192.168.100.0/24\")\n\nip.last.to_s\n# => \"192.168.100.254\"\n```\n\nThe object IP doesn't need to be a network: the method\nautomatically gets the network number from it\n\n  ip = Subnet.parse(\"192.168.100.50/24\")\n\n  ip.last.to_s\n    #=> \"192.168.100.254\"","summary":"<p>Like its sibling method IPv4#first, this method returns a new IPv4 object with the last host IP address in the range.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L380","def":{"name":"last","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"case\nwhen prefix <= 30\n  self.class.parse_u32(broadcast_u32 - 1, @prefix)\nwhen prefix == 31\n  self.class.parse_u32(broadcast_u32, @prefix)\nwhen prefix == 32\n  return self\nend"}},{"id":"link_local?-instance-method","html_id":"link_local?-instance-method","name":"link_local?","doc":"Checks if an IPv4 address objects belongs\nto a link-local network RFC3927\n\nExample:\n\n```\nip = Subnet \"169.254.0.1\"\nip.link_local?\n  #=> true\n```","summary":"<p>Checks if an IPv4 address objects belongs to a link-local network RFC3927</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L664","def":{"name":"link_local?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"[self.class.new(\"169.254.0.0/16\")].any? do |i|\n  i.includes?(self)\nend"}},{"id":"loopback?-instance-method","html_id":"loopback?-instance-method","name":"loopback?","doc":"Checks if an IPv4 address objects belongs\nto a loopback network RFC1122\n\nExample:\n\n```\nip = Subnet.parse \"127.0.0.1\"\nip.loopback?\n# => true\n```","summary":"<p>Checks if an IPv4 address objects belongs to a loopback network RFC1122</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L650","def":{"name":"loopback?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"[self.class.new(\"127.0.0.0/8\")].any? do |i|\n  i.includes?(self)\nend"}},{"id":"multicast?-instance-method","html_id":"multicast?-instance-method","name":"multicast?","doc":"Checks if an IPv4 address objects belongs\nto a multicast network RFC3171\n\nExample:\n\n```\nip = Subnet.parse \"224.0.0.0/4\"\nip.multicast?\n# => true\n```","summary":"<p>Checks if an IPv4 address objects belongs to a multicast network RFC3171</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L636","def":{"name":"multicast?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"[self.class.new(\"224.0.0.0/4\")].any? do |i|\n  i.includes?(self)\nend"}},{"id":"netmask-instance-method","html_id":"netmask-instance-method","name":"netmask","doc":"Returns the prefix as a string in IP format\n\n```crystal\nip = Subnet.parse(\"172.16.100.4/22\")\n\nip.netmask\n# => \"255.255.252.0\"\n```","summary":"<p>Returns the prefix as a string in IP format</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L165","def":{"name":"netmask","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix.to_ip"}},{"id":"netmask=(addr)-instance-method","html_id":"netmask=(addr)-instance-method","name":"netmask=","doc":"Like `IPv4#prefix=`, this method allow you to\nchange the prefix / netmask of an IP address\nobject.\n\n```crystal\nip = Subnet.parse(\"172.16.100.4\")\n\nputs ip\n# => 172.16.100.4/16\n\nip.netmask = \"255.255.252.0\"\n\nputs ip\n# => 172.16.100.4/22\n```","summary":"<p>Like <code><a href=\"../Subnet/IPv4.html#prefix%3D%28num%29-instance-method\">IPv4#prefix=</a></code>, this method allow you to change the prefix / netmask of an IP address object.</p>","abstract":false,"args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"args_string":"(addr)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L184","def":{"name":"netmask=","args":[{"name":"addr","doc":null,"default_value":"","external_name":"addr","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix = Prefix32.parse_netmask(addr)"}},{"id":"network-instance-method","html_id":"network-instance-method","name":"network","doc":"Returns a new IPv4 object with the network number\nfor the given IP.\n\n```crystal\nip = Subnet.parse(\"172.16.10.64/24\")\n\nip.network.to_s\n# => \"172.16.10.0\"\n```","summary":"<p>Returns a new IPv4 object with the network number for the given IP.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L322","def":{"name":"network","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"IPv4.parse_u32(network_u32, @prefix)"}},{"id":"network?-instance-method","html_id":"network?-instance-method","name":"network?","doc":"Checks if the IP address is actually a network\n\n```crystal\nip = Subnet.parse(\"172.16.10.64/24\")\n\nip.network?\n# => false\n\nip = Subnet.parse(\"172.16.10.64/26\")\n\nip.network?\n# => true\n```","summary":"<p>Checks if the IP address is actually a network</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L309","def":{"name":"network?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(@prefix < 32) && ((@u32 | @prefix.to_u32) == @prefix.to_u32)"}},{"id":"network_u32-instance-method","html_id":"network_u32-instance-method","name":"network_u32","doc":"Returns the network number in Unsigned 32bits format\n\n```\nip = Subnet.parse(\"10.0.0.1/29\")\n\nip.network_u32\n# => 167772160\n```","summary":"<p>Returns the network number in Unsigned 32bits format</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L554","def":{"name":"network_u32","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@u32 & @prefix.to_u32"}},{"id":"next-instance-method","html_id":"next-instance-method","name":"next","doc":"Returns the next IP address in the network, or\n`Iterator::Stop::INSTANCE` when out of\naddresses.","summary":"<p>Returns the next IP address in the network, or <code>Iterator::Stop::INSTANCE</code> when out of addresses.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L457","def":{"name":"next","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"next_i = to_i.succ\nif next_i >= 4294967295_i64\n  return Iterator::Stop::INSTANCE\nend\nself.class.parse_u32(next_i, prefix)\n"}},{"id":"octet(index)-instance-method","html_id":"octet(index)-instance-method","name":"octet","doc":"Returns the octet specified by index\n\n```crystal\nip = Subnet.parse(\"172.16.100.50/24\")\n\nip[0]\n# => 172\nip[1]\n# => 16\nip[2]\n# => 100\nip[3]\n# => 50\n```","summary":"<p>Returns the octet specified by index</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"args_string":"(index)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L246","def":{"name":"octet","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self[index]"}},{"id":"octets:Array(Int32)-instance-method","html_id":"octets:Array(Int32)-instance-method","name":"octets","doc":"Returns the address as an array of decimal values\n\n```crystal\nip = Subnet.parse(\"172.16.100.4\")\n\nip.octets\n# => [172, 16, 100, 4]\n```","summary":"<p>Returns the address as an array of decimal values</p>","abstract":false,"args":[],"args_string":" : Array(Int32)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L59","def":{"name":"octets","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Array(Int32)","visibility":"Public","body":"@octets"}},{"id":"pred-instance-method","html_id":"pred-instance-method","name":"pred","doc":"Returns the predecessor to the IP address\n\nExample:\n\n```\nip = Subnet.parse(\"192.168.45.23/16\")\n\nip.pred.to_string\n=> \"192.168.45.22/16\"\n```","summary":"<p>Returns the predecessor to the IP address</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L473","def":{"name":"pred","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.class.parse_u32(to_i.pred, prefix)"}},{"id":"prefix:Prefix32-instance-method","html_id":"prefix:Prefix32-instance-method","name":"prefix","doc":"Returns the prefix portion of the IPv4 object\nas a Subnet::Prefix32 object\n\n```crystal\nip = Subnet.parse(\"172.16.100.4/22\")\n\nip.prefix\n# => 22\n\nip.prefix.class\n# => Subnet::Prefix32\n```","summary":"<p>Returns the prefix portion of the IPv4 object as a Subnet::Prefix32 object</p>","abstract":false,"args":[],"args_string":" : Prefix32","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L49","def":{"name":"prefix","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Prefix32","visibility":"Public","body":"@prefix"}},{"id":"prefix=(num)-instance-method","html_id":"prefix=(num)-instance-method","name":"prefix=","doc":"Set a new prefix number for the object\n\nThis is useful if you want to change the prefix\nto an object created with IPv4.parse_u32 or\nif the object was created using the classful\nmask.\n\n```crystal\nip = Subnet.parse(\"172.16.100.4\")\n\nputs ip\n# => 172.16.100.4/16\n\nip.prefix = 22\n\nputs ip\n# => 172.16.100.4/22\n```","summary":"<p>Set a new prefix number for the object</p>","abstract":false,"args":[{"name":"num","doc":null,"default_value":"","external_name":"num","restriction":""}],"args_string":"(num)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L153","def":{"name":"prefix=","args":[{"name":"num","doc":null,"default_value":"","external_name":"num","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix = Prefix32.new(num)"}},{"id":"private?-instance-method","html_id":"private?-instance-method","name":"private?","doc":"Checks if an IPv4 address objects belongs\nto a private network RFC1918\n\nExample:\n\n```\nip = Subnet.parse \"10.1.1.1/24\"\nip.private?\n# => true\n```","summary":"<p>Checks if an IPv4 address objects belongs to a private network RFC1918</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L620","def":{"name":"private?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"[self.class.new(\"10.0.0.0/8\"), self.class.new(\"172.16.0.0/12\"), self.class.new(\"192.168.0.0/16\")].any? do |i|\n  i.includes?(self)\nend"}},{"id":"reverse-instance-method","html_id":"reverse-instance-method","name":"reverse","doc":"Returns the IP address in in-addr.arpa format\nfor DNS lookups\n\n```\nip = Subnet.parse(\"172.16.100.50/24\")\n\nip.reverse\n# => \"50.100.16.172.in-addr.arpa\"\n```","summary":"<p>Returns the IP address in in-addr.arpa format for DNS lookups</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L677","def":{"name":"reverse","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(@octets.reverse.join(\".\")) + \".in-addr.arpa\""}},{"id":"size-instance-method","html_id":"size-instance-method","name":"size","doc":"Returns the number of IP addresses included\nin the network. It also counts the network\naddress and the broadcast address.\n\n```\nip = Subnet.parse(\"10.0.0.1/29\")\n\nip.size\n# => 8\n```","summary":"<p>Returns the number of IP addresses included in the network.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L524","def":{"name":"size","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"2 ** @prefix.host_prefix"}},{"id":"split(subnets=2)-instance-method","html_id":"split(subnets=2)-instance-method","name":"split","doc":"Splits a network into different subnets\n\nIf the IP Address is a network, it can be divided into\nmultiple networks. If `self` is not a network, this\nmethod will calculate the network from the IP and then\nsubnet it.\n\nIf `subnets` is an power of two number, the resulting\nnetworks will be divided evenly from the supernet.\n\n```\nnetwork = Subnet.parse(\"172.16.10.0/24\")\n\nnetwork / 4 # implies map{|i| i.to_string}\n# => [\"172.16.10.0/26\",\n# => \"172.16.10.64/26\",\n# => \"172.16.10.128/26\",\n# => \"172.16.10.192/26\"]\n```\n\nIf `num` is any other number, the supernet will be\ndivided into some networks with a even number of hosts and\nother networks with the remaining addresses.\n\n```\nnetwork = Subnet.parse(\"172.16.10.0/24\")\n\nnetwork / 3 # implies map{|i| i.to_string}\n# => [\"172.16.10.0/26\",\n# => \"172.16.10.64/26\",\n# => \"172.16.10.128/25\"]\n```\n\nReturns an array of IPv4 objects","summary":"<p>Splits a network into different subnets</p>","abstract":false,"args":[{"name":"subnets","doc":null,"default_value":"2","external_name":"subnets","restriction":""}],"args_string":"(subnets = <span class=\"n\">2</span>)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L741","def":{"name":"split","args":[{"name":"subnets","doc":null,"default_value":"2","external_name":"subnets","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if (1..(2 ** @prefix.host_prefix)).includes?(subnets)\nelse\n  raise(ArgumentError.new(\"Value #{subnets} out of range\"))\nend\nnetworks = subnet(newprefix(subnets))\nwhile !(networks.size == subnets)\n  networks = sum_first_found(networks)\nend\nreturn networks\n"}},{"id":"subnet(subprefix)-instance-method","html_id":"subnet(subprefix)-instance-method","name":"subnet","doc":"This method implements the subnetting function\nsimilar to the one described in RFC3531.\n\nBy specifying a new prefix, the method calculates\nthe network number for the given IPv4 object\nand calculates the subnets associated to the new\nprefix.\n\nFor example, given the following network:\n\n```\nip = Subnet.parse \"172.16.10.0/24\"\n```\n\nwe can calculate the subnets with a /26 prefix\n\n```\nip.subnet(26).map{&:to_string)\n  #=> [\"172.16.10.0/26\", \"172.16.10.64/26\", \"172.16.10.128/26\", \"172.16.10.192/26\"]\n```\n\nThe resulting number of subnets will of course always be\na power of two.","summary":"<p>This method implements the subnetting function similar to the one described in RFC3531.</p>","abstract":false,"args":[{"name":"subprefix","doc":null,"default_value":"","external_name":"subprefix","restriction":""}],"args_string":"(subprefix)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L814","def":{"name":"subnet","args":[{"name":"subprefix","doc":null,"default_value":"","external_name":"subprefix","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"subprefix = subprefix.to_i\nif ((@prefix.to_i)..32).includes?(subprefix)\nelse\n  raise(ArgumentError.new(\"New prefix must be between #@prefix and 32\"))\nend\nArray(IPv4).new(2 ** (subprefix - @prefix.to_i)) do |i|\n  self.class.parse_u32(network_u32 + (i * (2 ** (32 - subprefix))), subprefix)\nend\n"}},{"id":"succ-instance-method","html_id":"succ-instance-method","name":"succ","doc":"Returns the successor to the IP address\n\nExample:\n\n```\nip = Subnet.parse(\"192.168.45.23/16\")\n\nip.succ.to_string\n=> \"192.168.45.24/16\"\n```","summary":"<p>Returns the successor to the IP address</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L450","def":{"name":"succ","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.class.parse_u32(to_i.succ, prefix)"}},{"id":"supernet(new_prefix)-instance-method","html_id":"supernet(new_prefix)-instance-method","name":"supernet","doc":"Returns a new IPv4 object from the supernetting\nof the instance network.\n\nSupernetting is similar to subnetting, except\nthat you getting as a result a network with a\nsmaller prefix (bigger host space). For example,\ngiven the network\n\n```\nip = Subnet.parse(\"172.16.10.0/24\")\n```\n\nyou can supernet it with a new /23 prefix\n\n```\nip.supernet(23).to_string\n# => \"172.16.10.0/23\"\n```\n\nHowever if you supernet it with a /22 prefix, the\nnetwork address will change:\n\n```\nip.supernet(22).to_string\n# => \"172.16.8.0/22\"\n```\n\nIf `new_prefix` is less than 1, returns 0.0.0.0/0","summary":"<p>Returns a new IPv4 object from the supernetting of the instance network.</p>","abstract":false,"args":[{"name":"new_prefix","doc":null,"default_value":"","external_name":"new_prefix","restriction":""}],"args_string":"(new_prefix)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L785","def":{"name":"supernet","args":[{"name":"new_prefix","doc":null,"default_value":"","external_name":"new_prefix","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if new_prefix >= @prefix.to_i\n  raise(ArgumentError.new(\"New prefix must be smaller than existing prefix\"))\nend\nif new_prefix < 1\n  return self.class.new(\"0.0.0.0/0\")\nend\nreturn (self.class.new(@address + \"/#{new_prefix}\")).network\n"}},{"id":"to(e)-instance-method","html_id":"to(e)-instance-method","name":"to","doc":"Return a list of IP's between @address\nand the supplied IP\n\n```\nip = Subnet..parse(\"172.16.100.51/32\")\n\nip.to(\"172.16.100.100\")\n# => [\"172.16.100.51\",\n# => \"172.16.100.52\",\n# => ...\n# => \"172.16.100.99\",\n# => \"172.16.100.100\"]\n```","summary":"<p>Return a list of IP's between @address and the supplied IP</p>","abstract":false,"args":[{"name":"e","doc":null,"default_value":"","external_name":"e","restriction":""}],"args_string":"(e)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L699","def":{"name":"to","args":[{"name":"e","doc":null,"default_value":"","external_name":"e","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if e.is_a?(Subnet::IPv4)\nelse\n  e = self.class.new(e)\nend\n(Range.new(@u32, e.to_u32)).map do |i|\n  Subnet.ntoa(i)\nend\n"}},{"id":"to_i-instance-method","html_id":"to_i-instance-method","name":"to_i","doc":"Like `IPv4#prefix=`, this method allow you to\nchange the prefix / netmask of an IP address\nobject.\n\n```crystal\nip = Subnet.parse(\"172.16.100.4\")\n\nputs ip\n# => 172.16.100.4/16\n\nip.netmask = \"255.255.252.0\"\n\nputs ip\n# => 172.16.100.4/22\n```","summary":"<p>Like <code><a href=\"../Subnet/IPv4.html#prefix%3D%28num%29-instance-method\">IPv4#prefix=</a></code>, this method allow you to change the prefix / netmask of an IP address object.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L189","def":{"name":"to_i","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"u32"}},{"id":"to_ipv6-instance-method","html_id":"to_ipv6-instance-method","name":"to_ipv6","doc":"Return the ip address in a format compatible\nwith the IPv6 Mapped IPv4 addresses\n\nExample:\n\n```\nip = Subnet.parse(\"172.16.10.1/24\")\n\nip.to_ipv6\n# => \"ac10:0a01\"\n```","summary":"<p>Return the ip address in a format compatible with the IPv6 Mapped IPv4 addresses</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L930","def":{"name":"to_ipv6","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(hexstring.scan(/..../)).map(&.[](0)).join(\":\")"}},{"id":"to_json(json:JSON::Builder)-instance-method","html_id":"to_json(json:JSON::Builder)-instance-method","name":"to_json","doc":null,"summary":null,"abstract":false,"args":[{"name":"json","doc":null,"default_value":"","external_name":"json","restriction":"JSON::Builder"}],"args_string":"(json : JSON::Builder)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L1187","def":{"name":"to_json","args":[{"name":"json","doc":null,"default_value":"","external_name":"json","restriction":"JSON::Builder"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"json.string(to_string)"}},{"id":"to_s:String-instance-method","html_id":"to_s:String-instance-method","name":"to_s","doc":"Returns a string with the address portion of\nthe IPv4 object\n\n```\nip = Subnet.parse(\"172.16.100.4/22\")\n\nip.to_s\n# => \"172.16.100.4\"\n```","summary":"<p>Returns a string with the address portion of the IPv4 object</p>","abstract":false,"args":[],"args_string":" : String","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L1166","def":{"name":"to_s","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@address"}},{"id":"to_string-instance-method","html_id":"to_string-instance-method","name":"to_string","doc":"Returns a string with the IP address in canonical\nform.\n\n```\nip = Subnet.parse(\"172.16.100.4/22\")\n\nip.to_string\n# => \"172.16.100.4/22\"\n```","summary":"<p>Returns a string with the IP address in canonical form.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L1179","def":{"name":"to_string","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"\"#{@address}/#{@prefix}\""}},{"id":"to_u32-instance-method","html_id":"to_u32-instance-method","name":"to_u32","doc":"Like `IPv4#prefix=`, this method allow you to\nchange the prefix / netmask of an IP address\nobject.\n\n```crystal\nip = Subnet.parse(\"172.16.100.4\")\n\nputs ip\n# => 172.16.100.4/16\n\nip.netmask = \"255.255.252.0\"\n\nputs ip\n# => 172.16.100.4/22\n```","summary":"<p>Like <code><a href=\"../Subnet/IPv4.html#prefix%3D%28num%29-instance-method\">IPv4#prefix=</a></code>, this method allow you to change the prefix / netmask of an IP address object.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L194","def":{"name":"to_u32","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"u32"}},{"id":"u32:Int64-instance-method","html_id":"u32:Int64-instance-method","name":"u32","doc":"Returns the address portion in unsigned\n32 bits integer format.\n\nThis method is identical to the C function\ninet_pton to create a 32 bits address family\nstructure.\n\n```crystal\nip = Subnet.parse(\"10.0.0.0/8\")\n\nip.to_i\n# => 167772160\n```","summary":"<p>Returns the address portion in unsigned 32 bits integer format.</p>","abstract":false,"args":[],"args_string":" : Int64","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv4.cr#L74","def":{"name":"u32","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Int64","visibility":"Public","body":"@u32"}}],"macros":[],"types":[]},{"html_id":"github.com/watzon/subnet/Subnet/IPv6","path":"Subnet/IPv6.html","kind":"class","full_name":"Subnet::IPv6","name":"IPv6","abstract":false,"superclass":{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/subnet/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/subnet/Iterator","kind":"module","full_name":"Iterator","name":"Iterator"},{"html_id":"github.com/watzon/subnet/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/subnet/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"subnet/ipv6.cr","line_number":55,"url":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr"}],"repository_name":"github.com/watzon/subnet","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[{"id":"IN6FORMAT","name":"IN6FORMAT","value":"(\"%04x:\" * 8).chomp(':')","doc":"Format string to pretty print IPv6 addresses","summary":"<p>Format string to pretty print IPv6 addresses</p>"}],"included_modules":[{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/subnet/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/subnet/Iterator","kind":"module","full_name":"Iterator","name":"Iterator"},{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"}],"extended_modules":[],"subclasses":[{"html_id":"github.com/watzon/subnet/Subnet/IPv6/Mapped","kind":"class","full_name":"Subnet::IPv6::Mapped","name":"Mapped"},{"html_id":"github.com/watzon/subnet/Subnet/IPv6/Unspecified","kind":"class","full_name":"Subnet::IPv6::Unspecified","name":"Unspecified"}],"including_types":[],"namespace":{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},"doc":"Class Subnet::IPv6 is used to handle IPv6 type addresses.\n\n## IPv6 addresses\n\nIPv6 addresses are 128 bits long, in contrast with IPv4 addresses\nwhich are only 32 bits long. An IPv6 address is generally written as\neight groups of four hexadecimal digits, each group representing 16\nbits or two octect. For example, the following is a valid IPv6\naddress:\n\n```\n2001:0db8:0000:0000:0008:0800:200c:417a\n```\n\nLetters in an IPv6 address are usually written downcase, as per\nRFC. You can create a new IPv6 object using uppercase letters, but\nthey will be converted.\n\n### Compression\n\nSince IPv6 addresses are very long to write, there are some\nsemplifications and compressions that you can use to shorten them.\n\n* Leading zeroes: all the leading zeroes within a group can be\n  omitted: \"0008\" would become \"8\"\n\n* A string of consecutive zeroes can be replaced by the string\n  \"::\". This can be only applied once.\n\nUsing compression, the IPv6 address written above can be shorten into\nthe following, equivalent, address\n\n```\n2001:db8::8:800:200c:417a\n```\n\nThis short version is often used in human representation.\n\n### Network Mask\n\nAs we used to do with IPv4 addresses, an IPv6 address can be written\nusing the prefix notation to specify the subnet mask:\n\n```\n2001:db8::8:800:200c:417a/64\n```\n\nThe /64 part means that the first 64 bits of the address are\nrepresenting the network portion, and the last 64 bits are the host\nportion.","summary":"<p>Class Subnet::IPv6 is used to handle IPv6 type addresses.</p>","class_methods":[{"id":"compress(str)-class-method","html_id":"compress(str)-class-method","name":"compress","doc":"Compress an IPv6 address in its compressed form\n\n```\nSubnet::IPv6.compress \"2001:0DB8:0000:CD30:0000:0000:0000:0000\"\n# => \"2001:db8:0:cd30::\"\n```","summary":"<p>Compress an IPv6 address in its compressed form</p>","abstract":false,"args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"args_string":"(str)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L582","def":{"name":"compress","args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(self.new(str)).compressed"}},{"id":"expand(str)-class-method","html_id":"expand(str)-class-method","name":"expand","doc":"Expands an IPv6 address in the canocical form\n\n```\nSubnet::IPv6.expand \"2001:0DB8:0:CD30::\"\n# => \"2001:0DB8:0000:CD30:0000:0000:0000:0000\"\n```","summary":"<p>Expands an IPv6 address in the canocical form</p>","abstract":false,"args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"args_string":"(str)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L572","def":{"name":"expand","args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(self.new(str)).address"}},{"id":"groups(str)-class-method","html_id":"groups(str)-class-method","name":"groups","doc":"Extract 16 bits groups from a string","summary":"<p>Extract 16 bits groups from a string</p>","abstract":false,"args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"args_string":"(str)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L612","def":{"name":"groups","args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"l, r = if str =~ (/^(.*)::(.*)$/)\n  [$~[1], $~[2]].map do |i|\n    i.split(\":\")\n  end\nelse\n  [str.split(\":\"), [] of String]\nend\n((l + (Array.new((8 - l.size) - r.size, \"0\"))) + r).map do |s|\n  s.empty? ? \"0\" : s\nend.map(&.to_i(16))\n"}},{"id":"parse_data(data)-class-method","html_id":"parse_data(data)-class-method","name":"parse_data","doc":"Creates a new IPv6 object from binary data,\nlike the one you get from a network stream.\n\nFor example, on a network stream the IP\n\n```\n\"2001:db8::8:800:200c:417a\"\n```\n\nis represented with the binary data\n\n```\n\" \\001\\r\\270\\000\\000\\000\\000\\000\\b\\b\\000 \\fAz\"\n```\n\nWith that data you can create a new IPv6 object:\n\n```\nip6 = Subnet::IPv6::parse_data \" \\001\\r\\270\\000\\000\\000\\000\\000\\b\\b\\000 \\fAz\"\nip6.prefix = 64\n\nip6.to_s\n# => \"2001:db8::8:800:200c:417a/64\"\n```","summary":"<p>Creates a new IPv6 object from binary data, like the one you get from a network stream.</p>","abstract":false,"args":[{"name":"data","doc":null,"default_value":"","external_name":"data","restriction":""}],"args_string":"(data)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L650","def":{"name":"parse_data","args":[{"name":"data","doc":null,"default_value":"","external_name":"data","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.parse_hex(data.to_slice.hexstring)"}},{"id":"parse_hex(hexstring,prefix=128)-class-method","html_id":"parse_hex(hexstring,prefix=128)-class-method","name":"parse_hex","doc":"Creates a new IPv6 object from a number expressed in\nhexdecimal format:\n\n```\nip6 = Subnet::IPv6::parse_hex(\"20010db80000000000080800200c417a\")\nip6.prefix = 64\n\nip6.to_string\n# => \"2001:db8::8:800:200c:417a/64\"\n```\n\nThe +prefix+ parameter is optional:\n\n```\nip6 = Subnet::IPv6::parse_hex(\"20010db80000000000080800200c417a\", 64)\n\nip6.to_string\n# => \"2001:db8::8:800:200c:417a/64\"\n```","summary":"<p>Creates a new IPv6 object from a number expressed in hexdecimal format:</p>","abstract":false,"args":[{"name":"hexstring","doc":null,"default_value":"","external_name":"hexstring","restriction":""},{"name":"prefix","doc":null,"default_value":"128","external_name":"prefix","restriction":""}],"args_string":"(hexstring, prefix = <span class=\"n\">128</span>)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L697","def":{"name":"parse_hex","args":[{"name":"hexstring","doc":null,"default_value":"","external_name":"hexstring","restriction":""},{"name":"prefix","doc":null,"default_value":"128","external_name":"prefix","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.parse_u128(hexstring.to_big_i(16), prefix)"}},{"id":"parse_u128(u128,prefix=128)-class-method","html_id":"parse_u128(u128,prefix=128)-class-method","name":"parse_u128","doc":"Creates a new IPv6 object from an\nunsigned 128 bits integer.\n\n```\nip6 = Subnet::IPv6::parse_u128(42540766411282592856906245548098208122)\nip6.prefix = 64\n\nip6.to_string\n# => \"2001:db8::8:800:200c:417a/64\"\n```\n\nThe +prefix+ parameter is optional:\n\n```\nip6 = Subnet::IPv6::parse_u128(42540766411282592856906245548098208122, 64)\n\nip6.to_string\n# => \"2001:db8::8:800:200c:417a/64\"\n```","summary":"<p>Creates a new IPv6 object from an unsigned 128 bits integer.</p>","abstract":false,"args":[{"name":"u128","doc":null,"default_value":"","external_name":"u128","restriction":""},{"name":"prefix","doc":null,"default_value":"128","external_name":"prefix","restriction":""}],"args_string":"(u128, prefix = <span class=\"n\">128</span>)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L673","def":{"name":"parse_u128","args":[{"name":"u128","doc":null,"default_value":"","external_name":"u128","restriction":""},{"name":"prefix","doc":null,"default_value":"128","external_name":"prefix","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"str = IN6FORMAT % (0..7).map do |i|\n  (u128 >> (112 - (16 * i))) & 65535\nend\nself.new(\"#{str}/#{prefix}\")\n"}}],"constructors":[{"id":"new(str:String)-class-method","html_id":"new(str:String)-class-method","name":"new","doc":"Creates a new IPv6 address object.\n\nAn IPv6 address can be expressed in any of the following forms:\n\n* \"2001:0db8:0000:0000:0008:0800:200C:417A\": IPv6 address with no compression\n* \"2001:db8:0:0:8:800:200C:417A\": IPv6 address with leading zeros compression\n* \"2001:db8::8:800:200C:417A\": IPv6 address with full compression\n\nIn all these 3 cases, a new IPv6 address object will be created, using the default\nsubnet mask /128\n\nYou can also specify the subnet mask as with IPv4 addresses:\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n```","summary":"<p>Creates a new IPv6 address object.</p>","abstract":false,"args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":"String"}],"args_string":"(str : String)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L113","def":{"name":"new","args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":"String"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(str)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}},{"id":"new(value:JSON::PullParser):Subnet::IPv6-class-method","html_id":"new(value:JSON::PullParser):Subnet::IPv6-class-method","name":"new","doc":null,"summary":null,"abstract":false,"args":[{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"JSON::PullParser"}],"args_string":"(value : JSON::PullParser) : Subnet::IPv6","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L732","def":{"name":"new","args":[{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":"JSON::PullParser"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Subnet::IPv6","visibility":"Public","body":"Subnet.parse(value.read_string)"}}],"instance_methods":[{"id":"(oth)-instance-method","html_id":"(oth)-instance-method","name":"<=>","doc":"Spaceship operator to compare IPv6 objects\n\nComparing IPv6 addresses is useful to ordinate\nthem into lists that match our intuitive\nperception of ordered IP addresses.\n\nThe first comparison criteria is the u128 value.\nFor example, 2001:db8:1::1 will be considered\nto be less than 2001:db8:2::1, because, in a ordered list,\nwe expect 2001:db8:1::1 to come before 2001:db8:2::1.\n\nThe second criteria, in case two IPv6 objects\nhave identical addresses, is the prefix. An higher\nprefix will be considered greater than a lower\nprefix. This is because we expect to see\n2001:db8:1::1/64 come before 2001:db8:1::1/65\n\nExample:\n\n```\nip1 = Subnet.parse \"2001:db8:1::1/64\"\nip2 = Subnet.parse \"2001:db8:2::1/64\"\nip3 = Subnet.parse \"2001:db8:1::1/65\"\n\nip1 < ip2\n# => true\nip1 < ip3\n# => false\n\n[ip1, ip2, ip3].sort.map { |i| i.to_string }\n# => [\"2001:db8:1::1/64\",\"2001:db8:1::1/65\",\"2001:db8:2::1/64\"]\n```","summary":"<p>Spaceship operator to compare IPv6 objects</p>","abstract":false,"args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"args_string":"(oth)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L511","def":{"name":"<=>","args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if to_i == oth.to_i\n  return prefix <=> oth.prefix\nend\nto_i <=> oth.to_i\n"}},{"id":"[](index)-instance-method","html_id":"[](index)-instance-method","name":"[]","doc":"Returns the 16-bits value specified by index\n\n```\nip = Subnet::IPv6.new(\"2001:db8::8:800:200c:417a/64\")\n\nip[0]\n# => 8193\nip[1]\n# => 3512\nip[2]\n# => 0\nip[3]\n# => 0\n```","summary":"<p>Returns the 16-bits value specified by index</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"args_string":"(index)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L248","def":{"name":"[]","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@groups[index]"}},{"id":"[]=(index,value)-instance-method","html_id":"[]=(index,value)-instance-method","name":"[]=","doc":"Updated the octet specified at index\n","summary":"<p>Updated the octet specified at index </p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":""}],"args_string":"(index, value)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L259","def":{"name":"[]=","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""},{"name":"value","doc":null,"default_value":"","external_name":"value","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@groups[index] = value\ninitialize(\"#{IN6FORMAT % @groups}/#{prefix}\")\n"}},{"id":"address:String-instance-method","html_id":"address:String-instance-method","name":"address","doc":"Returns the IPv6 address in uncompressed form:\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.address\n# => \"2001:0db8:0000:0000:0008:0800:200c:417a\"\n```","summary":"<p>Returns the IPv6 address in uncompressed form:</p>","abstract":false,"args":[],"args_string":" : String","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L82","def":{"name":"address","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"String","visibility":"Public","body":"@address"}},{"id":"allocate(skip=0)-instance-method","html_id":"allocate(skip=0)-instance-method","name":"allocate","doc":"Allocates a new ip from the current subnet. Optional skip parameter\ncan be used to skip addresses.\n\nWill raise StopIteration exception when all addresses have been allocated\n\nExample:\n\n```\nip = Subnet::IPv6.new(\"10.0.0.0/24\")\nip.allocate\n# => \"10.0.0.1/24\"\nip.allocate\n# => \"10.0.0.2/24\"\nip.allocate(2)\n# => \"10.0.0.5/24\"\n```\n\nUses an internal @allocator which tracks the state of allocated\naddresses.\n","summary":"<p>Allocates a new ip from the current subnet.</p>","abstract":false,"args":[{"name":"skip","doc":null,"default_value":"0","external_name":"skip","restriction":""}],"args_string":"(skip = <span class=\"n\">0</span>)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L721","def":{"name":"allocate","args":[{"name":"skip","doc":null,"default_value":"0","external_name":"skip","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@allocator = @allocator + (1 + skip)\nnext_ip = network_u128 + @allocator\nif next_ip > broadcast_u128\n  return nil\nend\nself.class.parse_u128(next_ip, @prefix)\n"}},{"id":"arpa-instance-method","html_id":"arpa-instance-method","name":"arpa","doc":"Returns the IPv6 address in a DNS reverse lookup\nstring, as per RFC3172 and RFC2874.\n\n```\nip6 = Subnet.parse \"3ffe:505:2::f\"\n\nip6.reverse\n# => \"f.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.0.0.0.5.0.5.0.e.f.f.3.ip6.arpa\"\n```","summary":"<p>Returns the IPv6 address in a DNS reverse lookup string, as per RFC3172 and RFC2874.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L323","def":{"name":"arpa","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"reverse"}},{"id":"bits-instance-method","html_id":"bits-instance-method","name":"bits","doc":"Returns the address portion of an IP in binary format,\nas a string containing a sequence of 0 and 1\n\n```\nip6 = Subnet::IPv6.new(\"2001:db8::8:800:200c:417a\")\n\nip6.bits\n# => \"0010000000000001000011011011100000 [...] \"\n```","summary":"<p>Returns the address portion of an IP in binary format, as a string containing a sequence of 0 and 1</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L562","def":{"name":"bits","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"\"%0128b\" % to_i"}},{"id":"broadcast_u128-instance-method","html_id":"broadcast_u128-instance-method","name":"broadcast_u128","doc":"Returns the broadcast address in Unsigned 128bits format\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.broadcast_u128\n# => 42540766411282592875350729025363378175\n```\n\nPlease note that there is no Broadcast concept in IPv6\naddresses as in IPv4 addresses, and this method is just\nan helper to other functions.\n","summary":"<p>Returns the broadcast address in Unsigned 128bits format</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L352","def":{"name":"broadcast_u128","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(network_u128 + size) - 1"}},{"id":"compressed:String-instance-method","html_id":"compressed:String-instance-method","name":"compressed","doc":"Compressed form of the IPv6 address\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.compressed\n# => \"2001:db8::8:800:200c:417a\"\n```","summary":"<p>Compressed form of the IPv6 address</p>","abstract":false,"args":[],"args_string":" : String","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L396","def":{"name":"compressed","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@compressed"}},{"id":"data-instance-method","html_id":"data-instance-method","name":"data","doc":"Returns the address portion of an IPv6 object\nin a network byte order format.\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.data\n# => \" \\001\\r\\270\\000\\000\\000\\000\\000\\b\\b\\000 \\fAz\"\n```\n\nIt is usually used to include an IP address\nin a data packet to be sent over a socket","summary":"<p>Returns the address portion of an IPv6 object in a network byte order format.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L289","def":{"name":"data","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"String.new(hexstring.hexbytes)"}},{"id":"each(&block)-instance-method","html_id":"each(&amp;block)-instance-method","name":"each","doc":"Iterates over all the IP addresses for the given\nnetwork (or IP address).\n\nThe object yielded is a new IPv6 object created\nfrom the iteration.\n\n```\nip6 = Subnet::IPv6.new(\"2001:db8::4/125\")\n\nip6.each do |i|\n  p i.compressed\nend\n# => \"2001:db8::\"\n# => \"2001:db8::1\"\n# => \"2001:db8::2\"\n# => \"2001:db8::3\"\n# => \"2001:db8::4\"\n# => \"2001:db8::5\"\n# => \"2001:db8::6\"\n# => \"2001:db8::7\"\n```\n\nWARNING: if the host portion is very large, this method\ncan be very slow and possibly hang your system!","summary":"<p>Iterates over all the IP addresses for the given network (or IP address).</p>","abstract":false,"args":[],"args_string":"(&block)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L473","def":{"name":"each","args":[],"double_splat":null,"splat_index":null,"yields":1,"block_arg":null,"return_type":"","visibility":"Public","body":"(network_u128..broadcast_u128).each do |i|\n  yield self.class.parse_u128(i, @prefix)\nend"}},{"id":"group(index)-instance-method","html_id":"group(index)-instance-method","name":"group","doc":"Returns the 16-bits value specified by index\n\n```\nip = Subnet::IPv6.new(\"2001:db8::8:800:200c:417a/64\")\n\nip[0]\n# => 8193\nip[1]\n# => 3512\nip[2]\n# => 0\nip[3]\n# => 0\n```","summary":"<p>Returns the 16-bits value specified by index</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"args_string":"(index)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L253","def":{"name":"group","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self[index]"}},{"id":"groups:Array(Int32)-instance-method","html_id":"groups:Array(Int32)-instance-method","name":"groups","doc":"Returns an array with the 16 bits groups in decimal\nformat:\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.groups\n# => [8193, 3512, 0, 0, 8, 2048, 8204, 16762]\n```","summary":"<p>Returns an array with the 16 bits groups in decimal format:</p>","abstract":false,"args":[],"args_string":" : Array(Int32)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L72","def":{"name":"groups","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Array(Int32)","visibility":"Public","body":"@groups"}},{"id":"hex_groups-instance-method","html_id":"hex_groups-instance-method","name":"hex_groups","doc":"Returns an array of the 16 bits groups in hexdecimal\nformat:\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.hex_groups\n# => [\"2001\", \"0db8\", \"0000\", \"0000\", \"0008\", \"0800\", \"200c\", \"417a\"]\n```\n\nNot to be confused with the similar `IPv6#hexstring` method.\n","summary":"<p>Returns an array of the 16 bits groups in hexdecimal format:</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L305","def":{"name":"hex_groups","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@address.split(\":\")"}},{"id":"hexstring-instance-method","html_id":"hexstring-instance-method","name":"hexstring","doc":"Returns a Base16 number representing the IPv6\naddress\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.hexstring\n# => \"20010db80000000000080800200c417a\"\n```","summary":"<p>Returns a Base16 number representing the IPv6 address</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L273","def":{"name":"hexstring","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"hex_groups.join(\"\")"}},{"id":"includes?(oth)-instance-method","html_id":"includes?(oth)-instance-method","name":"includes?","doc":"Checks whether a subnet includes the given IP address.\n\nExample:\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\naddr = Subnet.parse \"2001:db8::8:800:200c:1/128\"\n\nip6.includes? addr\n# => true\n\nip6.includes? Subnet::IPv6.new(\"2001:db8:1::8:800:200c:417a/76\")\n# => false\n```","summary":"<p>Checks whether a subnet includes the given IP address.</p>","abstract":false,"args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"args_string":"(oth)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L384","def":{"name":"includes?","args":[{"name":"oth","doc":null,"default_value":"","external_name":"oth","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix <= oth.prefix && (network_u128 == (self.class.new(oth.address + \"/#{@prefix}\")).network_u128)"}},{"id":"link_local?-instance-method","html_id":"link_local?-instance-method","name":"link_local?","doc":"Checks if an IPv6 address objects belongs\nto a link-local network RFC4291\n\nExample:\n\n```\nip = Subnet.parse \"fe80::1\"\nip.link_local?\n# => true\n```","summary":"<p>Checks if an IPv6 address objects belongs to a link-local network RFC4291</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L424","def":{"name":"link_local?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(self.class.new(\"fe80::/10\")).includes?(self)"}},{"id":"literal-instance-method","html_id":"literal-instance-method","name":"literal","doc":"Literal version of the IPv6 address\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.literal\n# => \"2001-0db8-0000-0000-0008-0800-200c-417a.ipv6-literal.net\"\n ```","summary":"<p>Literal version of the IPv6 address</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L594","def":{"name":"literal","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(@address.gsub(\":\", \"-\")) + \".ipv6-literal.net\""}},{"id":"loopback?-instance-method","html_id":"loopback?-instance-method","name":"loopback?","doc":"Returns true if the address is a loopback address\n\nSee Subnet::IPv6::Loopback for more information","summary":"<p>Returns true if the address is a loopback address</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L410","def":{"name":"loopback?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(@prefix == 128) && (@compressed == \"::1\")"}},{"id":"mapped?-instance-method","html_id":"mapped?-instance-method","name":"mapped?","doc":"Returns true if the address is a mapped address\n\nSee Subnet::IPv6::Mapped for more information","summary":"<p>Returns true if the address is a mapped address</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L445","def":{"name":"mapped?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(to_u128 >> 32) == 65535"}},{"id":"network-instance-method","html_id":"network-instance-method","name":"network","doc":"Returns a new IPv6 object with the network number\nfor the given IP.\n\n```\nip = Subnet.parse \"2001:db8:1:1:1:1:1:1/32\"\n\nip.network.to_string\n# => \"2001:db8::/32\"\n```","summary":"<p>Returns a new IPv6 object with the network number for the given IP.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L607","def":{"name":"network","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.class.parse_u128(network_u128, @prefix)"}},{"id":"network?-instance-method","html_id":"network?-instance-method","name":"network?","doc":"True if the IPv6 address is a network\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.network?\n# => false\n\nip6 = Subnet.parse \"2001:db8:8:800::/64\"\n\nip6.network?\n# => true\n```","summary":"<p>True if the IPv6 address is a network</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L230","def":{"name":"network?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(to_u128 | @prefix.to_u128) == @prefix.to_u128"}},{"id":"network_u128-instance-method","html_id":"network_u128-instance-method","name":"network_u128","doc":"Returns the network number in Unsigned 128bits format\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.network_u128\n# => 42540766411282592856903984951653826560\n```","summary":"<p>Returns the network number in Unsigned 128bits format</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L335","def":{"name":"network_u128","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"to_u128 & @prefix.to_u128"}},{"id":"next-instance-method","html_id":"next-instance-method","name":"next","doc":"Returns the next IP address in the network, or\n`Iterator::Stop::INSTANCE` when out of\naddresses.","summary":"<p>Returns the next IP address in the network, or <code>Iterator::Stop::INSTANCE</code> when out of addresses.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L533","def":{"name":"next","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"next_i = to_i.succ\nif next_i >= (2.to_big_i ** 64.to_big_i)\n  return Iterator::Stop::INSTANCE\nend\nself.class.parse_u128(next_i, prefix)\n"}},{"id":"pred-instance-method","html_id":"pred-instance-method","name":"pred","doc":"Returns the predecessor to the IP address\n\nExample:\n\n```\nip = Subnet.parse(\"192.168.45.23/16\")\n\nip.pred.to_string\n=> \"192.168.45.22/16\"\n```","summary":"<p>Returns the predecessor to the IP address</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L549","def":{"name":"pred","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.class.parse_u128(to_i.pred, prefix)"}},{"id":"prefix:Prefix128-instance-method","html_id":"prefix:Prefix128-instance-method","name":"prefix","doc":"Returns an instance of the prefix object\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.prefix\n# => 64\n```","summary":"<p>Returns an instance of the prefix object</p>","abstract":false,"args":[],"args_string":" : Prefix128","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L94","def":{"name":"prefix","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Prefix128","visibility":"Public","body":"@prefix"}},{"id":"prefix=(num)-instance-method","html_id":"prefix=(num)-instance-method","name":"prefix=","doc":"Set a new prefix number for the object\n\nThis is useful if you want to change the prefix\nto an object created with IPv6::parse_u128 or\nif the object was created using the default prefix\nof 128 bits.\n\n```\nip6 = Subnet::IPv6.new(\"2001:db8::8:800:200c:417a\")\n\nputs ip6.to_string\n# => \"2001:db8::8:800:200c:417a/128\"\n\nip6.prefix = 64\nputs ip6.to_string\n# => \"2001:db8::8:800:200c:417a/64\"\n```","summary":"<p>Set a new prefix number for the object</p>","abstract":false,"args":[{"name":"num","doc":null,"default_value":"","external_name":"num","restriction":""}],"args_string":"(num)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L150","def":{"name":"prefix=","args":[{"name":"num","doc":null,"default_value":"","external_name":"num","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix = Prefix128.new(num)"}},{"id":"reverse-instance-method","html_id":"reverse-instance-method","name":"reverse","doc":"Returns the IPv6 address in a DNS reverse lookup\nstring, as per RFC3172 and RFC2874.\n\n```\nip6 = Subnet.parse \"3ffe:505:2::f\"\n\nip6.reverse\n# => \"f.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.0.0.0.5.0.5.0.e.f.f.3.ip6.arpa\"\n```","summary":"<p>Returns the IPv6 address in a DNS reverse lookup string, as per RFC3172 and RFC2874.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L318","def":{"name":"reverse","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(hexstring.reverse.gsub(/./) do |c|\n  c + \".\"\nend) + \"ip6.arpa\""}},{"id":"size-instance-method","html_id":"size-instance-method","name":"size","doc":"Returns the number of IP addresses included\nin the network. It also counts the network\naddress and the broadcast address.\n\n```\nip6 = Subnet::IPv6.new(\"2001:db8::8:800:200c:417a/64\")\n\nip6.size\n# => 18446744073709551616\n```","summary":"<p>Returns the number of IP addresses included in the network.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L366","def":{"name":"size","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"2.to_big_i ** @prefix.host_prefix.to_big_i"}},{"id":"succ-instance-method","html_id":"succ-instance-method","name":"succ","doc":"Returns the successor to the IP address\n\nExample:\n\n```\nip = Subnet.parse(\"192.168.45.23/16\")\n\nip.succ.to_string\n=> \"192.168.45.24/16\"\n```","summary":"<p>Returns the successor to the IP address</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L526","def":{"name":"succ","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"self.class.parse_u128(to_i.succ, prefix)"}},{"id":"to_big_i-instance-method","html_id":"to_big_i-instance-method","name":"to_big_i","doc":"Return the address as a `BigInt`","summary":"<p>Return the address as a <code>BigInt</code></p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L213","def":{"name":"to_big_i","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"hexstring.to_big_i(16)"}},{"id":"to_i-instance-method","html_id":"to_i-instance-method","name":"to_i","doc":"Returns a the address in as a `BigInt` (will return a\n`UInt128` once support for that is finished in\nthe stdlib)\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.to_i\n# => 42540766411282592856906245548098208122\n```","summary":"<p>Returns a the address in as a <code>BigInt</code> (will return a <code>UInt128</code> once support for that is finished in the stdlib)</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L203","def":{"name":"to_i","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"to_big_i"}},{"id":"to_json(json:JSON::Builder)-instance-method","html_id":"to_json(json:JSON::Builder)-instance-method","name":"to_json","doc":null,"summary":null,"abstract":false,"args":[{"name":"json","doc":null,"default_value":"","external_name":"json","restriction":"JSON::Builder"}],"args_string":"(json : JSON::Builder)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L736","def":{"name":"to_json","args":[{"name":"json","doc":null,"default_value":"","external_name":"json","restriction":"JSON::Builder"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"json.string(to_string)"}},{"id":"to_s:String-instance-method","html_id":"to_s:String-instance-method","name":"to_s","doc":"Returns the IPv6 address in a human readable form,\nusing the compressed address.\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.to_s\n# => \"2001:db8::8:800:200c:417a\"\n```","summary":"<p>Returns the IPv6 address in a human readable form, using the compressed address.</p>","abstract":false,"args":[],"args_string":" : String","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L189","def":{"name":"to_s","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@compressed"}},{"id":"to_string-instance-method","html_id":"to_string-instance-method","name":"to_string","doc":"Returns the IPv6 address in a human readable form,\nusing the compressed address.\n\n```\nip6 = Subnet.parse \"2001:0db8:0000:0000:0008:0800:200c:417a/64\"\n\nip6.to_string\n# => \"2001:db8::8:800:200c:417a/64\"\n```","summary":"<p>Returns the IPv6 address in a human readable form, using the compressed address.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L176","def":{"name":"to_string","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"\"#{@compressed}/#{@prefix}\""}},{"id":"to_string_uncompressed-instance-method","html_id":"to_string_uncompressed-instance-method","name":"to_string_uncompressed","doc":"Unlike its counterpart IPv6#to_string method, IPv6#to_string_uncompressed\nreturns the whole IPv6 address and prefix in an uncompressed form\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.to_string_uncompressed\n# => \"2001:0db8:0000:0000:0008:0800:200c:417a/64\"\n```","summary":"<p>Unlike its counterpart IPv6#to_string method, IPv6#to_string_uncompressed returns the whole IPv6 address and prefix in an uncompressed form</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L163","def":{"name":"to_string_uncompressed","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"\"#{@address}/#{@prefix}\""}},{"id":"to_u128-instance-method","html_id":"to_u128-instance-method","name":"to_u128","doc":"Returns a the address in as a `BigInt` (will return a\n`UInt128` once support for that is finished in\nthe stdlib)\n\n```\nip6 = Subnet.parse \"2001:db8::8:800:200c:417a/64\"\n\nip6.to_i\n# => 42540766411282592856906245548098208122\n```","summary":"<p>Returns a the address in as a <code>BigInt</code> (will return a <code>UInt128</code> once support for that is finished in the stdlib)</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L208","def":{"name":"to_u128","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"to_big_i"}},{"id":"unique_local?-instance-method","html_id":"unique_local?-instance-method","name":"unique_local?","doc":"Checks if an IPv6 address objects belongs\nto a unique-local network RFC4193\n\nExample:\n\n```\nip = Subnet.parse \"fc00::1\"\nip.unique_local?\n# => true\n```","summary":"<p>Checks if an IPv6 address objects belongs to a unique-local network RFC4193</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L438","def":{"name":"unique_local?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(self.class.new(\"fc00::/7\")).includes?(self)"}},{"id":"unspecified?-instance-method","html_id":"unspecified?-instance-method","name":"unspecified?","doc":"Returns true if the address is an unspecified address\n\nSee Subnet::IPv6::Unspecified for more information","summary":"<p>Returns true if the address is an unspecified address</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L403","def":{"name":"unspecified?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(@prefix == 128) && (@compressed == \"::\")"}}],"macros":[],"types":[{"html_id":"github.com/watzon/subnet/Subnet/IPv6/Mapped","path":"Subnet/IPv6/Mapped.html","kind":"class","full_name":"Subnet::IPv6::Mapped","name":"Mapped","abstract":false,"superclass":{"html_id":"github.com/watzon/subnet/Subnet/IPv6","kind":"class","full_name":"Subnet::IPv6","name":"IPv6"},"ancestors":[{"html_id":"github.com/watzon/subnet/Subnet/IPv6","kind":"class","full_name":"Subnet::IPv6","name":"IPv6"},{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/subnet/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/subnet/Iterator","kind":"module","full_name":"Iterator","name":"Iterator"},{"html_id":"github.com/watzon/subnet/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/subnet/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"subnet/ipv6.cr","line_number":908,"url":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr"}],"repository_name":"github.com/watzon/subnet","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/watzon/subnet/Subnet/IPv6","kind":"class","full_name":"Subnet::IPv6","name":"IPv6"},"doc":"It is usually identified as a IPv4 mapped IPv6 address, a particular\nIPv6 address which aids the transition from IPv4 to IPv6. The\nstructure of the address is\n\n```\n::ffff:w.y.x.z\n```\n\nwhere w.x.y.z is a normal IPv4 address. For example, the following is\na mapped IPv6 address:\n\n```\n::ffff:192.168.100.1\n```\n\nSubnet is very powerful in handling mapped IPv6 addresses, as the\nIPv4 portion is stored internally as a normal IPv4 object. Let's have\na look at some examples. To create a new mapped address, just use the\nclass builder itself\n\n```\nip6 = Subnet::IPv6::Mapped.new \"::ffff:172.16.10.1/128\"\n```\n\nor just use the wrapper method\n\n```\nip6 = Subnet.parse \"::ffff:172.16.10.1/128\"\n```\n\nLet's check it's really a mapped address:\n\n```\nip6.mapped?\n# => true\n\nip6.to_string\n# => \"::FFFF:172.16.10.1/128\"\n```\n\nNow with the +ipv4+ attribute, we can easily access the IPv4 portion\nof the mapped IPv6 address:\n\n```\nip6.ipv4.address\n# => \"172.16.10.1\"\n```\n\nInternally, the IPv4 address is stored as two 16 bits\ngroups. Therefore all the usual methods for an IPv6 address are\nworking perfectly fine:\n\n```\nip6.hexstring\n# => \"00000000000000000000ffffac100a01\"\n\nip6.address\n# => \"0000:0000:0000:0000:0000:ffff:ac10:0a01\"\n```\n\nA mapped IPv6 can also be created just by specify the address in the\nfollowing format:\n\n```\nip6 = Subnet.parse \"::172.16.10.1\"\n```\n\nThat is, two colons and the IPv4 address. However, as by RFC, the ffff\ngroup will be automatically added at the beginning\n\n```\nip6.to_string\n=> \"::ffff:172.16.10.1/128\"\n```\n\nmaking it a mapped IPv6 compatible address.","summary":"<p>It is usually identified as a IPv4 mapped IPv6 address, a particular IPv6 address which aids the transition from IPv4 to IPv6.</p>","class_methods":[],"constructors":[{"id":"new(str)-class-method","html_id":"new(str)-class-method","name":"new","doc":"Creates a new IPv6 IPv4-mapped address\n\n```\nip6 = Subnet::IPv6::Mapped.new \"::ffff:172.16.10.1/128\"\n\nipv6.ipv4.class\n# => Subnet::IPv4\n```\n\nAn IPv6 IPv4-mapped address can also be created using the\nIPv6 only format of the address:\n\n```\nip6 = Subnet::IPv6::Mapped.new \"::0d01:4403\"\n\nip6.to_string\n# => \"::ffff:13.1.68.3\"\n```","summary":"<p>Creates a new IPv6 IPv4-mapped address</p>","abstract":false,"args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"args_string":"(str)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L930","def":{"name":"new","args":[{"name":"str","doc":null,"default_value":"","external_name":"str","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(str)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"ipv4:IPv4-instance-method","html_id":"ipv4:IPv4-instance-method","name":"ipv4","doc":"The internal IPv4 address.","summary":"<p>The internal IPv4 address.</p>","abstract":false,"args":[],"args_string":" : IPv4","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L912","def":{"name":"ipv4","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"IPv4","visibility":"Public","body":"@ipv4"}},{"id":"mapped?-instance-method","html_id":"mapped?-instance-method","name":"mapped?","doc":"Checks if the IPv6 address is IPv4 mapped\n\n```\nip6 = Subnet.parse \"::ffff:172.16.10.1/128\"\n\nip6.mapped?\n# => true\n```","summary":"<p>Checks if the IPv6 address is IPv4 mapped</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L975","def":{"name":"mapped?","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"true"}},{"id":"to_s-instance-method","html_id":"to_s-instance-method","name":"to_s","doc":"Similar to IPv6#to_s, but prints out the IPv4 address\nin dotted decimal format\n\n```\nip6 = Subnet.parse \"::ffff:172.16.10.1/128\"\n\nip6.to_s\n# => \"::ffff:172.16.10.1\"\n```","summary":"<p>Similar to IPv6#to_s, but prints out the IPv4 address in dotted decimal format</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L950","def":{"name":"to_s","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"\"::ffff:#{@ipv4.address}\""}},{"id":"to_string-instance-method","html_id":"to_string-instance-method","name":"to_string","doc":"Similar to IPv6#to_string, but prints out the IPv4 address\nin dotted decimal format\n\n```\nip6 = Subnet.parse \"::ffff:172.16.10.1/128\"\n\nip6.to_string\n# => \"::ffff:172.16.10.1/128\"\n```","summary":"<p>Similar to IPv6#to_string, but prints out the IPv4 address in dotted decimal format</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L963","def":{"name":"to_string","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"\"::ffff:#{@ipv4.address}/#@prefix\""}}],"macros":[],"types":[]},{"html_id":"github.com/watzon/subnet/Subnet/IPv6/Unspecified","path":"Subnet/IPv6/Unspecified.html","kind":"class","full_name":"Subnet::IPv6::Unspecified","name":"Unspecified","abstract":false,"superclass":{"html_id":"github.com/watzon/subnet/Subnet/IPv6","kind":"class","full_name":"Subnet::IPv6","name":"IPv6"},"ancestors":[{"html_id":"github.com/watzon/subnet/Subnet/IPv6","kind":"class","full_name":"Subnet::IPv6","name":"IPv6"},{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/subnet/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/subnet/Iterator","kind":"module","full_name":"Iterator","name":"Iterator"},{"html_id":"github.com/watzon/subnet/Enumerable","kind":"module","full_name":"Enumerable","name":"Enumerable"},{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/subnet/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"subnet/ipv6.cr","line_number":814,"url":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr"}],"repository_name":"github.com/watzon/subnet","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/watzon/subnet/Subnet/IPv6","kind":"class","full_name":"Subnet::IPv6","name":"IPv6"},"doc":"The address with all zero bits is called the +unspecified+ address\n(corresponding to 0.0.0.0 in IPv4). It should be something like this:\n\n```\n0000:0000:0000:0000:0000:0000:0000:0000\n```\n\nbut, with the use of compression, it is usually written as just two\ncolons:\n\n```\n::\n```\n\nor, specifying the netmask:\n\n```\n::/128\n```\n\nWith Subnet, create a new unspecified IPv6 address using its own\nsubclass:\n\n```\nip = Subnet::IPv6::Unspecified.new\n\nip.to_s\n# => => \"::/128\"\n```\n\nYou can easily check if an IPv6 object is an unspecified address by\nusing the IPv6#unspecified? method\n\n```\nip.unspecified?\n# => true\n```\n\nAn unspecified IPv6 address can also be created with the wrapper\nmethod, like we've seen before\n\n```\nip = Subnet.parse \"::\"\n\nip.unspecified?\n# => true\n```\n\nThis address must never be assigned to an interface and is to be used\nonly in software before the application has learned its host's source\naddress appropriate for a pending connection. Routers must not forward\npackets with the unspecified address.","summary":"<p>The address with all zero bits is called the +unspecified+ address (corresponding to 0.0.0.0 in IPv4).</p>","class_methods":[],"constructors":[{"id":"new(bla=nil)-class-method","html_id":"new(bla=nil)-class-method","name":"new","doc":"Creates a new IPv6 unspecified address\n\n```\nip = Subnet::IPv6::Loopback.new\n\nip.to_string\n# => \"::1/128\"\n```","summary":"<p>Creates a new IPv6 unspecified address</p>","abstract":false,"args":[{"name":"bla","doc":null,"default_value":"nil","external_name":"bla","restriction":""}],"args_string":"(bla = <span class=\"n\">nil</span>)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/ipv6.cr#L823","def":{"name":"new","args":[{"name":"bla","doc":null,"default_value":"nil","external_name":"bla","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(bla)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[],"macros":[],"types":[]}]},{"html_id":"github.com/watzon/subnet/Subnet/Prefix","path":"Subnet/Prefix.html","kind":"class","full_name":"Subnet::Prefix","name":"Prefix","abstract":true,"superclass":{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/subnet/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"subnet/prefix.cr","line_number":6,"url":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr"}],"repository_name":"github.com/watzon/subnet","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"}],"extended_modules":[],"subclasses":[{"html_id":"github.com/watzon/subnet/Subnet/Prefix128","kind":"class","full_name":"Subnet::Prefix128","name":"Prefix128"},{"html_id":"github.com/watzon/subnet/Subnet/Prefix32","kind":"class","full_name":"Subnet::Prefix32","name":"Prefix32"}],"including_types":[],"namespace":{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},"doc":"The base class for `Prefix32` and `Prefix128` defining some\ncommon methods that exist in both.","summary":"<p>The base class for <code><a href=\"../Subnet/Prefix32.html\">Prefix32</a></code> and <code><a href=\"../Subnet/Prefix128.html\">Prefix128</a></code> defining some common methods that exist in both.</p>","class_methods":[],"constructors":[{"id":"new(num)-class-method","html_id":"new(num)-class-method","name":"new","doc":"Create a new `Prefix`.","summary":"<p>Create a new <code><a href=\"../Subnet/Prefix.html\">Prefix</a></code>.</p>","abstract":false,"args":[{"name":"num","doc":null,"default_value":"","external_name":"num","restriction":""}],"args_string":"(num)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr#L12","def":{"name":"new","args":[{"name":"num","doc":null,"default_value":"","external_name":"num","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(num)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"+(other)-instance-method","html_id":"+(other)-instance-method","name":"+","doc":"Add this Prefix to another.","summary":"<p>Add this Prefix to another.</p>","abstract":false,"args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"args_string":"(other)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr#L32","def":{"name":"+","args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if other.is_a?(Number)\n  @prefix + other\nelse\n  @prefix + other.prefix\nend"}},{"id":"-(other)-instance-method","html_id":"-(other)-instance-method","name":"-","doc":"Subtract another Prefix from this one.","summary":"<p>Subtract another Prefix from this one.</p>","abstract":false,"args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"args_string":"(other)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr#L41","def":{"name":"-","args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"if other.is_a?(Number)\n  @prefix - other\nelse\n  (@prefix - other.prefix).abs\nend"}},{"id":"(other)-instance-method","html_id":"(other)-instance-method","name":"<=>","doc":"Compare this Prefix to another.","summary":"<p>Compare this Prefix to another.</p>","abstract":false,"args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"args_string":"(other)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr#L27","def":{"name":"<=>","args":[{"name":"other","doc":null,"default_value":"","external_name":"other","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix <=> other.to_i"}},{"id":"prefix:Int32-instance-method","html_id":"prefix:Int32-instance-method","name":"prefix","doc":null,"summary":null,"abstract":false,"args":[],"args_string":" : Int32","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr#L11","def":{"name":"prefix","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"Int32","visibility":"Public","body":"@prefix"}},{"id":"prefix=(prefix:Int32)-instance-method","html_id":"prefix=(prefix:Int32)-instance-method","name":"prefix=","doc":null,"summary":null,"abstract":false,"args":[{"name":"prefix","doc":null,"default_value":"","external_name":"prefix","restriction":"Int32"}],"args_string":"(prefix : Int32)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr#L15","def":{"name":"prefix=","args":[{"name":"prefix","doc":null,"default_value":"","external_name":"prefix","restriction":"Int32"}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix = prefix"}},{"id":"to_i:Int32-instance-method","html_id":"to_i:Int32-instance-method","name":"to_i","doc":"Return this Prefix as an integer.","summary":"<p>Return this Prefix as an integer.</p>","abstract":false,"args":[],"args_string":" : Int32","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr#L22","def":{"name":"to_i","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"@prefix"}},{"id":"to_s(io)-instance-method","html_id":"to_s(io)-instance-method","name":"to_s","doc":"Convert the Prefix to a string.","summary":"<p>Convert the Prefix to a string.</p>","abstract":false,"args":[{"name":"io","doc":null,"default_value":"","external_name":"io","restriction":""}],"args_string":"(io)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr#L17","def":{"name":"to_s","args":[{"name":"io","doc":null,"default_value":"","external_name":"io","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"io << @prefix.to_s"}}],"macros":[],"types":[]},{"html_id":"github.com/watzon/subnet/Subnet/Prefix128","path":"Subnet/Prefix128.html","kind":"class","full_name":"Subnet::Prefix128","name":"Prefix128","abstract":false,"superclass":{"html_id":"github.com/watzon/subnet/Subnet/Prefix","kind":"class","full_name":"Subnet::Prefix","name":"Prefix"},"ancestors":[{"html_id":"github.com/watzon/subnet/Subnet/Prefix","kind":"class","full_name":"Subnet::Prefix","name":"Prefix"},{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/subnet/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"subnet/prefix.cr","line_number":187,"url":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr"}],"repository_name":"github.com/watzon/subnet","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},"doc":null,"summary":null,"class_methods":[],"constructors":[{"id":"new(num=128)-class-method","html_id":"new(num=128)-class-method","name":"new","doc":"Creates a new prefix object for 128 bits IPv6 addresses\n\n```\nprefix = Subnet::Prefix128.new 64\n# => 64\n```","summary":"<p>Creates a new prefix object for 128 bits IPv6 addresses</p>","abstract":false,"args":[{"name":"num","doc":null,"default_value":"128","external_name":"num","restriction":""}],"args_string":"(num = <span class=\"n\">128</span>)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr#L194","def":{"name":"new","args":[{"name":"num","doc":null,"default_value":"128","external_name":"num","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(num)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"bits-instance-method","html_id":"bits-instance-method","name":"bits","doc":"Transforms the prefix into a string of bits\nrepresenting the netmask\n\n```\nprefix = Subnet::Prefix128.new 64\n\nprefix.bits\n# => \"1111111111111111111111111111111111111111111111111111111111111111 \\\n# => 0000000000000000000000000000000000000000000000000000000000000000\"\n```","summary":"<p>Transforms the prefix into a string of bits representing the netmask</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr#L212","def":{"name":"bits","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(\"1\" * @prefix) + (\"0\" * (128 - @prefix))"}},{"id":"host_prefix-instance-method","html_id":"host_prefix-instance-method","name":"host_prefix","doc":"Returns the length of the host portion\nof a netmask.\n\n```\nprefix = Prefix128.new 96\n\nprefix.host_prefix\n# => 32\n```","summary":"<p>Returns the length of the host portion of a netmask.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr#L240","def":{"name":"host_prefix","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"128 - @prefix"}},{"id":"to_u128-instance-method","html_id":"to_u128-instance-method","name":"to_u128","doc":"Unsigned 128 bits decimal number representing\nthe prefix\n\n```\nprefix = Subnet::Prefix128.new 64\n\nprefix.to_u128\n# => 340282366920938463444927863358058659840\n```","summary":"<p>Unsigned 128 bits decimal number representing the prefix</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr#L225","def":{"name":"to_u128","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"bits.to_big_i(2)"}}],"macros":[],"types":[]},{"html_id":"github.com/watzon/subnet/Subnet/Prefix32","path":"Subnet/Prefix32.html","kind":"class","full_name":"Subnet::Prefix32","name":"Prefix32","abstract":false,"superclass":{"html_id":"github.com/watzon/subnet/Subnet/Prefix","kind":"class","full_name":"Subnet::Prefix","name":"Prefix"},"ancestors":[{"html_id":"github.com/watzon/subnet/Subnet/Prefix","kind":"class","full_name":"Subnet::Prefix","name":"Prefix"},{"html_id":"github.com/watzon/subnet/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"github.com/watzon/subnet/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"github.com/watzon/subnet/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"subnet/prefix.cr","line_number":50,"url":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr"}],"repository_name":"github.com/watzon/subnet","program":false,"enum":false,"alias":false,"aliased":"","const":false,"constants":[{"id":"IN4MASK","name":"IN4MASK","value":"4294967295_i64","doc":null,"summary":null}],"included_modules":[],"extended_modules":[],"subclasses":[],"including_types":[],"namespace":{"html_id":"github.com/watzon/subnet/Subnet","kind":"module","full_name":"Subnet","name":"Subnet"},"doc":null,"summary":null,"class_methods":[{"id":"parse_netmask(netmask)-class-method","html_id":"parse_netmask(netmask)-class-method","name":"parse_netmask","doc":"Creates a new prefix by parsing a netmask in\ndotted decimal form\n\n```\nprefix = Subnet::Prefix32::parse_netmask \"255.255.255.0\"\n  #=> 24\n```","summary":"<p>Creates a new prefix by parsing a netmask in dotted decimal form</p>","abstract":false,"args":[{"name":"netmask","doc":null,"default_value":"","external_name":"netmask","restriction":""}],"args_string":"(netmask)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr#L177","def":{"name":"parse_netmask","args":[{"name":"netmask","doc":null,"default_value":"","external_name":"netmask","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"octets = netmask.is_a?(Indexable) ? netmask : netmask.split('.')\nif octets.size == 4\nelse\n  raise(\"netmask must contain 4 octets\")\nend\noctets = octets.map(&.to_u8)\nnum = (((Slice.new(octets.to_unsafe, 4)).hexstring.to_u32(16)).to_s(2)).count(\"1\")\nPrefix32.new(num)\n"}}],"constructors":[{"id":"new(num)-class-method","html_id":"new(num)-class-method","name":"new","doc":"Creates a new prefix object for 32 bits IPv4 addresses\n\n```\nprefix = Subnet::Prefix32.new 24\n# => 24\n```","summary":"<p>Creates a new prefix object for 32 bits IPv4 addresses</p>","abstract":false,"args":[{"name":"num","doc":null,"default_value":"","external_name":"num","restriction":""}],"args_string":"(num)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr#L59","def":{"name":"new","args":[{"name":"num","doc":null,"default_value":"","external_name":"num","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"_ = allocate\n_.initialize(num)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"id":"[](index)-instance-method","html_id":"[](index)-instance-method","name":"[]","doc":"Shortcut for the octecs in the dotted decimal\nrepresentation\n\n```\nprefix = Subnet::Prefix32.new 24\n\nprefix[2]\n# => 255\n```","summary":"<p>Shortcut for the octecs in the dotted decimal representation</p>","abstract":false,"args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"args_string":"(index)","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr#L138","def":{"name":"[]","args":[{"name":"index","doc":null,"default_value":"","external_name":"index","restriction":""}],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"octets[index]"}},{"id":"bits-instance-method","html_id":"bits-instance-method","name":"bits","doc":"Transforms the prefix into a string of bits\nrepresenting the netmask\n\n```\nprefix = Subnet::Prefix32.new 24\n\nprefix.bits\n# => \"11111111111111111111111100000000\"\n```","summary":"<p>Transforms the prefix into a string of bits representing the netmask</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr#L89","def":{"name":"bits","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"\"%.32b\" % to_u32"}},{"id":"host_prefix-instance-method","html_id":"host_prefix-instance-method","name":"host_prefix","doc":"Returns the length of the host portion\nof a netmask.\n\n```\nprefix = Prefix32.new 24\n\nprefix.host_prefix\n# => 8\n```","summary":"<p>Returns the length of the host portion of a netmask.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr#L76","def":{"name":"host_prefix","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"32 - @prefix"}},{"id":"hostmask-instance-method","html_id":"hostmask-instance-method","name":"hostmask","doc":"The hostmask is the contrary of the subnet mask,\nas it shows the bits that can change within the\nhosts\n\n```\nprefix = Subnet::Prefix32.new 24\n\nprefix.hostmask\n# => \"0.0.0.255\"\n```","summary":"<p>The hostmask is the contrary of the subnet mask, as it shows the bits that can change within the hosts</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr#L152","def":{"name":"hostmask","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"hostmask_octets.join('.')"}},{"id":"hostmask_octets-instance-method","html_id":"hostmask_octets-instance-method","name":"hostmask_octets","doc":"Returns an array of octets representing the hostmask\n\n```\nprefix = Subnet::Prefix32.new 24\n\nprefix.hostmask_octets\n# => StaticArray[\"0\", \"0\", \"0\", \"255\"]\n```","summary":"<p>Returns an array of octets representing the hostmask</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr#L164","def":{"name":"hostmask_octets","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"octets = uninitialized ::StaticArray(UInt8, 4)\nIO::ByteFormat::BigEndian.encode(~to_u32.to_u32, octets.to_slice)\noctets\n"}},{"id":"octets-instance-method","html_id":"octets-instance-method","name":"octets","doc":"An array of octets of the IPv4 dotted decimal\nformat\n\n```\nprefix = Subnet::Prefix32.new 24\n\nprefix.octets\n# => [255, 255, 255, 0]\n```","summary":"<p>An array of octets of the IPv4 dotted decimal format</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr#L115","def":{"name":"octets","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(\"%08.64x\" % (bits.to_i64(2))).hexbytes"}},{"id":"to_ip-instance-method","html_id":"to_ip-instance-method","name":"to_ip","doc":"Gives the prefix in IPv4 dotted decimal format,\ni.e. the canonical netmask we're all used to\n\n```\nprefix = Subnet::Prefix32.new 24\n\nprefix.to_ip\n# => \"255.255.255.0\"\n```","summary":"<p>Gives the prefix in IPv4 dotted decimal format, i.e.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr#L102","def":{"name":"to_ip","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"octets.join('.')"}},{"id":"to_u32-instance-method","html_id":"to_u32-instance-method","name":"to_u32","doc":"Unsigned 32 bit number representing the prefix.\n\n  prefix = Subnet::Prefix32.new 24\n\n  prefix.to_u32\n    #=> 4294967040","summary":"<p>Unsigned 32 bit number representing the prefix.</p>","abstract":false,"args":[],"args_string":"","source_link":"https://github.com/watzon/subnet/blob/d399e789cfa7e38c5853f4fbdaeb7624217704e2/src/subnet/prefix.cr#L125","def":{"name":"to_u32","args":[],"double_splat":null,"splat_index":null,"yields":null,"block_arg":null,"return_type":"","visibility":"Public","body":"(IN4MASK >> host_prefix) << host_prefix"}}],"macros":[],"types":[]}]}]}})